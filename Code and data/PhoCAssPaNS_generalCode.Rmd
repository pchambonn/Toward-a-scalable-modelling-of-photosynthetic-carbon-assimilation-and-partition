---
title: Scalable modelling of photosynthetic carbon assimilation and partition during
  nitrogen starvation for the microalga Chlorella vulgaris NIES 227
author: "Paul Chambonniere, Evita Dollon, Alexandra Dimitriades-Lemaire, Jean-François
  Sassi, Florian Delrue"
output: word_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
knitr::opts_chunk$set(message = FALSE,warning = FALSE)

# Define whether to include code in the report
			include_code <- TRUE  # Change this to FALSE to hide code ;  TRUE to show code
```

# Scope

This markdown document aims at showing the results associated to the publication "Scalable modelling of photosynthetic carbon assimilation and partition during nitrogen starvation for the microalga Chlorella vulgaris NIES 227". All the central results shown in the article are developped here. Some extra data analysis which were not included in the final article due to not serving directly the analysis but which were important to develop the article narrative can also be found.

# Initialisation

## Setting path for data file

The path to read the file of data and import the results into the workspace is set below.

```{r set username, include=FALSE}
localPath <- getwd()
```

## Opting IN or opting OUT of the last simulation comparing experimental and simulated data sets

Because the last simulation aiming at directly comparing the experimental data sets with results from the simulation may be long (several hours), an option is proposed here giving the possibility to not run this part of the simulation. 
When the parameter last simulation is activated, a stop module is activated ending the run of the main code.

```{r Choice of running the final simulation, include=FALSE}
lastSimulation <- 1
```

## Load functions and packages

```{r Code preparation, echo = include_code}
# Loading packages

knitr::opts_chunk$set(echo = include_code)
suppressPackageStartupMessages(library(ggplot2))
suppressPackageStartupMessages(library(readxl))
suppressPackageStartupMessages(library(patchwork))
suppressPackageStartupMessages(library(RColorBrewer))
suppressPackageStartupMessages(library(viridis))
suppressPackageStartupMessages(library(ggtern))
suppressPackageStartupMessages(library(dplyr))


# Loading functions

source(paste(localPath,'/Auxiliary R functions/o2cell_light_local_interpol.R',sep = ""),echo=TRUE)

```

## Theme creation

A theme is created to harmonize the figures created for the publication.

```{r Theme creation, echo=TRUE}
# Creation of a ggplot theme, idea provided by https://benjaminlouis-stat.fr/en/blog/2020-05-21-astuces-ggplot-rmarkdown/)
base_size <- 18

theme_paul <- theme_bw(base_size = base_size) %+replace%
  theme(
      # L'ensemble de la figure
      plot.title = element_text(size = rel(0.85), face = "bold", margin = margin(0,0,5,0), hjust = 0.5),
      # Zone où se situe le graphique
      panel.grid.major = element_blank(),
      panel.grid.minor = element_blank(),
      panel.border = element_blank(),
      # Les axes
      axis.title = element_text(size = rel(0.85), face = "bold"),
      axis.text = element_text(size = rel(0.70), face = "bold"),
      axis.line = element_line(color = "black", arrow = arrow(length = unit(0.5, "lines"), type = "closed")),
      # La légende
      # legend.title = element_text(size = rel(0.85), face = "bold"),
      legend.title = element_blank(),
      legend.text = element_text(size = rel(0.70), face = "bold"),
      legend.key = element_rect(fill = "transparent", colour = NA),
      legend.key.size = unit(1.5, "lines"),
      legend.background = element_rect(fill = "transparent", colour = NA),
      legend.box.margin = margin(0.1, 0.05, 0.1 , 0.05),
      legend.box.spacing = unit(3, units = "pt"),
      # Les étiquettes dans le cas d'un facetting
      strip.background = element_rect(fill = "#17252D", color = "#17252D"),
      strip.text = element_text(size = rel(0.85), face = "bold", color = "white", margin = margin(5,0,5,0))
    )


my_color_fill <- viridis(3, alpha = 1, begin = 0, end = 1, direction = 1, option = "D")
my_color_fill_highNumber <- viridis(9, alpha = 1, begin = 0, end = 1, direction = 1, option = "D")
my_color_manual <- viridis(3, alpha = 1, begin = 0, end = 1, direction = 1, option = "D")

theme_paul_highColourFill <- list(theme_paul,scale_fill_manual(values =  my_color_fill_highNumber,na.translate = FALSE),scale_color_manual(values =  my_color_fill_highNumber,na.translate = FALSE))
theme_paul <- list(theme_paul,scale_fill_manual(values =  my_color_fill,na.translate = FALSE),scale_color_manual(values =  my_color_manual,na.translate = FALSE))


```

# Data import and formatting

## Data import

```{r Data import, echo=TRUE}

results_PhoCAssPaNS <- read_excel(paste(localPath,"/Data files/Results_PhoCAssPaNS.xlsx",sep=""), sheet = "Feuil1", col_names = TRUE, n_max = Inf, skip = 2)

```

## Analysis parameters

```{r, echo = include_code}
# Definition of the mesh governing the discretisation of the calculation applied to the respirometry cell for light distribution
n_mesh <- 50 # 50 was use in order to compromise calculation duration

```

## Data formatting

The data from the results data file are implemented in R vectors, prior to introducing these vectors in the final data frame gathering all the needed data.

```{r Data transformation, echo=TRUE}

# Data for raw analysis
## Data on reactor
### Depth of the reactor (m)
reactor_depth <- results_PhoCAssPaNS$`Reactor depth (m)`
### Volume of the reactor(mL) 
reactor_volume<- results_PhoCAssPaNS$`Reactor volume (mL)`
### Volume sampled at each day of sampling
sampled_volume <- results_PhoCAssPaNS$`Volume sampled`

# Data classification: factor vectors aiming at classifying the 3 concentration and the 3 light are created
concentration_class = as.factor(results_PhoCAssPaNS$Concentration)
light_class = as.factor(results_PhoCAssPaNS$Light)


# Data for biomass growth
## Dry-weight (g/L)
### The initial dry weight being determined only for the stock solution, the dilution factor must also be applied
dry_weight = rowMeans(cbind(results_PhoCAssPaNS$DW1,results_PhoCAssPaNS$DW2),na.rm = TRUE)
dry_weight[2:4] <- dry_weight[2:4]*(50/550)
dry_weight[5:7] <- dry_weight[5:7]*(150/550)

## Cell count (cell/mL)
### The same remark applies.
### A data point was found to be significantly off expected value. A dilution error was possible a x2 correction factor was applied.
cell_count = rowMeans(cbind(results_PhoCAssPaNS$`Cell count 1`,results_PhoCAssPaNS$`Cell count 2`)*results_PhoCAssPaNS$`Dilution factor cell count`,na.rm = TRUE)
cell_count[2:4] <- cell_count[2:4]*(50/550)
cell_count[5:7] <- cell_count[5:7]*(150/550)
cell_count[37] <- 2*cell_count[37] 

### Weight specific cell count (cell/mg)
cell_count_specific = cell_count/dry_weight # cell/mg.
### Cell specific weight (mg/cell)
cell_weight = 1/cell_count_specific # mg/cell


## Data cell diameter (µm)
### 10 percentile of cell diameter
cell_size_d10 = results_PhoCAssPaNS$D10
### 25 percentile of cell diameter
cell_size_d25 = results_PhoCAssPaNS$D25
### Median cell diameter
cell_size_d50 = results_PhoCAssPaNS$D50
### 75 percentile of cell diameter
cell_size_d75 = results_PhoCAssPaNS$D75
### 90 percentile of cell diameter
cell_size_d90 = results_PhoCAssPaNS$D90
### Mean cell diameter
cell_size_dmean = results_PhoCAssPaNS$Dmean

# Broth optical properties
## Absorbance for the wavelength 880 nm, 683 nm, 483 nm
abs_880 = results_PhoCAssPaNS$`Dilution factor OD`*results_PhoCAssPaNS$`Abs 880 nm`
abs_683 = results_PhoCAssPaNS$`Dilution factor OD`*results_PhoCAssPaNS$`Abs 683 nm`
abs_483 = results_PhoCAssPaNS$`Dilution factor OD`*results_PhoCAssPaNS$`Abs 483 nm`

# Data TOC measurement:
## TOC and TN contained in the biomass are computed 
### The dilution factor used for TOC measurements are first imported
dilution_factor_TOC <- results_PhoCAssPaNS$`Dilution factor test TOC`
dilution_factor_TOC[2:4] <- dilution_factor_TOC[2:4]
dilution_factor_TOC[5:7] <- dilution_factor_TOC[5:7]
### TOC, TN specific to the dryweight (g/g DW)
toc_specific = results_PhoCAssPaNS$TC/(dry_weight/results_PhoCAssPaNS$`Dilution factor test TOC`*1000)
tn_specific = results_PhoCAssPaNS$TN/(dry_weight/results_PhoCAssPaNS$`Dilution factor test TOC`*1000)
### Ratio C to N contained in the biomass (g C/g N)
cn_ratio = toc_specific/tn_specific
### All TC-TN measurements are now converted on a per cell basis (g C/cell or g N/cell)
toc_cell_specific = results_PhoCAssPaNS$TC*results_PhoCAssPaNS$`Dilution factor test TOC`/1000/(cell_count*1000)
tn_cell_specific = results_PhoCAssPaNS$TN*results_PhoCAssPaNS$`Dilution factor test TOC`/1000/(cell_count*1000)
toc_specific[2:4] <- toc_specific[2:4]*(50/550)
toc_specific[5:7] <- toc_specific[5:7]*(150/550)
tn_specific[2:4] <- tn_specific[2:4]*(50/550)
tn_specific[5:7] <- tn_specific[5:7]*(150/550)
toc_cell_specific[2:4] <- toc_cell_specific[2:4]*(50/550)
toc_cell_specific[5:7] <- toc_cell_specific[5:7]*(150/550)
tn_cell_specific[2:4] <- tn_cell_specific[2:4]*(50/550)
tn_cell_specific[5:7] <- tn_cell_specific[5:7]*(150/550)
### TN content is converted into a protein content based on Templeman et al. (2015)
factor_protein <- 5.04
total_protein <- factor_protein*tn_specific
total_protein_cell <- factor_protein*tn_cell_specific

# Pigments content: pigment content are computed based on absorbance measuremnts of microalgae extracts in DMSO (Wellbrun 1994)
## Concentration in the extracts for chlorophyll-a, -b, and total carotenoids (µg/L)
total_chla <- 12.19*results_PhoCAssPaNS$A_665-3.45*results_PhoCAssPaNS$`A _649`
total_chlb <- 21.99*results_PhoCAssPaNS$`A _649` - 5.32*results_PhoCAssPaNS$A_665
total_carot <- (1000*results_PhoCAssPaNS$A_480 - 2.14*total_chla - 70.16*total_chlb)/220

## Pigment mass specific content (µg pigment/mg algae)
total_chla_specific_weight = total_chla*(results_PhoCAssPaNS$`Volume extraction (mL)`)/(results_PhoCAssPaNS$`Volume sampled (mL)`*dry_weight/results_PhoCAssPaNS$`Dilution factor chl`)
total_chlb_specific_weight = total_chlb*(results_PhoCAssPaNS$`Volume extraction (mL)`)/((results_PhoCAssPaNS$`Volume sampled (mL)`)*dry_weight/results_PhoCAssPaNS$`Dilution factor chl`)
total_carot_specific_weight= total_carot*(results_PhoCAssPaNS$`Volume extraction (mL)`)/((results_PhoCAssPaNS$`Volume sampled (mL)`)*dry_weight/results_PhoCAssPaNS$`Dilution factor chl`)

### Pigment cell specific content (µg pigment/cell)
total_chla_cell_specific_weight = total_chla*(results_PhoCAssPaNS$`Volume extraction (mL)`)/((results_PhoCAssPaNS$`Volume sampled (mL)`)*cell_count/results_PhoCAssPaNS$`Dilution factor chl`)
total_chlb_cell_specific_weight = total_chlb*(results_PhoCAssPaNS$`Volume extraction (mL)`)/((results_PhoCAssPaNS$`Volume sampled (mL)`)*cell_count/results_PhoCAssPaNS$`Dilution factor chl`)
total_carot_cell_specific_weight= total_carot*(results_PhoCAssPaNS$`Volume extraction (mL)`)/((results_PhoCAssPaNS$`Volume sampled (mL)`)*cell_count/results_PhoCAssPaNS$`Dilution factor chl`)


# Lipids content
## Total lipid in the microalgae specific to dryweight are computed as the average of duplicates measurements (g Lipids/g DW)
total_FAME_1 = results_PhoCAssPaNS$`Total FAME`
total_FAME_2 = results_PhoCAssPaNS$`Total FAME 2`
total_FAME = rowMeans(matrix(c(total_FAME_1,total_FAME_2),ncol = 2),na.rm = TRUE)
## A relative error on the measurement is computed as the normalized difference of both duplicates
error_total_FAME = abs(total_FAME_1 - total_FAME_2)/total_FAME
## Total lipid in the microalgae specific to cells are computed from mass specific content and the ratio cell to dryweight concentration (g Lipids/cell)
total_FAME_cell = total_FAME*dry_weight/(cell_count*1000)

# Carbohydrates content
## Total Carbohydrates in the microalgae specific to dryweight are computed as the average of duplicates measurements (g CHO/g DW)
### 0.91 factor takes into account that measurement was made with a glucose (C6H1206) standard when sugar is stored as starch (C6H1205)n in the biomass 
total_sugars_1 = 0.91*results_PhoCAssPaNS$`% 1 (g glucose/g dw)`
total_sugars_2 = 0.91*results_PhoCAssPaNS$`% 2 (g glucose/g dw)`
total_sugars = rowMeans(matrix(c(total_sugars_1,total_sugars_2),ncol = 2),na.rm = TRUE) 
## A relative error on the measurement is computed as the normalized difference of both duplicates
error_total_sugars = abs(total_sugars_1 - total_sugars_2)/total_sugars
## Total Carbohydrates in the microalgae specific to cells are computed from mass specific content and the ratio cell to dryweight concentration (g carbohydrates/cell)
total_sugars_cell = total_sugars*dry_weight/(cell_count*1000) # g carbohydrates/cell

# Photosynthetic parameters measurements
## The data necessary to compute the photosynthetic parameters is imported here
### Volume of the experimental chamber (m3)
V_cell = 5.51*10^(-6)
### Creation of a vector verifying the existence of a test
o2cell_test = as.numeric(!is.na(results_PhoCAssPaNS$`Dilution tested (Factor)`))
### Oxygen production under light conditions measured and error associated [95% CI] for the first and second measurement (g O2/s)
PO2_1 = results_PhoCAssPaNS$`Productivity 1`*V_cell*1000/60/1000 
PO2_1_error = 1.96*results_PhoCAssPaNS$`Error productivity 1`*V_cell*1000/60/1000 
PO2_2 = results_PhoCAssPaNS$`Productivity 2`*V_cell*1000/60/1000 
PO2_2_error = 1.96*results_PhoCAssPaNS$`Error productivity 2`*V_cell*1000/60/1000 
### Respiration rates in the dark measured and error associated [95% CI] for the first and second measurement (g O2/s)
Resp_1 = results_PhoCAssPaNS$`Respiration 1`*V_cell*1000/60/1000 
Resp_1_error = 1.96*results_PhoCAssPaNS$`Error respiration 1`*V_cell*1000/60/1000 
Resp_2 = results_PhoCAssPaNS$`Respiration 2`*V_cell*1000/60/1000 
Resp_2_error = 1.96*results_PhoCAssPaNS$`Error respiration 2`*V_cell*1000/60/1000
### Light intensity set in the software (µmol/m2/s)
I0_O2_cell_1 = results_PhoCAssPaNS$`Light intensity 1`
I0_O2_cell_2 = results_PhoCAssPaNS$`Light intensity 2`
### Dilution factor used for the test from the experimental broth
dilution_factor_O2_cell = results_PhoCAssPaNS$`Dilution tested (Factor)`
### Optical density measured for the photosynthetic test experimental broth (880 nm and 683 nm)
OD_880_O2_cell = results_PhoCAssPaNS$OD880
OD_683_O2_cell = results_PhoCAssPaNS$OD683


# Light data
### Light intensity effectively received in the reactor (µmol/m2/s)
light_intensity_reactor = results_PhoCAssPaNS$`Transmittance filter`*results_PhoCAssPaNS$`Light intensity (mumol/m2/s)`
## The light history of each experimental reactor is collected here
### Total light absorbed globally for the volume from the start of the experiment (µmol photons)
total_light_received = results_PhoCAssPaNS$`Total light absorbed from the start` 
### Total light absorbed globally for the volume between two samplings (µmol photons)
light_absorbed_interval <- results_PhoCAssPaNS$`Light absorbed delta t` 



```

## Compilation in data frame

All the data collected is now logged in a single data frame.

```{r Compilation in a data frame, echo = include_code}

results_PhoCAssPaNS_df = data.frame(day = results_PhoCAssPaNS$Day , sample = results_PhoCAssPaNS$Sample , concentrationClass = concentration_class , lightClass = light_class, 
                                 dryWeight = dry_weight , cellWeight = cell_weight , cellCount = cell_count ,  cellCountSpecific = cell_count_specific ,
                                 cellSizeD10 = cell_size_d10, cellSizeD25 = cell_size_d25, cellSizeD50 = cell_size_d50, cellSizeD75 = cell_size_d75, cellSizeD90 = cell_size_d90, cellSizeDmean = cell_size_dmean,
                                 tocSpecific = toc_specific , tnSpecific = tn_specific, cnRatio = cn_ratio,
                                 tocCellSpecific = toc_cell_specific , tnCellSpecific = tn_cell_specific,
                                 abs880 = abs_880 , abs683 = abs_683 , abs483 = abs_483 ,
                                 totalChlaSpecificWeight = total_chla_specific_weight, totalChlbSpecificWeight = total_chlb_specific_weight ,  totalCarotSpecificWeight = total_carot_specific_weight,
                                 totalChlaCellSpecificWeight = total_chla_cell_specific_weight, totalChlbCellSpecificWeight = total_chlb_cell_specific_weight ,  totalCarotCellSpecificWeight = total_carot_cell_specific_weight,
                                 totalProtein = total_protein, totalProteinCell = total_protein_cell,
                                 totalFAME = total_FAME, errorTotalFAME = error_total_FAME,
                                 totalFAMECell = total_FAME_cell,
                                 totalSugars = total_sugars, erroTotalSugars = error_total_sugars,
                                 totalSugarsCell = total_sugars_cell,
                                 totalLightReceived = total_light_received, lightAbsorbedInterval = light_absorbed_interval,
                                 o2CellTest = o2cell_test, PO21 = PO2_1, PO21Error = PO2_1_error , PO22 = PO2_2, PO22Error = PO2_2_error , Resp1 = Resp_1, Resp1Error = Resp_1_error , Resp2 = Resp_2 , Resp2Error = Resp_2_error , dilutionFactorO2Cell = dilution_factor_O2_cell, OD880O2Cell = OD_880_O2_cell, OD683O2Cell = OD_683_O2_cell, I0O2Cell1 = I0_O2_cell_1, I0O2Cell2 = I0_O2_cell_2,
                                 reactorDepth = reactor_depth, reactorVolume = reactor_volume, sampledVolume = sampled_volume, I0Reactor = light_intensity_reactor)

```

## A posteriori addition of data to the data frame

### Correction of initial pigment content

The first measurement of pigment was measured with different dilutions and must therefore be added manually as done here

```{r A posteriori correction of data, echo = include_code}

results_PhoCAssPaNS_df$totalChlaSpecificWeight[1:10] <- 36.43
results_PhoCAssPaNS_df$totalChlbSpecificWeight[1:10] <- 18.37
results_PhoCAssPaNS_df$totalCarotSpecificWeight[1:10] <- 6.67

results_PhoCAssPaNS_df$totalChlaCellSpecificWeight[1:10] <- 1.48*10^(-6)
results_PhoCAssPaNS_df$totalChlbCellSpecificWeight[1:10] <- 7.44*10^(-7)
results_PhoCAssPaNS_df$totalCarotCellSpecificWeight[1:10] <- 2.70*10^(-7)
```

### O2 cell auxiliary variables

Variables needed for the O2 productivity analyses are added here. 
  - m_algae_O2cell: the total algae mass (dry weight) present in the O2 cell for each measurement (g) 
  - n_algae_O2cell: the number of algae cell present in the O2 cell for each measurement (cell)
Having computed these metrics, we now compute mass or cell specific dark respiration rate as the ratio of the rate of O2 consumption and the biomass content at the time of the experiment (in dryweight or number of cells, respectively)

```{r , echo = include_code, message = FALSE, warning = FALSE, results = 'hide',eval=TRUE}

m_algae_O2cell <- c()
n_algae_O2cell <- c()

for (i in 1:nrow(results_PhoCAssPaNS_df)){
  if (results_PhoCAssPaNS_df$o2CellTest[i] == 1){
    dryweight_O2cell = results_PhoCAssPaNS_df$dryWeight[i]/results_PhoCAssPaNS_df$dilutionFactorO2Cell[i]
    n_cell = results_PhoCAssPaNS_df$cellCount[i]*1000/results_PhoCAssPaNS_df$dilutionFactorO2Cell[i]*V_cell*1000
    if (i %in% seq(2,10,1)){
      dryweight_O2cell = results_PhoCAssPaNS_df$dryWeight[1]/results_PhoCAssPaNS_df$dilutionFactorO2Cell[1]
      n_cell = results_PhoCAssPaNS_df$cellCount[1]*1000/results_PhoCAssPaNS_df$dilutionFactorO2Cell[1]*V_cell*1000 
    }
    m_algae = dryweight_O2cell*V_cell*1000 
    
    m_algae_O2cell <- c(m_algae_O2cell,m_algae)
    n_algae_O2cell <- c(n_algae_O2cell,n_cell)
      
  }else{
    
    m_algae_O2cell <- c(m_algae_O2cell,NA)
    n_algae_O2cell <- c(n_algae_O2cell,NA)    
  }
}

# Adding the data to the data frame
results_PhoCAssPaNS_df$mAlgaeO2cell = m_algae_O2cell
results_PhoCAssPaNS_df$nAlgaeO2cell = n_algae_O2cell


results_PhoCAssPaNS_df$lambdaPhotoresp = -results_PhoCAssPaNS_df$Resp2/results_PhoCAssPaNS_df$mAlgaeO2cell
results_PhoCAssPaNS_df$lambdaDark = -results_PhoCAssPaNS_df$Resp1/results_PhoCAssPaNS_df$mAlgaeO2cell



```

### Extinction coefficients calculation

Light extinction coefficients at 683 nm (sigma_683) and 880 nm (sigma_880) are calculated both mass and cell specific.
The calculation is based on the formula: OD = -log10(T) with T = exp(-sigmaMass*X*d) = exp(-signamCell*nCell*d).
The factor (1/0.01) therefore represents the normalisation of optical density being measured in a 1 cm wide cuvette (d = 0.01 m).

```{r , echo = include_code, message = FALSE, warning = FALSE, results = 'hide',eval=TRUE}
# Calculation

sigma_683_cell = log(10)*(1/0.01)*results_PhoCAssPaNS_df$OD683O2Cell/(results_PhoCAssPaNS_df$nAlgaeO2cell/V_cell) #m2/cell
sigma_880_cell = log(10)*(1/0.01)*results_PhoCAssPaNS_df$OD880O2Cell/(results_PhoCAssPaNS_df$nAlgaeO2cell/V_cell) #m2/cell
sigma_683_mass = log(10)*(1/0.01)*results_PhoCAssPaNS_df$OD683O2Cell/(results_PhoCAssPaNS_df$mAlgaeO2cell/V_cell) #m2/g
sigma_880_mass = log(10)*(1/0.01)*results_PhoCAssPaNS_df$OD880O2Cell/(results_PhoCAssPaNS_df$mAlgaeO2cell/V_cell) #m2/g

# Implementation
results_PhoCAssPaNS_df$sigma683Cell <- sigma_683_cell
results_PhoCAssPaNS_df$sigma880Cell <- sigma_880_cell
results_PhoCAssPaNS_df$sigma683Mass <- sigma_683_mass
results_PhoCAssPaNS_df$sigma880Mass <- sigma_880_mass

```

### Light supply analysis

Total light intensity absorbed, dry-weight or cell specific, is computed here (µmol/s/g DW or µmol/s/cell, respectively) assuming Beer-Lambert law in a cylindrical reactor.

```{r, echo = include_code}

results_PhoCAssPaNS_df$averageLightDensityDryweight <-
  results_PhoCAssPaNS_df$I0Reactor/(results_PhoCAssPaNS_df$reactorDepth*results_PhoCAssPaNS_df$dryWeight*1000)*
  (1-exp(-results_PhoCAssPaNS_df$sigma683Mass*results_PhoCAssPaNS_df$dryWeight*1000*results_PhoCAssPaNS_df$reactorDepth))


results_PhoCAssPaNS_df$averageLightDensityCell <- 
  results_PhoCAssPaNS_df$I0Reactor/(results_PhoCAssPaNS_df$reactorDepth*results_PhoCAssPaNS_df$cellCount*10^6)*
  (1-exp(-results_PhoCAssPaNS_df$sigma683Mass*results_PhoCAssPaNS_df$dryWeight*1000*results_PhoCAssPaNS_df$reactorDepth))

```

### Cell division associated variables

Variables related to cell division are calculated and appended to the main data frame below. Because cell division is calculated based on consecutive data using Euler method, cell specific data or protein specific data will be normalised using interval-averaged data ("MidInterval" vectors).

```{r, echo = include_code}
# Creation of mid interval data to compare growth rate with these quantities
## Cell count in the reactor
aux <- dplyr::lag(results_PhoCAssPaNS_df$cellCount,9)
results_PhoCAssPaNS_df$cellCountMidInterval = c(0.5*(results_PhoCAssPaNS_df$cellCount +  aux))

## Protein cell quota
aux <- dplyr::lag(results_PhoCAssPaNS_df$totalProteinCell,9)
results_PhoCAssPaNS_df$totalProteinCellMidInterval = c(0.5*(results_PhoCAssPaNS_df$totalProteinCell +  aux))

## Protein mass quota
aux <- dplyr::lag(results_PhoCAssPaNS_df$totalProtein,9)
results_PhoCAssPaNS_df$totalProteinMidInterval = c(0.5*(results_PhoCAssPaNS_df$totalProtein +  aux))

# Time derivative of cell count (dN/dt, cell/mL/d)
results_PhoCAssPaNS_df$divisionSpeed <- c(rep(NA,9),diff(results_PhoCAssPaNS_df$cellCount,9))/c(rep(NA,9),diff(results_PhoCAssPaNS_df$day,9))

# Cell division rate (1/N.dN/dt, 1/D)
results_PhoCAssPaNS_df$divisionRate <- 1/results_PhoCAssPaNS_df$cellCountMidInterval*results_PhoCAssPaNS_df$divisionSpeed
```

# Preparation of the analysis

## Reactor specific data frame

A second data frame is created which will serve to store the data generated in the analysis which are characteristic of a single reactor. This data frame will then serve for reactor specific analyses.

```{r, echo = include_code, message=FALSE, warning=FALSE, results='hide'}

reactorPhoCAssPaNS_df <- 
  data.frame(concentrationClass = results_PhoCAssPaNS_df$concentrationClass[2:10],
             lightClass = results_PhoCAssPaNS_df$lightClass[2:10])

```

## Complementary parameters needed for the analysis

Parameters not measured or determined in separate experiments needed for the analysis are referenced in the following block.

```{r, echo = include_code}

# Photosynhtetic parameters values for non-nutrients starved microalgae
## Maximum specific rate of photosynthetic O2 productivity for C vulgaris NIES 227 under nutrient replete conditions (coefficient Pm, g O2/g DW/s)
Pm_0_exp = 9.103757e-04
## Lower bound uncertainty (95% IC) value for Pm
Pm_min_exp = 8.47283e-04 
## Upper bound uncertainty (95% IC) value for Pm
Pm_max_exp = 9.73468e-04 
## Half-saturation constant of C vulgaris NIES 227 for light (µmol/L/s/)
K1_mass = 1.564803*10^(2)
## Inhibition constant of C vulgaris NIES 227 for light(µmol^2/L^2/s^2)
### We note that the value given is the squared value as given in the manuscript. The equation of O2 production used in the R script takes this into account.
K2_mass = 9.593525
### For reference, we compute the value of the square root of K2_mass
sqrt(K2_mass)
## The ratio K1/Pm being assumed constant in all conditions is computed here (µmol.g DW/(g O2.L))
alpha_PI <- K1_mass/Pm_0_exp 

```

## Uncertainty analysis

The uncertainty value on individual measurements and propagation error analysis for basic variables included in the central data frame are referenced and computed in the following block.

```{r, echo = include_code}
# Direct relative error. Values given correspond to the 95% confidence interval
## Relative error on light intensity received by the reactors (%)
I0Reactor_rel_error <- 0.075
## Relative error on dry weight measurements (%)
dryweight_rel_error <- 0.08
## Relative error on cell count measurements and cell division speed (%)
cellCount_rel_error <- 0.15
cellCountMidInterval_rel_error = sqrt(2*cellCount_rel_error^2)
divisionSpeed_rel_error <- cellCountMidInterval_rel_error
divisionRate_rel_error <- sqrt(divisionSpeed_rel_error^2 + cellCountMidInterval_rel_error^2)
## Relative error on reactor depth (%) (this value is a conservative arbitrary value)
depth_rel_error <- 0.05
## Relative error on the optical density measured (%)
OD_rel_error <- 0.01 # from constructor
## Relative error on the O2 cell volume (%) (this value is a conservative arbitrary value)
O2_cell_vol_error <- 0.05 # arbitrary value, somewhat conservative
## Relative error on the pigment concentration error measurement (%) (conservative error based on the repeated mesaurement of Wellburn, 1994 [Table 5])
pigment_concentration_rel_error <- 0.1
## Relative error on the protein factor (%, based on the confidence interval in Templeton et al.)
factor_protein_rel_error <- 0.23
## Relative error on TN measurement (%)
tn_rel_error <- 0.024
## Relative error on dilution factor (%)
dilutionFactor_rel_error <- 0.01
## Relative error on the photosynthetic coefficient alpha_Pi (ratio K1:Pm) and K2 (%)
alpha_PI_rel_error <- 0.059778653
K2_mass_rel_error <- 0.133058292

# Calculated error from error propagation analysis
## Relative error on mass extinction coefficient (%) 
sigma_rel_error <- sqrt(OD_rel_error^2 + dryweight_rel_error^2 )
## Relative error on mass specific light absorbed from the start of the experiment (%) 
averageLightDensityDryweight_rel_error <- sqrt(I0Reactor_rel_error^2 + 2*dryweight_rel_error^2 + 2*depth_rel_error^2 + sigma_rel_error^2)
## Relative error on cell specific light absorbed from the start of the experiment (%)
averageLightDensityCell_rel_error <- sqrt(I0Reactor_rel_error^2 + 2*cellCount_rel_error^2 + 2*depth_rel_error^2 + sigma_rel_error^2)
## Relative error on protein quotas (mass and cell specific, %)
totalProtein_rel_error <- sqrt(factor_protein_rel_error^2 + tn_rel_error^2 + dryweight_rel_error^2 + dilutionFactor_rel_error^2)
totalProteinCell_rel_error <- sqrt(factor_protein_rel_error^2 + tn_rel_error^2 + cellCount_rel_error^2 + dilutionFactor_rel_error^2)
totalProteinCellMidInterval_rel_error = sqrt(2*totalProteinCell_rel_error^2)
totalProteinMidInterval_rel_error = sqrt(2*totalProtein_rel_error^2)
## Relative error on lipid quotas  (mass and cell specific, %)
totalFame_rel_error <- error_total_FAME
### We assume 11% error on lipid mass quota when value is NA due to the absence of replicates
lipid_simplicate <- is.na(totalFame_rel_error)
totalFame_rel_error[lipid_simplicate] <- 0.11
totalFAMECell_rel_error <- sqrt(totalFame_rel_error^2 + dryweight_rel_error^2 + cellCount_rel_error^2)
## Relative error on carbohydrate quotas  (mass and cell specific, %)
totalSugars_rel_error <- error_total_sugars
### We assume 20% error on lipid mass quota when value is NA due to the absence of replicates
sugars_simplicate <- is.na(totalSugars_rel_error)
totalSugars_rel_error[sugars_simplicate] <- 0.20
totalSugarsCell_rel_error <- sqrt(totalSugars_rel_error^2 + dryweight_rel_error^2 + cellCount_rel_error^2)
## Relative error on carbon content  (mass specific, %)
tocSpecific_rel_error <- sqrt(tn_rel_error^2 + dilutionFactor_rel_error^2 +dryweight_rel_error^2)
## Relative error on carbon fixed in the reactor
carbonFixedExp_rel_error <- sqrt(tocSpecific_rel_error^2 + dryweight_rel_error^2)
## Relative error on the functional pool quota (%, mass specific)
functionalPool_abs_error <- sqrt((totalProtein_rel_error*results_PhoCAssPaNS_df$totalProtein)^2 +
                               (totalFame_rel_error*results_PhoCAssPaNS_df$totalFAME)^2 +
                               (totalSugars_rel_error*results_PhoCAssPaNS_df$totalSugars)^2)


## Integration of errors calculated into the data frame, when the errors take the form of vectors
results_PhoCAssPaNS_df$totalFame_rel_error <- totalFame_rel_error
results_PhoCAssPaNS_df$totalFAMECell_rel_error <- totalFAMECell_rel_error
results_PhoCAssPaNS_df$totalSugars_rel_error <- totalSugars_rel_error
results_PhoCAssPaNS_df$totalSugarsCell_rel_error <- totalSugarsCell_rel_error
results_PhoCAssPaNS_df$functionalPool_abs_error <- functionalPool_abs_error

## Integration of errors directly for dark respiration
results_PhoCAssPaNS_df$lambdaPhotorespRelError = sqrt((results_PhoCAssPaNS_df$Resp2Error/results_PhoCAssPaNS_df$Resp2)^2 + dryweight_rel_error^2)
results_PhoCAssPaNS_df$lambdaDarkRelError = sqrt((results_PhoCAssPaNS_df$Resp1Error/results_PhoCAssPaNS_df$Resp1)^2 + dryweight_rel_error^2)

```

## Removing the stock solution sample from analysis

Data from analyses performed on the stock solution were included in the initial, data table. This sample is not relevant for the analysis of the present study and is now removed.

```{r , echo = include_code, message=FALSE, warning=FALSE, results='hide'}
results_PhoCAssPaNS_df <- subset(results_PhoCAssPaNS_df, sample != "Mother")
```

# Data pre-analaysis

## Determination of Pm (specific maximum photosynthetic rate of O2 production)

Pm coefficient is determined from least squared methods when comparing O2 production measured in the O2 cell and O2 theoretically produced according to the Equation presented in the manuscript.

```{r, echo = include_code , fig.height=4.5,fig.width=6.5, message = FALSE , warning = FALSE}
# Options are available for the calculation
## option_plot_local: option to return the plot of the least square function
option_plot_local = 0


# The variables which will be determined in the analysis are initialized here
## Pm_fit_vector: Pm coefficient values will be stored in this vector
## Pm_min: Lower bound on the uncertainty value of Pm will be stored in this vector
## Pm_max: Upper bound on the uncertainty value of Pm will be stored in this vector

Pm_fit_vector = rep(NA,nrow(results_PhoCAssPaNS_df))
Pm_min = rep(NA,nrow(results_PhoCAssPaNS_df))
Pm_max = rep(NA,nrow(results_PhoCAssPaNS_df))

# Loop of the determination
for (iexp in 1:nrow(results_PhoCAssPaNS_df)){
  # A first condition separates the experiment with two measurements available from the experiement with only one point available (first determination and another case during the experiment)
  if ((is.na(results_PhoCAssPaNS_df$dilutionFactorO2Cell[iexp]) == 0) &
      (is.na(results_PhoCAssPaNS_df$I0O2Cell2[iexp]) == 0)){
    
    # Variables needed in each loop are extracted in a local vector used in the calculation loop
    ## P_O2_meas_I1: O2 productivity measured in the first test in light conditions (g O2/s)
    P_O2_meas_I1 = results_PhoCAssPaNS_df$PO21[iexp]
    ## P_O2_meas_I1_error: Error on O2 productivity measured in the first test in light conditions (standard error, g O2/s)
    P_O2_meas_I1_error = results_PhoCAssPaNS_df$PO21Error[iexp]
    ## P_O2_meas_I2: O2 productivity measured in the second test in light conditions (g O2/s)
    P_O2_meas_I2 = results_PhoCAssPaNS_df$PO22[iexp] # gO2/s
    ## P_O2_meas_I1_error: Error on O2 productivity measured in the second test in light conditions (standard error, g O2/s)
    P_O2_meas_I2_error = results_PhoCAssPaNS_df$PO22Error[iexp] # gO2/s
    ## I1: software light intensity applied in the first test (µmol/m2/s)
    I1 = results_PhoCAssPaNS_df$I0O2Cell1[iexp]
    ## I2: software light intensity applied in the second test (µmol/m2/s)
    I2 = results_PhoCAssPaNS_df$I0O2Cell2[iexp] # µmol/m2/s
    ## Optical density measured for the experiment at 880 nm
    OD_880 = results_PhoCAssPaNS_df$OD880O2Cell[iexp] # NA
    ## X_algae: Dryweight concentration in the O2 cell during the experiemnt (g/L)
    X_algae = results_PhoCAssPaNS_df$mAlgaeO2cell[iexp]/(V_cell*10^3) # dryweight in the cell for the experiment (g/L)
    ## lambda1: specific dark respiration rate in the first (gO2/g/s)
    lambda1 = results_PhoCAssPaNS_df$lambdaDark[iexp]
    ## lambda1RelError: error on specific dark respiration rate in the first test (standard deviation, gO2/g/s)
    lambda1RelError = results_PhoCAssPaNS_df$lambdaDarkRelError[iexp]
    ## lambda2: specific dark respiration rate in the second test (gO2/g/s)
    lambda2 = results_PhoCAssPaNS_df$lambdaPhotoresp[iexp] # gO2/g/s
    ## lambda2RelError: error on specific dark respiration rate in the second test (standard deviation, gO2/g/s)
    lambda2RelError = results_PhoCAssPaNS_df$lambdaPhotorespRelError[iexp]
    ## sigma_683: Mass specific extinction coefficient at 683 nm during the experiemnt (m2/g)
    sigma_683 <- results_PhoCAssPaNS_df$sigma683Mass[iexp]
    
    # We now create the tensor of local light intensities in the volume of the O2 cell with definition n_mesh over each cylindrical coordinates (r,teta,z). The data is generated using the function  o2cell_light_local_interpol. 
    ## In the case only one value of light intensity exists, the light intensity is set to the value 'NA'
    
    I_cell_table_1 = o2cell_light_local_interpol(n = n_mesh, I_software = I1 , OD_880 = OD_880, path = paste(localPath,'/Auxiliary R functions/',sep=""))
    if (is.na(I2) == 0){
      I_cell_table_2 = o2cell_light_local_interpol(n = n_mesh, I_software = I2 , OD_880 = OD_880, path = paste(localPath,'/Auxiliary R functions/',sep="")) 
    }else{
      I_cell_table_2 <- NA
    }  
    
    I_cell_model_1 = I_cell_table_1$I_cell
    if (is.na(I2) == 0){
      I_cell_model_2 = I_cell_table_2$I_cell
    }
    
    # Obtention of cylindric coordinate (r,teta,z) to perform discretised calculations over the volume of the O2 cell. The vectors are directly obtained from the data generated by running the o2cell_light_local_interpol function
    rcoordinates = I_cell_table_1$rcoordinates
    tetacoordinates = I_cell_table_1$tetacoordinates
    zcoordinates = I_cell_table_1$zcoordinates
    
    # The tensor of the local elementary volume values for the definition used in light distribution calculation. This elementary volume array has one less unit of length for the 3 coordinates.
    # An extra line of NA values for each dimension was voluntarily left in elementary volume mesh as it simplifies the restriction of I_cell on the inner mesh
    
    dV <- array(NA,dim = c(n_mesh,n_mesh,n_mesh + 1))
    
    for (i in 1:(dim(dV)[1])){
      for (j in 1:(dim(dV)[2])){
        for (k in 1:(dim(dV)[3]-1)){
          dV[i,j,k] <- rcoordinates[i]*(rcoordinates[i+1]-rcoordinates[i])*(tetacoordinates[j+1]-tetacoordinates[j])*(zcoordinates[k+1]-zcoordinates[k]) 
        }
      }
    }
    
    for (i in 1:(dim(dV)[1])){
      for (j in 1:(dim(dV)[2])){
        dV[i,j,n_mesh+1] <- rcoordinates[i]*(rcoordinates[i+1]-rcoordinates[i])*(tetacoordinates[j+1]-tetacoordinates[j])*(zcoordinates[n_mesh+1]-zcoordinates[n_mesh])
      }
    }
    # The coordinates vector of r and teta are shortened by one to enable simpler direct calculation when doing the product of elementary tensors and the coordinates vectors.
    rcoordinates <- rcoordinates[2:length(rcoordinates)]
    tetacoordinates <- tetacoordinates[1:(length(tetacoordinates)-1)]  
    
    # The optimisation function being the sum of the squared residuals to be minimized is created with all local values henceforth created
    Pm_optim <- function(Pm_fit){
      (P_O2_meas_I1 -
         sum(((Pm_fit*sigma_683*(X_algae)*I_cell_model_1)/(alpha_PI*Pm_fit + sigma_683*(X_algae)*I_cell_model_1 + (1/K2_mass)*(sigma_683*(X_algae)*I_cell_model_1)^2) -  lambda1)*X_algae*dV*10^3,na.rm = TRUE))^2 +
      (P_O2_meas_I2 -
         sum(((Pm_fit*sigma_683*(X_algae)*I_cell_model_2)/(alpha_PI*Pm_fit + sigma_683*(X_algae)*I_cell_model_2 + (1/K2_mass)*(sigma_683*(X_algae)*I_cell_model_2)^2) - lambda2)*X_algae*dV*10^3,na.rm = TRUE))^2
    }

    # The fitting algorithm is performed. This is based on the optim function, with Nelder-Mead algorithm. The  value of the maximum theoretical Pm coefficient as determined in the independent experiment of non-starved microalgae is used as initialisation value. A low value for relative tolerance (10^-(20)) is set to increase precision of the determination.

    fitted <- optimize(Pm_optim,c(0,1.1),tol = 10^(-20))
    
    # The fitted value is stored in the vector created
    Pm_fit_vector[iexp] <- fitted$minimum
    
    # A plot of the current least square function (SSR = f(Pm)) is created to eye-verify the outcome of the fit, precision of the fit, and possible issues with the fit. This plot is using log transformed values for both the Pm (x-axis) and SSR (y-axis)
    if (option_plot_local == 1){
      x <- seq(-7,0,0.01)
      x2 <- c(0,10^x)
      y <- sapply(x2,Pm_optim)

      x <- c(-8,x)
      plot(x,log10(y))
      title(iexp)
    }
    
    # In some case, the algorithm did not retune any minimum value, likely due to productivity over the max potential maximum given by the function (bounded). Assuming uncertainty caused the overshoot of the measured productivity, and that the Pm coefficient determined in the independent experiemnt on non starved algae returned the max theoretical value for Pm, this value was implemented in such cases.  
    if (Pm_fit_vector[iexp] > 1){
      Pm_fit_vector[iexp] <- Pm_0_exp
    }

    
    # Error analysis: 
    ## Having determined the Pm coefficient, the error on this parameter is also determined
    ## The coefficients as described in SI-3 of the manuscript are calculated
    
    beta_1 <- mean(alpha_PI*Pm_fit_vector[iexp] + sigma_683*(X_algae)*I_cell_model_1 +
      (1/K2_mass)*(sigma_683*(X_algae)*I_cell_model_1)^2)
    beta_2 <- mean(alpha_PI*Pm_fit_vector[iexp] + sigma_683*(X_algae)*I_cell_model_2 +
      (1/K2_mass)*(sigma_683*(X_algae)*I_cell_model_2)^2)
    alpha_1 <- Pm_fit_vector[iexp]*sigma_683*(X_algae)*I_cell_model_1
    alpha_2 <- Pm_fit_vector[iexp]*sigma_683*(X_algae)*I_cell_model_2
    mu_1 <- sum(alpha_1/beta_1*X_algae*dV*10^3,na.rm = TRUE)
    mu_2 <- sum(alpha_2/beta_2*X_algae*dV*10^3,na.rm = TRUE)
    eta_1 <- lambda1*X_algae*(V_cell*1000)
    eta_2 <- lambda2*X_algae*(V_cell*1000)
    
    gamma_1 <- P_O2_meas_I1 - mu_1 + eta_1
    gamma_2 <- P_O2_meas_I2 - mu_2 + eta_2
      
    alpha_rel_error <- sqrt(dryweight_rel_error^2 + I0Reactor_rel_error^2 + sigma_rel_error^2)  
    beta_1_rel_error <- 1/abs(beta_1)*
      sqrt((alpha_PI_rel_error*alpha_PI*Pm_fit_vector[iexp])^2 +
             (sigma_683*(X_algae)*I_cell_model_1)^2*
                (dryweight_rel_error^2 + I0Reactor_rel_error^2 + sigma_rel_error^2) +
             (((alpha_1/sqrt(K2_mass))^2)*sqrt(2*alpha_rel_error^2 + 2*K2_mass_rel_error^2))^2)
    beta_2_rel_error <- 1/abs(beta_2)*
      sqrt((alpha_PI_rel_error*alpha_PI*Pm_fit_vector[iexp])^2 +
             (sigma_683*(X_algae)*I_cell_model_2)^2*
                (dryweight_rel_error^2 + I0Reactor_rel_error^2 + sigma_rel_error^2) +
             (((alpha_2/sqrt(K2_mass))^2)*sqrt(2*alpha_rel_error^2 + 2*K2_mass_rel_error^2))^2)
    
    mu_1_rel_error <- 1/abs(mu_1)*sqrt(sum(
      (alpha_1/beta_1*X_algae*dV*10^3)^2*
        (alpha_rel_error^2 + beta_1_rel_error^2 + dryweight_rel_error^2 + O2_cell_vol_error^2),
                               na.rm = TRUE))
    mu_2_rel_error <- 1/abs(mu_2)*sqrt(sum(
      (alpha_2/beta_2*X_algae*dV*10^3)^2*
        (alpha_rel_error^2 + beta_2_rel_error^2 + dryweight_rel_error^2 + O2_cell_vol_error^2),
                               na.rm = TRUE))
    eta_1_rel_error <- sqrt(lambda1RelError^2 + dryweight_rel_error^2 + O2_cell_vol_error^2)
    eta_2_rel_error <- sqrt(lambda2RelError^2 + dryweight_rel_error^2 + O2_cell_vol_error^2)
  
      
    gamma_1_rel_error <- 1/abs(gamma_1)*sqrt(
      P_O2_meas_I1_error^2 + 
        (mu_1_rel_error*mu_1)^2 +
        (eta_1_rel_error*eta_1)^2)
    gamma_2_rel_error <- 1/abs(gamma_2)*sqrt(
      P_O2_meas_I2_error^2 + 
        (mu_2_rel_error*mu_2)^2 +
        (eta_2_rel_error*eta_2)^2)
    
    
    
    # Because it is challenging to apply the absolute error on the minimum of the function, we assess the relative error on the function Pm_optim evaluation as the average of the relative errors for gamma_1^2 and gamma_2^2 terms
    Pm_optim_error_rel_error <- mean(sqrt(2)*gamma_1_rel_error, sqrt(2)*gamma_2_rel_error)
    
    # An error function being the Pm_optim function deviated by the error value previously determined when evaluated in Pm is created. This function will take the values 0 for the upper and lower bound of uncertainty on Pm. The lower error is searched for between 10^(-8) and the Pm coefficient previously determined, the upper error is searched for between Pm previously determined and 10^(-1). The values are then stored in the respective vectors created.
    Pm_optim_error_function <- function(x){
      Pm_optim(x) - (1 + Pm_optim_error_rel_error)*Pm_optim(Pm_fit_vector[iexp])
    }
    
    # The roots of the function Pm_optim are now investigated. 
    if ((class(try(uniroot(Pm_optim_error_function,interval = c(10^(-8),Pm_fit_vector[iexp])),silent = TRUE)) == "try-error") == TRUE){
      Pm_min[iexp] <- Pm_fit_vector[iexp]
    }else{
      a <- uniroot(Pm_optim_error_function,interval = c(10^(-8),Pm_fit_vector[iexp]), tol = 0.01*Pm_optim(Pm_fit_vector[iexp]))
      Pm_min[iexp] <- a$root
    }
    
    if ((class(try(uniroot(Pm_optim_error_function,interval = c(Pm_fit_vector[iexp],10^(-1))),silent = TRUE)) == "try-error") == TRUE){
      Pm_max[iexp] <- Pm_fit_vector[iexp]
    }else{
      b <- uniroot(Pm_optim_error_function,interval = c(Pm_fit_vector[iexp],10^(-1)), tol = 0.01*Pm_optim(Pm_fit_vector[iexp]))
    
      Pm_max[iexp] <- b$root
    }
    
    ## In the case Pm coefficient could not be determined and the value determined independently in non-starved conditions was implemented, the uncertainty values likewise determined are also implemented.
    
    if (Pm_fit_vector[iexp] == Pm_0_exp){
      Pm_min[iexp] <- Pm_min_exp
      Pm_max[iexp] <- Pm_max_exp
    }
  # The experiments with only one point available are now likewise investigated   
  }else{
    if (is.na(results_PhoCAssPaNS_df$dilutionFactorO2Cell[iexp]) == 0){
      Pm_optim <- function(Pm_fit){
        (P_O2_meas_I1 -
           sum(((Pm_fit*sigma_683*(X_algae)*I_cell_model_1)/(alpha_PI*Pm_fit + sigma_683*(X_algae)*I_cell_model_1 + (1/K2_mass)*(sigma_683*(X_algae)*I_cell_model_1)^2) -  lambda1)*X_algae*dV*10^3,na.rm = TRUE))^2
      }

      # fitted <- optim(par = c(10^(-4)), fn = Pm_optim, method = "Nelder-Mead", # lower = c(0),
      #               control = list(trace = TRUE, reltol = 10^(-20)))
      fitted <- optimize(Pm_optim,c(0,1.1),tol = 10^(-20))
    
      Pm_fit_vector[iexp] <- fitted$minimum
      
      if (option_plot_local == 1){
        x <- seq(-7,0,0.01)
        x2 <- 10^x
        y <- sapply(x2,Pm_optim)
        
        plot(x,log10(y))
        title(c(iexp,"1 point"))
      }
      
      
      # Error analysis
      
      beta_1 <- mean(alpha_PI*Pm_fit_vector[iexp] + sigma_683*(X_algae)*I_cell_model_1 +
        (1/K2_mass)*(sigma_683*(X_algae)*I_cell_model_1)^2)
      alpha_1 <- Pm_fit_vector[iexp]*sigma_683*(X_algae)*I_cell_model_1
      mu_1 <- sum(alpha_1/beta_1*X_algae*dV*10^3,na.rm = TRUE)
      eta_1 <- lambda1*X_algae*(V_cell*1000)
      
      gamma_1 <- P_O2_meas_I1 - mu_1 + eta_1
        
      alpha_rel_error <- sqrt(dryweight_rel_error^2 + I0Reactor_rel_error^2 + sigma_rel_error^2)  
      beta_1_rel_error <- 1/abs(beta_1)*
        sqrt((alpha_PI_rel_error*alpha_PI*Pm_fit_vector[iexp])^2 +
               (sigma_683*(X_algae)*I_cell_model_1)^2*
                  (dryweight_rel_error^2 + I0Reactor_rel_error^2 + sigma_rel_error^2) +
               (((alpha_1/sqrt(K2_mass))^2)*sqrt(2*alpha_rel_error^2 + 2*K2_mass_rel_error^2))^2)
      mu_1_rel_error <- 1/abs(mu_1)*sqrt(sum(
        (alpha_1/beta_1*X_algae*dV*10^3)^2*
          (alpha_rel_error^2 + beta_1_rel_error^2 + dryweight_rel_error^2 + O2_cell_vol_error^2),
                                 na.rm = TRUE))
      eta_1_rel_error <- sqrt(lambda1RelError^2 + dryweight_rel_error^2 + O2_cell_vol_error^2)
        
      gamma_1_rel_error <- 1/abs(gamma_1)*sqrt(
        P_O2_meas_I1_error^2 + 
          (mu_1_rel_error*mu_1)^2 +
          (eta_1_rel_error*eta_1)^2)
      
      Pm_optim_error_rel_error <- sqrt(2)*gamma_1_rel_error
      print(Pm_optim_error_rel_error)
      Pm_optim_error_function <- function(x){
        Pm_optim(x) - (1 + Pm_optim_error_rel_error)*Pm_optim(Pm_fit_vector[iexp])
      }
      
      if ((class(try(uniroot(Pm_optim_error_function,interval = c(10^(-7),Pm_fit_vector[iexp])),silent = TRUE)) == "try-error") |
          (class(try(uniroot(Pm_optim_error_function,interval = c(Pm_fit_vector[iexp],10^(-1))),silent = TRUE)) == "try-error")){
      }else{
        a <- uniroot(Pm_optim_error_function,interval = c(10^(-8),Pm_fit_vector[iexp]), tol = 0.01*Pm_optim(Pm_fit_vector[iexp]))
        b <- uniroot(Pm_optim_error_function,interval = c(Pm_fit_vector[iexp],10^(-1)), tol = 0.01*Pm_optim(Pm_fit_vector[iexp]))
      
        Pm_min[iexp] <- a$root
        Pm_max[iexp] <- b$root
      }
    }
  }
}

results_PhoCAssPaNS_df$PmMass <- Pm_fit_vector
results_PhoCAssPaNS_df$PmMassMin <- Pm_min
results_PhoCAssPaNS_df$PmMassMax <- Pm_max


Pm_fit_vector-Pm_max

max(Pm_fit_vector,na.rm = TRUE)
min(Pm_fit_vector,na.rm = TRUE)
mean(Pm_fit_vector,na.rm = TRUE)

```

## Per reactor light density

Reactor and biomass specific light intensity absorbed is computed as the averaged value over the full experiment for each experiment, and saved in the per reactor data frame reactorPhoCAssPaNS_df (µmol/s/g-DW and µmol/s/cell)

```{r, echo = include_code}
concentrationClassList = c("0.1 g.L-1","0.3 g.L-1","1.0 g.L-1")
lightClassList = c("25%","50%","100%")

lightDensity <- rep(NA,9)
lightDensity_std <- rep(NA,9)
lightDensityCell <- rep(NA,9)
lightDensityCell_std <- rep(NA,9)

for (i_concentration in (1:3)){
  for (j_light in (1:3)){

    data_reduced <- subset(results_PhoCAssPaNS_df, concentrationClass == concentrationClassList[i_concentration])
    data_reduced <- subset(data_reduced, data_reduced$lightClass == lightClassList[j_light])
    
    lightDensity[3*(i_concentration - 1) + j_light] <- mean(data_reduced$averageLightDensityDryweight,na.rm = TRUE)
    lightDensity_std[3*(i_concentration - 1) + j_light] <- sd(data_reduced$averageLightDensityDryweight,na.rm = TRUE)
    
    lightDensityCell[3*(i_concentration - 1) + j_light] <- mean(data_reduced$averageLightDensityCell,na.rm = TRUE)
    lightDensityCell_std[3*(i_concentration - 1) + j_light] <- sd(data_reduced$averageLightDensityCell,na.rm = TRUE)
  }
}

reactorPhoCAssPaNS_df$lightDensity = lightDensity
reactorPhoCAssPaNS_df$lightDensityStd = lightDensity_std
reactorPhoCAssPaNS_df$lightDensityCell = lightDensityCell
reactorPhoCAssPaNS_df$lightDensityCell_std = lightDensityCell_std


```

## Carbon fixed by the biomass

The carbon fixed by the biomass during the experiment in the form of carbohydrate, lipids, proteins, the sum of the three, as well as the total carbon in the suspended phase are determined for each reactor. Yields are defined for each macromolecules, and the values are determined based on the previously determined pool biomass content, and biomass concentration in the reactors. Error analysis is also performed in the following paragraph.

```{r, echo = include_code}
# Carbon content in the carbohydrates (g C/g CHO)
Y_C_CHO <- 0.439
# Carbon content in the lipids (g C/g lipids)
Y_C_L <- 0.8522 # g C/g Lipids
# Carbon content in the proteins (g C/g proteins)
Y_C_P <- 1/1.52 # g C/g protein

# Relative error on the carbon yields for macromolecules
Y_C_L_rel_error = 0.01 # based on SD in analysis of carbon content
Y_C_CHO_rel_error = 0.01 # as lipids
Y_C_P_rel_error = 0.23 # from Templeton et al. (2015)

# Calculations
## Experimental total carbon fixed (g C/L)
carbon_fixed_exp <- results_PhoCAssPaNS_df$tocSpecific*results_PhoCAssPaNS_df$dryWeight
## Experimental total carbon fixed as carbohydrates (g C-CHO/L)
carbon_fixed_CHO_exp <- Y_C_CHO*results_PhoCAssPaNS_df$totalSugars*results_PhoCAssPaNS_df$dryWeight
## Experimental total carbon fixed as proteins (g C-proteins/L)
carbon_fixed_proteins_exp <- Y_C_P*results_PhoCAssPaNS_df$tnSpecific*factor_protein*results_PhoCAssPaNS_df$dryWeight
## Experimental total carbon fixed as lipids (g C-lipids/L)
carbon_fixed_lipids_exp <- Y_C_L*results_PhoCAssPaNS_df$totalFAME*results_PhoCAssPaNS_df$dryWeight
## Total functional carbon (sum of the carbon content in proteins, lipids, and CHO) concentration (g C/L)
carbon_functional <- carbon_fixed_CHO_exp + carbon_fixed_lipids_exp + carbon_fixed_proteins_exp

## Appending data to the central data frame
results_PhoCAssPaNS_df$carbonFixedExp <- carbon_fixed_exp
results_PhoCAssPaNS_df$carbonFixedCHOExp <- carbon_fixed_CHO_exp
results_PhoCAssPaNS_df$carbonFixedProteinsExp <- carbon_fixed_proteins_exp
results_PhoCAssPaNS_df$carbonFixedLipidsExp <- carbon_fixed_lipids_exp
results_PhoCAssPaNS_df$carbonFunctional <- carbon_functional

# Uncertainty analysis
## All uncertainty values are computed from error propagation analysis
carbonFixedCHOExp_rel_error <- sqrt(Y_C_CHO_rel_error^2 + 
                                      results_PhoCAssPaNS_df$totalSugars_rel_error^2 +
                                      dryweight_rel_error^2)
carbonFixedProteinsExp_rel_error <-
  sqrt(Y_C_P_rel_error^2 + totalProtein_rel_error^2 + dryweight_rel_error^2)
carbonFixedLipidsExp_rel_error <-
  sqrt(Y_C_L_rel_error^2 + 
         results_PhoCAssPaNS_df$totalFame_rel_error^2 +
         dryweight_rel_error^2)
carbonFunctional_rel_error <- 
  sqrt((carbonFixedCHOExp_rel_error*carbon_fixed_CHO_exp)^2 + 
         (carbonFixedProteinsExp_rel_error*carbon_fixed_proteins_exp)^2 +
         (carbonFixedLipidsExp_rel_error*carbon_fixed_lipids_exp)^2)/
  carbon_functional

## Appending data to the central data frame
results_PhoCAssPaNS_df$carbonFixedCHOExp_rel_error <- carbonFixedCHOExp_rel_error
results_PhoCAssPaNS_df$carbonFixedProteinsExp_rel_error  <- carbonFixedProteinsExp_rel_error
results_PhoCAssPaNS_df$carbonFixedLipidsExp_rel_error <-  carbonFixedLipidsExp_rel_error
results_PhoCAssPaNS_df$carbonFunctional_rel_error  <- carbonFunctional_rel_error

```

# Results

## Parameters for aestethics

```{r , echo = include_code, message=FALSE, warning=FALSE, results='hide'}
shape_factor = factor(results_PhoCAssPaNS_df$sample)
# Color factor
color_factor = factor(results_PhoCAssPaNS_df$lightClass, levels = c("25%","50%","100%"))
results_PhoCAssPaNS_df$lightClass <- color_factor

color_factor = factor(reactorPhoCAssPaNS_df$lightClass, levels = c("25%","50%","100%"))
reactorPhoCAssPaNS_df$lightClass <- color_factor

```

## Light supply analysis

```{r, echo = include_code, fig.width=6, fig.height=4.2}

plot_lightdensity_a <-
  ggplot(data = results_PhoCAssPaNS_df,
                         aes(x = day , y = averageLightDensityDryweight, color = lightClass, shape = concentrationClass)) +
  geom_point(size = 3,stroke = 1.25, position = position_dodge(width = 0.25)) +
  geom_errorbar(aes(ymin = averageLightDensityDryweight*(1 - averageLightDensityDryweight_rel_error), ymax = averageLightDensityDryweight*(1 + averageLightDensityDryweight_rel_error)), width = 2, position = position_dodge(width = 0.25)) +
  scale_shape_manual(values = c(21,23,24)) +
  scale_y_log10() +
  labs(title = "a)",
       x = "Day",
       y = expression(bold(atop("Average light density", paste("(µmol.s"^"-1",".g dryweight"^"-1",")"))))) +
  theme_paul + 
  guides(size = "none") +
  scale_color_manual(values = c(my_color_fill[1],my_color_fill[2],my_color_fill[3])) +
  scale_fill_manual(values = c(my_color_fill[1],my_color_fill[2],my_color_fill[3]))


plot_lightdensity_b <- ggplot(data = results_PhoCAssPaNS_df,
                         aes(x = day , y = averageLightDensityCell, color = lightClass, shape = concentrationClass)) +
  geom_point(size = 3,stroke = 1.25, position = position_dodge(width = 0.25)) +
  geom_errorbar(aes(ymin = averageLightDensityCell*(1 - averageLightDensityCell_rel_error), ymax = averageLightDensityCell*(1 + averageLightDensityCell_rel_error)), width = 2, position = position_dodge(width = 0.25)) +
  scale_shape_manual(values = c(21,23,24)) +
  scale_y_log10() +
  labs(title = "b)",
       x = "Day",
       y = expression(bold(atop("Average light density", paste("(µmol.s"^"-1",".cell"^"-1",")"))))) +
  # ylim(c(0,0.5)) +
  theme_paul + 
  guides(size = "none") +
  scale_color_manual(values = c(my_color_fill[1],my_color_fill[2],my_color_fill[3])) +
  scale_fill_manual(values = c(my_color_fill[1],my_color_fill[2],my_color_fill[3]))


plot_lightdensity_a
plot_lightdensity_b

```

## Biomass growth

### Dry weight:

```{r echo = include_code, message=FALSE, warning=FALSE, fig.height=4.5,fig.width=6, results='hide'}

plot_biomass_a <-
  ggplot(data = results_PhoCAssPaNS_df,
                         aes(x = day , y = dryWeight, color = lightClass, shape = concentrationClass)) +
  geom_point(size = 3,stroke = 1.25, position = position_dodge(width = 0.25)) +
  geom_line(size = 0.5, linetype = 2) +
  geom_errorbar(aes(ymin = dryWeight*(1 - dryweight_rel_error), ymax = dryWeight*(1 + dryweight_rel_error)), width = 2, position = position_dodge(width = 0.25)) +
scale_shape_manual(values = c(21,23,24)) +
  labs(title = "a)",
       x = "Day",
       y = expression(bold(atop("Dry weight", paste("(g.L"^"-1",")"))))) +
  theme_paul +
  theme(legend.position = "none") +
  scale_color_manual(values = c(my_color_fill[1],my_color_fill[2],my_color_fill[3])) +
  scale_fill_manual(values = c(my_color_fill[1],my_color_fill[2],my_color_fill[3]))

```

```{r, ,fig.height=4.5,fig.width=5, echo = include_code, warning=FALSE}
plot_biomass_a
```

### Cell count

```{r, echo = include_code, message=FALSE, warning=FALSE, results='hide'}

plot_biomass_b <- ggplot(data = results_PhoCAssPaNS_df,
                         aes(x = day , y = cellCount*1000, color = lightClass, shape = concentrationClass)) +
  scale_shape_manual(values = 1:3,na.translate = FALSE) +
  geom_point(size = 3,stroke = 1.25, position = position_dodge(width = 0.25)) +
  geom_line(size = 0.5, linetype = 2) +
  geom_errorbar(aes(ymin = cellCount*1000*(1 - cellCount_rel_error), ymax = cellCount*1000*(1 + cellCount_rel_error)), width = 2, position = position_dodge(width = 0.25)) +
  labs(title = "b)",
       x = "Day",
       y = expression(bold(atop("Total cell count", paste("(cell.L"^"-1",")"))))) +
  scale_shape_manual(values = c(21,23,24)) +
  scale_y_log10() +
  theme_paul +
  scale_color_manual(values = c(my_color_fill[1],my_color_fill[2],my_color_fill[3]))


```

```{r, echo = include_code,fig.height=4.5,fig.width=6.5, warning=FALSE}
plot_biomass_b

```

### Biomass pigment

```{r, echo = include_code, results="hide"}

# Absolute concentrations----
plot_chla_total <- ggplot(data = results_PhoCAssPaNS_df,
                          aes(x = day , y = totalChlaSpecificWeight/10*dryWeight/100,
                              color = lightClass, shape = concentrationClass)) +
  scale_shape_manual(values = 1:3,na.translate = FALSE) +
  geom_point(size = 3,stroke = 1.25, position = position_dodge(width = 0.25)) +
  geom_line(size = 0.5, linetype = 2) +
  geom_errorbar(aes(ymin = totalChlaSpecificWeight/10*dryWeight/100*(1 - pigment_concentration_rel_error), ymax = totalChlaSpecificWeight/10*dryWeight/100*(1 + pigment_concentration_rel_error)), width = 2, position = position_dodge(width = 0.25)) +
  labs(x = "Day",
       y = expression(bold(atop("Chl-a concentration in the reactor",paste("(g.L"^"-1",")"))))) +
  scale_shape_manual(values = c(21,23,24)) +
  theme_paul +
  theme(legend.position = "none") +
  scale_color_manual(values = c(my_color_fill[1],my_color_fill[2],my_color_fill[3]))


plot_chlb_total <- ggplot(data = results_PhoCAssPaNS_df,
                          aes(x = day , y = totalChlbSpecificWeight/10*dryWeight/100,
                              color = lightClass, shape = concentrationClass)) +
  scale_shape_manual(values = 1:3,na.translate = FALSE) +
  geom_point(size = 3,stroke = 1.25, position = position_dodge(width = 0.25)) +
  geom_line(size = 0.5, linetype = 2) +
  geom_errorbar(aes(ymin = totalChlbSpecificWeight/10*dryWeight/100*(1 - pigment_concentration_rel_error), ymax = totalChlbSpecificWeight/10*dryWeight/100*(1 + pigment_concentration_rel_error)), width = 2, position = position_dodge(width = 0.25)) +
  scale_shape_manual(values = c(21,23,24)) +
  labs(title = "c)",
       x = "Day",
       y = expression(bold(atop("Chl-b concentration in the reactor",paste("(g.L"^"-1",")"))))) +
  theme_paul +
  theme(legend.position = "none") +
  scale_color_manual(values = c(my_color_fill[1],my_color_fill[2],my_color_fill[3]))

plot_carot_total <- ggplot(data = results_PhoCAssPaNS_df,
                          aes(x = day , y = totalCarotSpecificWeight/10*dryWeight/100,
                              color = lightClass, shape = concentrationClass)) +
  scale_shape_manual(values = 1:3,na.translate = FALSE) +
  geom_point(size = 3,stroke = 1.25, position = position_dodge(width = 0.25)) +
  geom_line(size = 0.5, linetype = 2) +
  geom_errorbar(aes(ymin = totalCarotSpecificWeight/10*dryWeight/100*(1 - pigment_concentration_rel_error), ymax = totalCarotSpecificWeight/10*dryWeight/100*(1 + pigment_concentration_rel_error)), width = 2, position = position_dodge(width = 0.25)) +
  scale_shape_manual(values = c(21,23,24)) +
  labs(x = "Day",
       y = expression(bold(atop("Carotenoids concentration in the reactor",paste("(g.L"^"-1",")"))))) +
  theme_paul +
  scale_color_manual(values = c(my_color_fill[1],my_color_fill[2],my_color_fill[3]))


plot_chla_total_log <- plot_chla_total + scale_y_log10()
plot_chlb_total_log <- plot_chlb_total+ scale_y_log10()
plot_carot_total_log <- plot_carot_total+ scale_y_log10()

plot_pigment_total <- plot_chla_total_log + plot_chlb_total_log + plot_carot_total_log

```

```{r,  echo = include_code , fig.height=5 , fig.width=17 , warning=FALSE}
plot_pigment_total
```

### Final plot
```{r, echo = include_code, fig.width = 16, fig.height = 9}
# validationPlot_dryweight +
#   theme(legend.position = "none") +
#   validationPlot_cellCount + theme(legend.position = "none") +
#    validationPlot_totalCHO + theme(legend.position = "none") +
#    validationPlot_totalLipids + 
#   theme(legend.position = c(-0.25,1.15),
#         legend.box = "horizontal",
#         legend.background = element_rect(size=0.5, linetype="solid",
#                                          colour ="black"))
  
## Putting the legend in common (based on https://stackoverflow.com/questions/13649473/add-a-common-legend-for-combined-ggplots )

plot_pigment_total <- plot_pigment_total +
  theme(legend.box = "vertical")

g_legend <- function(a.gplot){
  tmp <- ggplot_gtable(ggplot_build(a.gplot))
  leg <- which(sapply(tmp$grobs, function(x) x$name) == "guide-box")
  legend <- tmp$grobs[[leg]]
  return(legend)
}

mylegend <- g_legend(plot_pigment_total)


layoutMatrix <- rbind(c(NA,1,1,1,NA,2,2,2,NA,6),
                      c(NA,1,1,1,NA,2,2,2,NA,6),
                      c(NA,1,1,1,NA,2,2,2,NA,6),
                      c(3,3,3,4,4,4,5,5,5,6),
                      c(3,3,3,4,4,4,5,5,5,6),
                      c(3,3,3,4,4,4,5,5,5,6))

finalBiomassPlot <-
      grid.arrange(plot_biomass_a + theme(legend.position="none"),
                           plot_biomass_b + theme(legend.position="none"),
                           plot_chla_total_log  + theme(legend.position="none"),
                           plot_chlb_total_log  + theme(legend.position="none"),
                           plot_carot_total_log + theme(legend.position="none"),
               layout_matrix = layoutMatrix,
               mylegend)


```

## Photosynthetic activity

### Pm and lambda plots

```{r, echo = include_code,warning=FALSE}

plot_Pm_tern <- ggtern(data = subset(results_PhoCAssPaNS_df,PmMass < 1),
                       aes(y=totalFAME,x=totalSugars,z=tnSpecific*factor_protein)) + 
  geom_errorbarL(aes(Lmin = totalSugars*(1 - totalSugars_rel_error), Lmax = totalSugars*(1 + totalSugars_rel_error)), width = 2, color = "black") +
  geom_errorbarR(aes(Rmin = totalProtein*(1 - totalProtein_rel_error), Rmax = totalProtein*(1 + totalProtein_rel_error)), width = 2, color = "black") +
  geom_errorbarT(aes(Tmin = totalFAME*(1 - totalFame_rel_error), Tmax = totalFAME*(1 + totalFame_rel_error)), width = 2, color = "black") +
  geom_point(aes(fill=PmMass,stroke = 1),color="black",shape=21,size=4,show.legend = TRUE) + 
  theme_paul + 
  theme(legend.position=c(0,1),
        legend.justification=c(0,1)) + 
  scale_colour_viridis_c(option = "D",trans = "log",breaks=c(1*10^(-6),1*10^(-5),1*10^(-4),1*10^(-3))) +
  scale_fill_viridis_c(option = "D",trans = "log",breaks=c(1*10^(-6),1*10^(-5),1*10^(-4),1*10^(-3))) +
  theme(legend.background = element_rect(fill = FALSE)) +
  theme_showarrows() + 
  labs( title = expression(bold(atop("Maximum specific rate of photosynthesis", paste("(g O"[2],".g"^"-1",".s"^"-1",")")))),
        x = "",
        xarrow = "Carbohydrates mass quota (% DW)",
        y = "",
        yarrow = "Lipids mass quota (% DW)",
        z = "",
        zarrow = "Proteins mass quota (% DW)" )


limit_low <- 1*10^(-7)

plot_photoRepsiration_tern <- ggtern(data = results_PhoCAssPaNS_df,
                                     aes(y=totalFAME,x=totalSugars,z=tnSpecific*factor_protein)) + 
  geom_errorbarL(aes(Lmin = totalSugars*(1 - totalSugars_rel_error), Lmax = totalSugars*(1 + totalSugars_rel_error)), width = 2, color = "black") +
  geom_errorbarR(aes(Rmin = totalProtein*(1 - totalProtein_rel_error), Rmax = totalProtein*(1 + totalProtein_rel_error)), width = 2, color = "black") +
  geom_errorbarT(aes(Tmin = totalFAME*(1 - totalFame_rel_error), Tmax = totalFAME*(1 + totalFame_rel_error)), width = 2, color = "black") +
  geom_point(aes(fill=lambdaPhotoresp,stroke = 1),color="black",shape=21,size=4,show.legend = TRUE) +
  theme_paul + 
  theme(legend.position=c(0,1),
        legend.justification=c(0,1)) + 
  scale_colour_viridis_c(option = "D",trans = "log",
                         limits = c(limit_low,1*10^(-5)),
                         breaks=c(1*10^(-7),3*10^(-7),1*10^(-6),3*10^(-6),1*10^(-5),1*10^(-4),1*10^(-3))) +
  scale_fill_viridis_c(option = "D",trans = "log",
                       limits = c(limit_low,1*10^(-5)),
                       breaks=c(1*10^(-7),3*10^(-7),1*10^(-6),3*10^(-6),1*10^(-5),1*10^(-4),1*10^(-3))) +
  theme(legend.background = element_rect(fill = FALSE)) +
  theme_showarrows() +
  # theme(tern.axis.arrow.sep	= 0.1) +
  labs( title = expression(bold(atop("Specific rate of oxygen consumption in the dark",
                                     paste("following light exposition (g O"[2],".g"^"-1",".s"^"-1",")")))),
        x = "",
        xarrow = "Carbohydrates mass quota (% DW)",
        y = "",
        yarrow = "Lipids mass quota (% DW)",
        z = "",
        zarrow = "Proteins mass quota (% DW)" )


results_PhoCAssPaNS_df$lambdaDark[which(results_PhoCAssPaNS_df$lambdaDark < 0)] <- NA

plot_darkRespiration_tern <-  ggtern(data = results_PhoCAssPaNS_df,
                                     aes(y=totalFAME,x=totalSugars,z=tnSpecific*factor_protein)) + 
  geom_errorbarL(aes(Lmin = totalSugars*(1 - totalSugars_rel_error), Lmax = totalSugars*(1 + totalSugars_rel_error)), width = 2, color = "black") +
  geom_errorbarR(aes(Rmin = totalProtein*(1 - totalProtein_rel_error), Rmax = totalProtein*(1 + totalProtein_rel_error)), width = 2, color = "black") +
  geom_errorbarT(aes(Tmin = totalFAME*(1 - totalFame_rel_error), Tmax = totalFAME*(1 + totalFame_rel_error)), width = 2, color = "black") +
  geom_point(aes(fill=lambdaDark,stroke = 1),color="black",shape=21,size=4,show.legend = TRUE) +  
  theme_paul + 
  theme(legend.position=c(0,1),
        legend.justification=c(0,1)) + 
  scale_colour_viridis_c(option = "D",trans = "log",
                         limits = c(limit_low,1*10^(-5)),
                         breaks=c(1*10^(-7),3*10^(-7),1*10^(-6),3*10^(-6),1*10^(-5),1*10^(-4),3*10^(-4),1*10^(-3))) +
  scale_fill_viridis_c(option = "D",trans = "log",
                       limits = c(limit_low,1*10^(-5)),
                       breaks=c(1*10^(-7),3*10^(-7),1*10^(-6),3*10^(-6),1*10^(-5),1*10^(-4),3*10^(-4),1*10^(-3))) +
  theme(legend.background = element_rect(fill = FALSE)) +
  theme_showarrows() + 
  labs( title = expression(bold(atop("Specific rate of oxygen consumption in the dark", paste("(g O"[2],".g"^"-1",".s"^"-1",")")))),
        x = "",
        xarrow = "Carbohydrates mass quota (% DW)",
        y = "",
        yarrow = "Lipids mass quota (% DW)",
        z = "",
        zarrow = "Proteins mass quota (% DW)" )

```

```{r , echo = include_code,fig.width=6,fig.height=6,warning=FALSE}
plot_Pm_tern
plot_photoRepsiration_tern
plot_darkRespiration_tern

max(results_PhoCAssPaNS_df$PmMass,na.rm = TRUE)/min(results_PhoCAssPaNS_df$PmMass,na.rm = TRUE)
```

## Biomass content

### Functional pool quota determination

The quota for functional pool is determined here from the complement in mass percentage of the cell from lipids, carbohydrates, and proteins.

```{r, echo=TRUE,warning=FALSE}
# Data minor transfo
functional_pool = (1 - (results_PhoCAssPaNS_df$totalFAME + results_PhoCAssPaNS_df$totalSugars + results_PhoCAssPaNS_df$totalProtein))
functional_pool[functional_pool < 0 ] <- 0

sample = c(results_PhoCAssPaNS_df$sample,results_PhoCAssPaNS_df$sample,results_PhoCAssPaNS_df$sample,results_PhoCAssPaNS_df$sample)
category = c(rep("Lipids",length(results_PhoCAssPaNS_df$totalFAME)),rep("Carbohydrates",length(results_PhoCAssPaNS_df$totalSugars)),rep("Proteins",length(results_PhoCAssPaNS_df$totalProtein)),rep("Functional compartment",length(functional_pool)))
data_quota = data.frame(Sample = sample, 
                        Quotas = c(results_PhoCAssPaNS_df$totalFAME,results_PhoCAssPaNS_df$totalSugars, results_PhoCAssPaNS_df$totalProtein,functional_pool), 
                        Day = c(results_PhoCAssPaNS_df$day,results_PhoCAssPaNS_df$day,results_PhoCAssPaNS_df$day,results_PhoCAssPaNS_df$day),
                        quotaCategory = category)
day_lim = 16

data_quota$quotaCategory2 <- factor(data_quota$quotaCategory,levels = c("Functional compartment","Carbohydrates","Lipids","Proteins"))

results_PhoCAssPaNS_df$functionalPool <- functional_pool

```

### Analysis of protein decline in the reactors

#### Protein biomass quota decrease

We here Verify the hypothesis that the rate of protein quota decrease is linked to global light irradiance in the reactor

```{r, echo = include_code,fig.height=5,fig.width=7}


# We first determine a rate of decrease for protein content in each reactor

## Eye analysis lead to an expression of the protein quota as an exponential decrease with time ~ qP(t) = (qP0 - qPmin)*exp(-aplha*t) + qPmin
  ## This is is solved by linear regression of ln((q(t) - qMin)/(q0 - qMin)) ~ -alpha*t

# We set a minimum protein quota as 0.99 of the min measured over all reactors, avoiding to compute a log(0) in the transformation for linear regression
q_prot_min <- 0.99*min(results_PhoCAssPaNS_df$totalProtein,na.rm = TRUE) 

concentrationClassList = c("0.1 g.L-1","0.3 g.L-1","1.0 g.L-1")
lightClassList = c("25%","50%","100%")

# Initialisaiton of vectors for the values to retrieve
## prot_degradation_rate: rate of protein degradation (d-1)
prot_degradation_rate <- rep(NA,9)
## prot_degradation_rate_std: standard deviation for the rate of protein degradation determined (d-1)
prot_degradation_rate_std <- rep(NA,9)
## R2_prot_degradation_rate: Correlation coefficient associated to the linear regression
R2_prot_degradation_rate <- rep(NA,9)
## pValue_prot_degradation_rate: p-value associated to the linear regression
pValue_prot_degradation_rate <- rep(NA,9)

# Loop of calculation
for (i_concentration in (1:3)){
  for (j_light in (1:3)){

    # Extraction of a single reactor value, stored in a locally defined data frame
    data_reduced <- subset(results_PhoCAssPaNS_df, concentrationClass == concentrationClassList[i_concentration])
    data_reduced <- subset(data_reduced, data_reduced$lightClass == lightClassList[j_light])
    
    # We define the starting protein quota
    q_prot_0 <- data_reduced$totalProtein[1]
    # We compute the y values of the linear regression, implemented in the local data frame
    data_reduced$proteinFit <- log((data_reduced$totalProtein - q_prot_min)/(q_prot_0 - q_prot_min))
    
    # Linear regression
    local_lm <- lm(data = data_reduced, proteinFit ~ day + 0)
    
    # Extraction of results
    prot_degradation_rate[3*(i_concentration - 1) + j_light] <- summary(local_lm)$coefficients[1]
    prot_degradation_rate_std[3*(i_concentration - 1) + j_light] <- summary(local_lm)$coefficients[2]
    R2_prot_degradation_rate[3*(i_concentration - 1) + j_light] <- summary(local_lm)$r.squared
    pValue_prot_degradation_rate[3*(i_concentration - 1) + j_light] <- summary(local_lm)$coefficients[4]
    
    # Plot of the local results in order to verify the quality of the results
    plot(data_reduced$day,data_reduced$proteinFit)
    abline(local_lm,col = "red",lwd = 2)
    
  }
}
# Results are now registered in the per-reactor results data frame
## Protein degradation rate (d-1)
reactorPhoCAssPaNS_df$protDegradationRate <- -prot_degradation_rate
## Relative error on protein degradation rate (%, IC-95%)
reactorPhoCAssPaNS_df$protDegradationRate_rel_error <- abs(1.96*prot_degradation_rate_std/prot_degradation_rate)

# Ploting of the results
ggplot(data = reactorPhoCAssPaNS_df,aes(x = lightDensity,y = protDegradationRate, colour = lightClass,shape = concentrationClass)) +
  geom_point(size = 3,stroke = 1.25) +
  geom_errorbarh(aes(xmin = (lightDensity -1.96*lightDensityStd), xmax = (lightDensity + 1.96*lightDensityStd)),
                stroke = 1.25, width = 4) +
  geom_errorbar(aes(ymin = protDegradationRate*(1 - protDegradationRate_rel_error), 
                    ymax = protDegradationRate*(1 + protDegradationRate_rel_error)),
                stroke = 1.25, width = 1) +
  scale_shape_manual(values = c(1,2,4),na.translate = FALSE) +
  # ylim(c(-0.1,0.9)) +
  labs(x = expression(bold(atop("Dryweight specific light density ",
                                 paste("(µmol.(g DW.s)"^"-1","])")))),
       y = expression(bold(atop("Protein mass quota",
                                paste("degradation rate (d"^"-1",")"))))) +
  theme_paul +
  scale_color_manual(values = c(my_color_fill[1],my_color_fill[2],my_color_fill[3])) + 
  scale_y_continuous(breaks = c(0,0.2,0.4,0.6,0.8))

ggplot(data = reactorPhoCAssPaNS_df,aes(x = lightDensityCell,y = protDegradationRate, colour = lightClass,shape = concentrationClass)) +
  geom_point(size = 3,stroke = 1.25) +
  geom_errorbarh(aes(xmin = (lightDensityCell -1.96*lightDensityCell_std), xmax = (lightDensityCell + 1.96*lightDensityCell_std)),
                stroke = 1.25, width = 0.05) +
  geom_errorbar(aes(ymin = protDegradationRate*(1 - protDegradationRate_rel_error), 
                    ymax = protDegradationRate*(1 + protDegradationRate_rel_error)),
                stroke = 1.25, width = 0.2) +
  scale_shape_manual(values = c(1,2,4),na.translate = FALSE) +
  ylim(c(0,0.8)) +
  scale_x_log10() +
  labs(x = expression(bold(atop("Cell specific light density ",
                                 paste("(µmol.(cell.s)"^"-1","])")))),
       y = expression(bold(atop("Protein content degradation rate",
                                paste("(g.g.d"^"-1",")"))))) +
  theme_paul +
  scale_color_manual(values = c(my_color_fill[1],my_color_fill[2],my_color_fill[3])) + 
  scale_y_continuous(breaks = c(0,0.2,0.4,0.8))

# Verification of the hypothesis that the specific protein degradation rate is significantly and positively influenced by the light density in the reactor
lm(data = reactorPhoCAssPaNS_df, protDegradationRate ~ lightDensity)
summary(lm(data = reactorPhoCAssPaNS_df, protDegradationRate ~ lightDensity))

# Printing the results of the analysis
## All results from teh analysis are aggregated in a matrix
protein_quota_deg_rate_matrix <- 
  matrix(c(-prot_degradation_rate,
           prot_degradation_rate_std,
           R2_prot_degradation_rate,
           pValue_prot_degradation_rate),
         nrow = 9)
```

#### Analysis of protein final quota

```{r, echo = include_code}
# Calculation of the final protein quota (mass and cell specific)
# Initialisation of the vectors
final_prot_quota <- rep(NA,9)
final_prot_cell_quota <- rep(NA,9)

for (i_concentration in (1:3)){
  for (j_light in (1:3)){

    data_reduced <- subset(results_PhoCAssPaNS_df, concentrationClass == concentrationClassList[i_concentration])
    data_reduced <- subset(data_reduced, data_reduced$lightClass == lightClassList[j_light])
    
    final_prot_quota[3*(i_concentration - 1) + j_light] <-
      tail(data_reduced$totalProtein[is.na(data_reduced$totalProtein) == 0], n = 1)
    final_prot_cell_quota[3*(i_concentration - 1) + j_light] <-
      tail(data_reduced$totalProteinCell[is.na(data_reduced$totalProteinCell) == 0], n = 1)
  }
}

# Printing of the results
mean(final_prot_quota)
sd(final_prot_quota)
mean(final_prot_cell_quota)
sd(final_prot_cell_quota)

```

#### Evolution of Protein global content in the reactors

The protein content evolution is now analysed in term of global concentration in the reactor.

```{r, echo = include_code,fig.height=5,fig.width=7}


# Initialisation

global_prot_degradation_rate <- rep(NA,9)
global_prot_degradation_rate_std <- rep(NA,9)
R2_global_prot_degradation_rate <- rep(NA,9)
pValue_global_prot_degradation_rate <- rep(NA,9)

# Loop of the calculation
for (i_concentration in (1:3)){
  for (j_light in (1:3)){

    # Definition of a local data frame gathering results from a single reactor
    data_reduced <- subset(results_PhoCAssPaNS_df, concentrationClass == concentrationClassList[i_concentration])
    data_reduced <- subset(data_reduced, data_reduced$lightClass == lightClassList[j_light])
    # We append the global protein concentration (g/L)
    data_reduced$globalProtein <- data_reduced$dryWeight*data_reduced$totalProtein
    
    # Linear regression of global protein concentration vs time
    local_lm <- lm(data = data_reduced, globalProtein ~ day )
    
    # Extraction of a degradation rate as the slope of the linear degradation and associated fitting statistics
    global_prot_degradation_rate[3*(i_concentration - 1) + j_light] <- summary(local_lm)$coefficients[2,1]
    global_prot_degradation_rate_std[3*(i_concentration - 1) + j_light] <- summary(local_lm)$coefficients[2,2]
    R2_global_prot_degradation_rate[3*(i_concentration - 1) + j_light] <- summary(local_lm)$r.squared
    pValue_global_prot_degradation_rate[3*(i_concentration - 1) + j_light] <- summary(local_lm)$coefficients[2,4]
    
    # Local plot for eye check of the fits
    plot(data_reduced$day,data_reduced$globalProtein)
    abline(local_lm,col = "red",lwd = 2)
    
  }
}

# The results are registered in the per reactor data frame
reactorPhoCAssPaNS_df$globalProtDegradationRate <- -global_prot_degradation_rate
reactorPhoCAssPaNS_df$globalProtDegradationRate_rel_error <- abs(1.96*global_prot_degradation_rate_std/global_prot_degradation_rate)

# Plotting the results
ggplot(data = reactorPhoCAssPaNS_df,aes(x = lightDensity,y = globalProtDegradationRate,
                                     colour = lightClass,shape = concentrationClass)) +
  geom_point(size = 3,stroke = 1.25) +
  geom_errorbarh(aes(xmin = (lightDensity -1.96*lightDensityStd), xmax = (lightDensity + 1.96*lightDensityStd)),
                stroke = 1.25, height = 0.00125) +
  geom_errorbar(aes(ymin = globalProtDegradationRate*(1 - globalProtDegradationRate_rel_error), 
                    ymax = globalProtDegradationRate*(1 + globalProtDegradationRate_rel_error)),
                stroke = 1.25, width = 1) +
  scale_shape_manual(values = c(1,2,4),na.translate = FALSE) +
  # ylim(c(-0.1,0.9)) +
  labs(x = expression(bold(atop("Dryweight specific light density ",
                                 paste("(µmol.(g DW.s)"^"-1","])")))),
       y = expression(bold(atop("Protein global concentration",
                                paste("degradation rate (g Proteins.(L.d)"^"-1",")"))))) +
  theme_paul +
  scale_color_manual(values = c(my_color_fill[3],my_color_fill[1],my_color_fill[2])) # + 
  # scale_y_continuous(breaks = c(0,0.2,0.4,0.6,0.8))

ggplot(data = reactorPhoCAssPaNS_df,aes(x = lightDensityCell,y = globalProtDegradationRate, colour = lightClass,shape = concentrationClass)) +
  geom_point(size = 3,stroke = 1.25) +
  geom_errorbarh(aes(xmin = (lightDensityCell -1.96*lightDensityCell_std), xmax = (lightDensityCell + 1.96*lightDensityCell_std)),
                stroke = 1.25, height = 0.00125) +
  geom_errorbar(aes(ymin = globalProtDegradationRate*(1 - globalProtDegradationRate_rel_error), 
                    ymax = globalProtDegradationRate*(1 + globalProtDegradationRate_rel_error)),
                stroke = 1.25, width = 0.2) +
  scale_shape_manual(values = c(1,2,4),na.translate = FALSE) +
  ylim(c(0,0.8)) +
  scale_x_log10() +
  labs(x = expression(bold(atop("Cell specific light density ",
                                 paste("(µmol.(cell.s)"^"-1","])")))),
       y = expression(bold(atop("Protein global concentration",
                                paste("degradation rate (g Proteins.(L.d)"^"-1",")"))))) +
  theme_paul +
  scale_color_manual(values = c(my_color_fill[1],my_color_fill[2],my_color_fill[3])) + 
  scale_y_continuous(breaks = c(0,0.2,0.4,0.8))

# Linear regression of the global protein degradation rates obtained vs light density in the reactors
lm(data = reactorPhoCAssPaNS_df, globalProtDegradationRate ~ lightDensity)
summary(lm(data = reactorPhoCAssPaNS_df, globalProtDegradationRate ~ lightDensity))

# Printing of the results
## All results from teh analysis are aggregated in a matrix
protein_global_deg_rate_matrix <-
  matrix(
    c(-global_prot_degradation_rate,
      global_prot_degradation_rate_std,
      R2_global_prot_degradation_rate,
      pValue_global_prot_degradation_rate),
    nrow = 9)

```

#### Carbohydrate quota quantitative analysis

```{r, echo = include_code}

# Max CHO quota and Standard error associated
max(results_PhoCAssPaNS_df$totalSugars,na.rm = TRUE)
results_PhoCAssPaNS_df$totalSugars_rel_error[which(results_PhoCAssPaNS_df$totalSugars == max(results_PhoCAssPaNS_df$totalSugars,na.rm = TRUE))]*max(results_PhoCAssPaNS_df$totalSugars,na.rm = TRUE)/1.96

# Max CHO cell quota and Standard error associated
max(results_PhoCAssPaNS_df$totalSugarsCell,na.rm = TRUE)
results_PhoCAssPaNS_df$totalSugarsCell_rel_error[which(results_PhoCAssPaNS_df$totalSugarsCell == max(results_PhoCAssPaNS_df$totalSugarsCell,na.rm = TRUE))]*max(results_PhoCAssPaNS_df$totalSugarsCell,na.rm = TRUE)/1.96

```

#### Biomass macromolecules content analysis

The plots of biomass content in proteins, lipids, and carbohydrates, in terms of global concentration in the reactor, mass quota, and cell quota are all produced below. They are then merged in a single ggplot object.

```{r,  echo = include_code}

plot_total_content_FAME <- ggplot(data = results_PhoCAssPaNS_df,
                                  aes(x = day , y = totalFAME*dryWeight,
                                      color = lightClass, shape = concentrationClass)) +
  geom_point(size = 3,stroke = 1.25, position = position_dodge(width = 0.25)) +
  geom_line(size = 0.5, linetype = 2) +
  geom_errorbar(aes(ymin = totalFAME*dryWeight*(1 - sqrt(totalFame_rel_error^2 + dryweight_rel_error^2)),
                    ymax = totalFAME*dryWeight*(1 + sqrt(totalFame_rel_error^2 + dryweight_rel_error^2))),
                    width = 2, position = position_dodge(width = 0.25)) +
scale_shape_manual(values = c(21,23,24)) +
  labs(title = "c)",
       x = "Day",
       y = expression(bold(atop("Lipid global content", paste("(g.L"^"-1",")"))))) +
  theme_paul +
  scale_y_log10() +
  scale_color_manual(values = c(my_color_fill[1],my_color_fill[2],my_color_fill[3])) 




plot_total_content_sugars <- ggplot(data = results_PhoCAssPaNS_df,
                                  aes(x = day , y = totalSugars*dryWeight,
                                      color = lightClass, shape = concentrationClass)) +
  geom_point(size = 3,stroke = 1.25, position = position_dodge(width = 0.25)) +
  geom_line(size = 0.5, linetype = 2) +
  geom_errorbar(aes(ymin = totalSugars*dryWeight*(1 - sqrt(totalSugars_rel_error^2 + dryweight_rel_error^2)),
                    ymax = totalSugars*dryWeight*(1 + sqrt(totalSugars_rel_error^2 + dryweight_rel_error^2))),
                    width = 2, position = position_dodge(width = 0.25)) +
scale_shape_manual(values = c(21,23,24)) +
  labs(title = "b)",
       x = "Day",
       y = expression(bold(atop("Carbohydrates global content", paste("(g.L"^"-1",")"))))) +
  theme_paul +
  scale_y_log10() +
  theme(legend.position = "none") +
  scale_color_manual(values = c(my_color_fill[1],my_color_fill[2],my_color_fill[3])) 




plot_total_content_proteins <- ggplot(data = results_PhoCAssPaNS_df,
                                  aes(x = day , y = totalProtein*dryWeight,
                                      color = lightClass, shape = concentrationClass)) +
  geom_point(size = 3,stroke = 1.25, position = position_dodge(width = 0.25)) +
  geom_line(size = 0.5, linetype = 2) +
  geom_errorbar(aes(ymin = totalProtein*dryWeight*(1 - sqrt(totalProtein_rel_error^2 + dryweight_rel_error^2)),
                    ymax = totalProtein*dryWeight*(1 + sqrt(totalProtein_rel_error^2 + dryweight_rel_error^2))),
                    width = 2, position = position_dodge(width = 0.25)) +
scale_shape_manual(values = c(21,23,24)) +
  labs(title = "a)",
       x = "Day",
       y = expression(bold(atop("Protein global content", paste("(g.L"^"-1",")"))))) +
  theme_paul +
  scale_y_log10() +
  theme(legend.position = "none") +
  scale_color_manual(values = c(my_color_fill[1],my_color_fill[2],my_color_fill[3])) 



plot_mass_content_FAME <- ggplot(data = results_PhoCAssPaNS_df,
                                  aes(x = day , y = totalFAME,
                                      color = lightClass, shape = concentrationClass)) +
  geom_point(size = 3,stroke = 1.25, position = position_dodge(width = 0.25)) +
  geom_line(size = 0.5, linetype = 2) +
  geom_errorbar(aes(ymin = totalFAME*(1 - totalFame_rel_error^2 ),
                    ymax = totalFAME*(1 + totalFame_rel_error^2)),
                    width = 2, position = position_dodge(width = 0.25)) +
scale_shape_manual(values = c(21,23,24)) +
  labs(title = "f)",
       x = "Day",
       y = expression(bold(atop("Lipid mass quota", paste("(g.(g dry-weight)"^"-1",")"))))) +
  theme_paul +
  scale_color_manual(values = c(my_color_fill[1],my_color_fill[2],my_color_fill[3])) 




plot_mass_content_sugars <- ggplot(data = results_PhoCAssPaNS_df,
                                  aes(x = day , y = totalSugars,
                                      color = lightClass, shape = concentrationClass)) +
  geom_point(size = 3,stroke = 1.25, position = position_dodge(width = 0.25)) +
  geom_line(size = 0.5, linetype = 2) +
  geom_errorbar(aes(ymin = totalSugars*(1 - totalSugars_rel_error^2),
                    ymax = totalSugars*(1 + totalSugars_rel_error^2)),
                    width = 2, position = position_dodge(width = 0.25)) +
scale_shape_manual(values = c(21,23,24)) +
  labs(title = "e)",
       x = "Day",
       y = expression(bold(atop("Carbohydrates mass quotat", paste("(g.(g dry-weight)"^"-1",")"))))) +
  theme_paul +
  theme(legend.position = "none") +
  scale_color_manual(values = c(my_color_fill[1],my_color_fill[2],my_color_fill[3])) 




plot_mass_content_proteins <- ggplot(data = results_PhoCAssPaNS_df,
                                  aes(x = day , y = totalProtein,
                                      color = lightClass, shape = concentrationClass)) +
  geom_point(size = 3,stroke = 1.25, position = position_dodge(width = 0.25)) +
  geom_line(size = 0.5, linetype = 2) +
  geom_errorbar(aes(ymin = totalProtein*(1 - totalProtein_rel_error^2),
                    ymax = totalProtein*(1 + totalProtein_rel_error^2 )),
                    width = 2, position = position_dodge(width = 0.25)) +
scale_shape_manual(values = c(21,23,24)) +
  labs(title = "d)",
       x = "Day",
       y = expression(bold(atop("Protein mass quota", paste("(g.(g dry-weight)"^"-1",")"))))) +
  theme_paul +
  theme(legend.position = "none") +
  scale_color_manual(values = c(my_color_fill[1],my_color_fill[2],my_color_fill[3])) 


# totalProteinCell ,
plot_cell_content_proteins <-
  ggplot(data = results_PhoCAssPaNS_df,
         aes(x = day , y = totalProteinCell,
             color = lightClass, shape = concentrationClass)) +
  geom_point(size = 3,stroke = 1.25, position = position_dodge(width = 0.25)) +
  geom_line(size = 0.5, linetype = 2) +
  geom_errorbar(aes(ymin = totalProteinCell*(1 - totalProteinCell_rel_error),
                    ymax = totalProteinCell*(1 + totalProteinCell_rel_error)),
                    width = 2, position = position_dodge(width = 0.25)) +
scale_shape_manual(values = c(21,23,24)) +
  labs(title = "g)",
       x = "Day",
       y = expression(bold(atop("Proteins cell quota", paste("(g.cell"^"-1",")"))))) +
  theme_paul +
  theme(legend.position = "none") +
  scale_y_log10() +
  scale_color_manual(values = c(my_color_fill[1],my_color_fill[2],my_color_fill[3])) 


# totalFAMECell , 
plot_cell_content_FAME <-
  ggplot(data = results_PhoCAssPaNS_df,
         aes(x = day , y = totalFAMECell,
             color = lightClass, shape = concentrationClass)) +
  geom_point(size = 3,stroke = 1.25, position = position_dodge(width = 0.25)) +
  geom_line(size = 0.5, linetype = 2) +
  geom_errorbar(aes(ymin = totalFAMECell*(1 - totalFAMECell_rel_error),
                    ymax = totalFAMECell*(1 + totalFAMECell_rel_error)),
                    width = 2, position = position_dodge(width = 0.25)) +
scale_shape_manual(values = c(21,23,24)) +
  labs(title = "i)",
       x = "Day",
       y = expression(bold(atop("Lipid cell quota", paste("(g.cell"^"-1",")"))))) +
  theme_paul +
  scale_y_log10() +
  scale_color_manual(values = c(my_color_fill[1],my_color_fill[2],my_color_fill[3])) 

# totalSugarsCell
plot_cell_content_sugars <-
  ggplot(data = results_PhoCAssPaNS_df,
         aes(x = day , y = totalSugarsCell,
             color = lightClass, shape = concentrationClass)) +
  geom_point(size = 3,stroke = 1.25, position = position_dodge(width = 0.25)) +
  geom_line(size = 0.5, linetype = 2) +
  geom_errorbar(aes(ymin = totalSugarsCell*(1 - totalSugarsCell_rel_error),
                    ymax = totalSugarsCell*(1 + totalSugarsCell_rel_error)),
                    width = 2, position = position_dodge(width = 0.25)) +
scale_shape_manual(values = c(21,23,24)) +
  labs(title = "h)",
       x = "Day",
       y = expression(bold(atop("Carbohydrates cell quota", paste("(g.cell"^"-1",")"))))) +
  theme_paul +
  theme(legend.position = "none") +
  scale_y_log10() +
  scale_color_manual(values = c(my_color_fill[1],my_color_fill[2],my_color_fill[3])) 


plot_global_content_total <- 
  plot_total_content_proteins + plot_total_content_sugars + plot_total_content_FAME +
  plot_mass_content_proteins + plot_mass_content_sugars + plot_mass_content_FAME +
  plot_cell_content_proteins + plot_cell_content_sugars + plot_cell_content_FAME



```

```{r,  echo = include_code , fig.height=14 , fig.width=17 , warning=FALSE}
plot_global_content_total
```

#### Evolution of the functional compartment mass quota

The last value of functional pool mass quota is extracted for each reactor below. The link between this value and the light density in the reactor is then investigated.

```{r,echo = include_code, fig.width=6.5,fig.height=5}

# Initialisation
functional_pool_last <- rep(NA,9)
functionalPool_abs_error_last <- rep(NA,9)

# Loop
for (i_concentration in (1:3)){
  for (j_light in (1:3)){

    # Extraction of per reactor data
    data_reduced <- subset(results_PhoCAssPaNS_df, concentrationClass == concentrationClassList[i_concentration])
    data_reduced <- subset(data_reduced, data_reduced$lightClass == lightClassList[j_light])
    
    # Extraction of the last functional pool quota value of the experiment
    functional_pool_last[3*(i_concentration - 1) + j_light] <- tail(data_reduced$functionalPool[is.na(data_reduced$functionalPool) == 0],n=1)
    functionalPool_abs_error_last[3*(i_concentration - 1) + j_light] <- tail(data_reduced$functionalPool_abs_error[is.na(data_reduced$functionalPool_abs_error) == 0],n=1)
  }
}

# The data obtained is stored in the per reactor data frame.
reactorPhoCAssPaNS_df$functionalPoolLast <- functional_pool_last
reactorPhoCAssPaNS_df$functionalPool_abs_errorLast <- functionalPool_abs_error_last

# Plot of the results
ggplot(data = reactorPhoCAssPaNS_df, aes(x = lightDensity, y = functionalPoolLast, colour = lightClass,shape = concentrationClass)) +
  geom_point(size = 3,stroke = 1.25, position = position_dodge(width = 0.25)) +
  geom_errorbarh(aes(xmin = lightDensity - 1.96*lightDensity_std, xmax = lightDensity + 1.96*lightDensity_std), height = 0.05, position = position_dodge(width = 0.25)) +
scale_shape_manual(values = c(21,23,24)) +
  geom_errorbar(aes(ymin = functional_pool_last - functionalPool_abs_error_last, ymax = functional_pool_last + functionalPool_abs_error_last), width = 2, position = position_dodge(width = 0.25)) +
  ylim(c(0,0.6)) +
  labs(x = expression(bold(atop("Average light density", paste("(µmol.(s.g dry-weight)"^"-1",")")))),
       y = expression(bold(atop("Functional compartment", "final quota (% DW)")))) +
  theme_paul +
  scale_color_manual(values = c(my_color_fill[1],my_color_fill[2],my_color_fill[3]))

# Linear regression between last value of functional pool quota and light density in the reactor to test the hypothesis of a link in the values
lm_local <- lm(functionalPoolLast ~ lightDensity , data = reactorPhoCAssPaNS_df)
summary(lm_local)



```

# Model of lipid accumulation under nitrogen starvation

## Prediction of carbon photosynthesized

### Light distribution and O2 productivity in the e-flasks

```{r Modelling light distribution and O2 productivity in the e-flasks, echo = include_code,warning=FALSE}
# Creation of meshed elementary data in the volume of e-flask
## Geometric data
### r_erlen: radius of the basis of the e-flask (m)
r_erlen <- 0.06
## angle_eflask: angle made by the wall of e-flask with the horizontal plan (rad)
angle_eflask = 80*(2*pi)/360


# Creation of tensors and vectors to store the results
## Tensor of the local volumes of the e-flask
eflask_base_tensor = array(data = rep(NA,(n_mesh+1)^3), dim = c(n_mesh+1,n_mesh+1,n_mesh+1))

## Vector of gross O2 proudctions computed (central, min and max values)
P_O2_gross <- rep(NA,nrow(results_PhoCAssPaNS_df))
P_O2_gross_min <- rep(NA,nrow(results_PhoCAssPaNS_df))
P_O2_gross_max <- rep(NA,nrow(results_PhoCAssPaNS_df))


# Loop of the calculation
## For each row of data, a rate of production of O2  is computed based on the light distribution according to the optical variables determined, and the algae photosynthetic activity according to the Pm coefifcient and light conditions determined
for (iexp in (1:(nrow(results_PhoCAssPaNS_df)-9))){
  # Determination of the e-flaks broth depth (m)
  reactor_depth = results_PhoCAssPaNS_df$reactorDepth[iexp]
  
  
  if (is.na(reactor_depth) == 0){ # This condition is added to not perform the calculation on missing data
    # A set of vectors for each cylindrical coordinates in the e-flasks are developed
    z_coordinates = seq(0,reactor_depth,reactor_depth/n_mesh)
    teta_coordinates = seq(0,2*pi,2*pi/n_mesh)
    r_coordinates <- seq(0,r_erlen - reactor_depth/tan(angle_eflask),(r_erlen - reactor_depth/tan(angle_eflask))/n_mesh)
    
    # Tensors of the set of cylindrical coordinates for the e-flask are initialised. These tensors represent for each elementary volume of the experimental broth the corresponding r, teta, or z coordinate.
    r_coordinates_tensor <- eflask_base_tensor
    teta_coordinates_tensor <- eflask_base_tensor
    z_coordinates_tensor <- eflask_base_tensor
    
    # The tensor previously determined are now filled with the values
    for (i in 1:(n_mesh + 1)){
      for (j in 1:(n_mesh + 1)){
        for (k in 1:(n_mesh + 1)){
          # Assigning coordinates for each point inside the volume of the e-flask
          r_seq <- seq(0,r_erlen - (reactor_depth - z_coordinates[k])/tan(angle_eflask),(r_erlen - (reactor_depth - z_coordinates[k])/tan(angle_eflask))/n_mesh)
          r_coordinates_tensor[i,j,k] <- r_seq[i]
          teta_coordinates_tensor[i,j,k] <- teta_coordinates[j]
          z_coordinates_tensor[i,j,k] <- z_coordinates[k]
        }
      }
    }
    
    # Calculation of local light intensity and local O2 productivity
    # Tensors of local light intensity and local O2 productivity (central, min, and max) are initialised.
    I_local_total_tensor <- eflask_base_tensor
    P_O2_spec_local <- eflask_base_tensor
    P_O2_spec_min_local <- eflask_base_tensor
    P_O2_spec_max_local <- eflask_base_tensor
    
    # The value for incident light intensity is retrieved
    I0_local <-results_PhoCAssPaNS_df$I0Reactor[iexp]
    
    # Variable characteristics of the culture are now retrieved, averaged over the value for the current time step and the following time step for the reactor considered.
    ## Mass specific extinction coefficient at 683 nm (m2/g)
    sigma_local <- 1/2*(results_PhoCAssPaNS_df$sigma683Mass[iexp] + results_PhoCAssPaNS_df$sigma683Mass[iexp + 9])
    ## Cell concentration in the reactor (cell/m3)
    n_algae_local <- 1/2*(results_PhoCAssPaNS_df$cellCount[iexp] + results_PhoCAssPaNS_df$cellCount[iexp + 9])*10^6
    ## Dryweight concentration in the reactor (g/m3)
    x_algae_local <- 1/2*(results_PhoCAssPaNS_df$dryWeight[iexp] + results_PhoCAssPaNS_df$dryWeight[iexp + 9])*1000
    ## specific photosynthetic rate of O2 production (g O2/g DW/s)
    ### Central, minimal, and maximal values are computed
    PmMass_local <- 1/2*(results_PhoCAssPaNS_df$PmMass[iexp] + results_PhoCAssPaNS_df$PmMass[iexp + 9])
    PmMass_min_local <- 1/2*(results_PhoCAssPaNS_df$PmMassMin[iexp] + results_PhoCAssPaNS_df$PmMassMin[iexp + 9])
    PmMass_max_local <- 1/2*(results_PhoCAssPaNS_df$PmMassMax[iexp] + results_PhoCAssPaNS_df$PmMassMax[iexp + 9])
    

    
    # Loop of calculation for global O2 production in the reactor over a 24h period(g 02)
    ## Local O2 production is calculated for each local volume of the tensor, and the global production is based on the sum of the production of each local volume
    for (iv in 1:(n_mesh)){
      for (jv in 1:(n_mesh)){
        for (kv in 1:(n_mesh)){
          
          # The local coordinate is retrieved as the middle point between consecutive coordinates
          r_local = (r_coordinates_tensor[iv,jv,kv] + r_coordinates_tensor[iv+1,jv,kv])/2
          teta_local = (teta_coordinates_tensor[iv,jv,kv] + teta_coordinates_tensor[iv,jv+1,kv])/2
          z_local = (z_coordinates_tensor[iv,jv,kv] + z_coordinates_tensor[iv,jv,kv+1])/2
          
          # The vertical depth in the algae of the local volume is determined
          ## First, the limit of the non-conical part (i.e. part of the central cylindrical volume) of the broth is defined
          r_lim <- r_erlen - reactor_depth/tan(angle_eflask) # Limit of the "non conical" part of the broth
          ## Two cases are possible: 
          ### 1) the local volume is within the central cylindrical volume, the local depth is then computed as the distance from the top of the volume, bong the coordinate zs
          ### 2) the local volume if in the "conical" part, the local depth must then be computed from the edge of the e-flask being below the free surface of the broth
          if (r_local <= r_lim){
            z_s <- z_local
          }else{
            z_s <- z_local - (r_local - r_lim)*tan(angle_eflask)
          }
          # Local light intensity is then determined from Beer-Lambert, assuming vertical radiation, no scattering, from the local depth determined
          I_local_total_tensor[iv,jv,kv] <- I0_local*exp(-sigma_local*x_algae_local*z_s)
          
          # The local volume (m3) is computed
          dV <- (r_coordinates_tensor[iv+1,jv,kv] + r_coordinates_tensor[iv,jv,kv])/2*(r_coordinates_tensor[iv+1,jv,kv] - r_coordinates_tensor[iv,jv,kv])*
              (teta_coordinates_tensor[iv,jv+1,kv] - teta_coordinates_tensor[iv,jv,kv])*
              (z_coordinates_tensor[iv,jv,kv+1] - z_coordinates_tensor[iv,jv,kv])
          
          # O2 local production over 24h is calculated based on Equation 4 in the manuscript
          P_O2_spec_local[iv,jv,kv] <- 
              PmMass_local*sigma_local*(x_algae_local/1000)*I_local_total_tensor[iv,jv,kv]/
                    (alpha_PI*PmMass_local +  sigma_local*(x_algae_local/1000)*I_local_total_tensor[iv,jv,kv] + (1/K2_mass)*(sigma_local*(x_algae_local/1000)*I_local_total_tensor[iv,jv,kv])^2)*
                  x_algae_local*dV*20*3600 # gO2 produced over 24h periods (only 20h of light)
          # Minimum value is computed based on the lower bound of the confidence interval of Pm coefficient
          P_O2_spec_min_local[iv,jv,kv] <- 
              PmMass_min_local*sigma_local*(x_algae_local/1000)*I_local_total_tensor[iv,jv,kv]/
                    (alpha_PI*PmMass_min_local +  sigma_local*(x_algae_local/1000)*I_local_total_tensor[iv,jv,kv] + (1/K2_mass)*(sigma_local*(x_algae_local/1000)*I_local_total_tensor[iv,jv,kv])^2)*
                  x_algae_local*dV*20*3600 # gO2 produced over 24h periods (only 20h of light)
          
          # Maximum value is computed based on the upper bound of the confidence interval of Pm coefficient
          P_O2_spec_max_local[iv,jv,kv] <- 
              PmMass_max_local*sigma_local*(x_algae_local/1000)*I_local_total_tensor[iv,jv,kv]/
                    (alpha_PI*PmMass_max_local +  sigma_local*(x_algae_local/1000)*I_local_total_tensor[iv,jv,kv] + (1/K2_mass)*(sigma_local*(x_algae_local/1000)*I_local_total_tensor[iv,jv,kv])^2)*
                  x_algae_local*dV*20*3600 # gO2 produced over 24h periods (only 20h of light)
        }
      }
    }
    
    # The global O2 production for the reactor over 24h on the interval considered is now determined from the sum of the local productions. THis results is divided by the volume of the reactor thus obtaining a volumetric gross O2 productivity (g02/L/d)
    P_O2_gross[iexp] <- sum(P_O2_spec_local,na.rm = TRUE)/(results_PhoCAssPaNS_df$reactorVolume[iexp]/1000) 
    
    P_O2_gross_min[iexp] <- sum(P_O2_spec_min_local,na.rm = TRUE)/(results_PhoCAssPaNS_df$reactorVolume[iexp]/1000) 
    
    P_O2_gross_max[iexp] <- sum(P_O2_spec_max_local,na.rm = TRUE)/(results_PhoCAssPaNS_df$reactorVolume[iexp]/1000) 
  }
  
  print(iexp)
    
}

```

### Carbon concentration in the e-flasks predicted

Haivng determined the O2 production rate in the reactors, we now translate it in a carbon fixation rate based on photosynthesis stoichiometry.

```{r}
# moles of e- generated calculated from g of O2 produced (mol e-/L/d)
n_electrons_photosynthese <- P_O2_gross*4/32 
# g of carbohydrates generated calculated from mol of e- generated (mol e-/L/d)
prod_CHO_gross <- n_electrons_photosynthese*180/24 # g CHO/L/d

# Rate of respiration globally in the reactor (g O2/L/d)
Respiration_gross <- (results_PhoCAssPaNS_df$Resp1/results_PhoCAssPaNS_df$mAlgaeO2cell)*(results_PhoCAssPaNS_df$dryWeight)*24*3600
# moles of e- generated from respiration (mol e-/L/d)
n_electrons_respiration <- Respiration_gross*4/32
# Carbohydrate consumed from respiration mechanisms (g CHO/L/d)
consumption_CHO_resp <- n_electrons_respiration*180/24

# Gross total rate of carbon fixed as sugars predicted from O2 cell modelling (g C/L/d)
delta_carbon_fixed_CHO_gross_theo = 0.439*prod_CHO_gross
# Gross total rate of carbon from carbohydrate consumed from respiration mechanisms (g C/L/d)
delta_carbon_consumed_CHO_resp_theo = 0.439*consumption_CHO_resp

# Total gross amount of carbon fixed between consecutive samplings (g C/L)
aux_carbon_fixed_gross_theo <- delta_carbon_fixed_CHO_gross_theo*diff(results_PhoCAssPaNS_df$day[1:length(results_PhoCAssPaNS_df$day)],9)

# Determination of gross functional carbon predicted to be fixed in biomass
## Creation of the vector storing the resutls
func_carbon_fixed_gross_theo <- rep(NA,nrow(results_PhoCAssPaNS_df))
## Initialisation based on measured value
func_carbon_fixed_gross_theo[1:9] <- results_PhoCAssPaNS_df$carbonFunctional[1:9]
## Loop of determination:
### From the first value measured, the amount calculated to be fixed in the sampling interval (delta_carbon_fixed_CHO_gross_theo) is consecutively added
for (i in 10:nrow(results_PhoCAssPaNS_df)){
  func_carbon_fixed_gross_theo[i] <- func_carbon_fixed_gross_theo[i - 9] + aux_carbon_fixed_gross_theo[i-9]
}


# Net total rate of carbon fixed as sugars predicted from O2 cell modelling (g C/L/d)
delta_carbon_fixed_CHO_net_theo = delta_carbon_fixed_CHO_gross_theo + delta_carbon_consumed_CHO_resp_theo
# Total net amount carbon fixed between consecutive samplings (g C/L)
aux_carbon_fixed_net_theo <- delta_carbon_fixed_CHO_net_theo*c(diff(results_PhoCAssPaNS_df$day[1:length(results_PhoCAssPaNS_df$day)],9),rep(0,9)) # gC/L
# Determination of net functional carbon predicted to be fixed in biomass
## Creation of the vector storing the resutls
carbon_fixed_net_theo <- rep(NA,nrow(results_PhoCAssPaNS_df))
## Initialisation based on measured value
carbon_fixed_net_theo[1:9] <- results_PhoCAssPaNS_df$carbonFunctional[1:9]
## Loop of determination:
### From the first value measured, the amount calculated to be fixed in the sampling interval (delta_carbon_fixed_CHO_net_theo) is consecutively added
for (i in 10:nrow(results_PhoCAssPaNS_df)){
  carbon_fixed_net_theo[i] <- carbon_fixed_net_theo[i - 9] + aux_carbon_fixed_net_theo[i - 9]
}

# The same calculation are now applied with the lower and upper bound uncertainty interval of the O2 productivity to determine lower and upper bound of the total carbon fixed
## Lower bound
n_electrons_photosynthese_min <- P_O2_gross_min*4/32 
prod_CHO_gross_min <- n_electrons_photosynthese_min*180/24 
delta_carbon_fixed_CHO_gross_theo_min = 0.439*prod_CHO_gross_min 
aux_carbon_fixed_gross_theo_min <- delta_carbon_fixed_CHO_gross_theo_min*diff(results_PhoCAssPaNS_df$day[1:length(results_PhoCAssPaNS_df$day)],9)
func_carbon_fixed_gross_theo_min <- rep(NA,nrow(results_PhoCAssPaNS_df))
func_carbon_fixed_gross_theo_min[1:9] <- results_PhoCAssPaNS_df$carbonFunctional[1:9]
for (i in 10:nrow(results_PhoCAssPaNS_df)){
  func_carbon_fixed_gross_theo_min[i] <- func_carbon_fixed_gross_theo_min[i - 9] + aux_carbon_fixed_gross_theo_min[i-9]
}

## Upper bound
n_electrons_photosynthese_max <- P_O2_gross_max*4/32
prod_CHO_gross_max <- n_electrons_photosynthese_max*180/24
delta_carbon_fixed_CHO_gross_theo_max = 0.439*prod_CHO_gross_max
aux_carbon_fixed_gross_theo_max <- delta_carbon_fixed_CHO_gross_theo_max*diff(results_PhoCAssPaNS_df$day[1:length(results_PhoCAssPaNS_df$day)],9) # gC/L
func_carbon_fixed_gross_theo_max <- rep(NA,nrow(results_PhoCAssPaNS_df))
func_carbon_fixed_gross_theo_max[1:9] <- results_PhoCAssPaNS_df$carbonFunctional[1:9]
for (i in 10:nrow(results_PhoCAssPaNS_df)){
  func_carbon_fixed_gross_theo_max[i] <- func_carbon_fixed_gross_theo_max[i - 9] + aux_carbon_fixed_gross_theo_max[i-9]
}

# Storage of the results in the general data frame
results_PhoCAssPaNS_df$functionalCarbonFixedGrossTheo <- func_carbon_fixed_gross_theo
results_PhoCAssPaNS_df$functionalCarbonFixedGrossTheoMin <- func_carbon_fixed_gross_theo_min
results_PhoCAssPaNS_df$functionalCarbonFixedGrossTheoMax <- func_carbon_fixed_gross_theo_max
results_PhoCAssPaNS_df$carbonFixedNetTheo <- carbon_fixed_net_theo

# Relative error associated 
results_PhoCAssPaNS_df$functionalCarbonFixedGrossTheo_rel_error <- 
  (func_carbon_fixed_gross_theo_max - func_carbon_fixed_gross_theo_min)/
  func_carbon_fixed_gross_theo

```

### Final validation figure

```{r,echo=TRUE, fig.width=6.4,fig.height=5}

plot_functionalCarbon_fixed_exp_vs_theo_gross <- 
  ggplot(data = results_PhoCAssPaNS_df,
         aes(x = functionalCarbonFixedGrossTheo , y = carbonFunctional,
             color = lightClass, shape = concentrationClass)) +
  geom_point(size = 2,stroke = 1.25) +
  geom_errorbar(aes(ymin = carbonFunctional*(1 - carbonFunctional_rel_error), 
                    ymax = carbonFunctional*(1 + carbonFunctional_rel_error)),
                width = 0.1) +
  geom_errorbarh(aes(xmin = functionalCarbonFixedGrossTheoMin,
                    xmax = functionalCarbonFixedGrossTheoMax,
                    height = 0.1)) +
scale_shape_manual(values = c(21,23,24)) +
  geom_abline(slope = 1, intercept = 0, size = 1, linetype = "dashed") +
  # xlim(c(0,3)) + ylim(c(0,3)) +
  labs(x = expression(bold(atop("Theoretical gross total carbon", paste("fixed in biomass (g C.L"^"-1",")")))),
       y = expression(bold(atop("Experimental total functional carbon ", paste("fixed in biomass (g C.L"^"-1",")"))))) +
  theme_paul_highColourFill +
  scale_color_manual(values = c(my_color_fill[1],my_color_fill[2],my_color_fill[3])) +
  scale_fill_manual(values = c(my_color_fill[1],my_color_fill[2],my_color_fill[3]))

plot_functionalCarbon_fixed_exp_vs_theo_gross
```

```{r, echo = include_code,warning=FALSE,fig.width=7,fig.height=5}

summary(lm(carbonFunctional ~ functionalCarbonFixedGrossTheo + 0, data = results_PhoCAssPaNS_df))

```

## Decay rate analysis

We compute the decay from the delta between the functional carbon measured (i.e. the carbon contained in protein, lipid, and CHO) and the theoretical gross carbon fixed, as the slope of the regression from this delta with regards to time. As we expect a carbon loss proportional to time and total biomass, we also reduce this delta specifically to biomass dry-weight concentration.

### Gross fixed theo vs functional

```{r}
# The mass specific gross carbon theoretically fixed is first calculated (g C/g dw) 
results_PhoCAssPaNS_df$specificCarbonFunctionalFixedGrossTheo <- 
  results_PhoCAssPaNS_df$functionalCarbonFixedGrossTheo/results_PhoCAssPaNS_df$dryWeight
# Relative error associated to this value is likewise computed (%)
results_PhoCAssPaNS_df$specificCarbonFunctionalFixedGrossTheo_rel_error <-
  sqrt(results_PhoCAssPaNS_df$functionalCarbonFixedGrossTheo_rel_error^2 + 
         dryweight_rel_error^2)

# The mass specific functional carbon fixed experimentally determined is determined (g C/g dw) 
results_PhoCAssPaNS_df$specificCarbonFunctional <- results_PhoCAssPaNS_df$carbonFunctional/results_PhoCAssPaNS_df$dryWeight
# Relative error is also determined (%)
results_PhoCAssPaNS_df$specificCarbonFunctional_rel_error <-
  sqrt(results_PhoCAssPaNS_df$carbonFunctional_rel_error^2 +
         dryweight_rel_error^2)

# The delta of specific carbon fixed between gross theoretical value and functional experimentally measured is determined (g C/g dw/d)
results_PhoCAssPaNS_df$specificCarbonRespirationLoss <-
  results_PhoCAssPaNS_df$specificCarbonFunctional - results_PhoCAssPaNS_df$specificCarbonFunctionalFixedGrossTheo
# Error associated is determined (absolute error, g C/g DW/d)
results_PhoCAssPaNS_df$specificCarbonRespirationLoss_abs_error <-
  sqrt((results_PhoCAssPaNS_df$specificCarbonFunctional*
          results_PhoCAssPaNS_df$specificCarbonFunctional_rel_error)^2  +
       (results_PhoCAssPaNS_df$specificCarbonFunctionalFixedGrossTheo*
          results_PhoCAssPaNS_df$specificCarbonFunctional_rel_error)^2)

# Determination of respiration rate
## Initialisation of vector of results
decay_rate_vector <- rep(NA,9)
decay_rate_vector_IC <- rep(NA,9)
  
## Loop of calculation
for (i_concentration in (1:3)){
  for (j_light in (1:3)){
     # Retrieving specific reactor data
    data_reduced <- subset(results_PhoCAssPaNS_df, concentrationClass == concentrationClassList[i_concentration])
    data_reduced <- subset(data_reduced, data_reduced$lightClass == lightClassList[j_light])
    
    # Linear regression of the biomass carbon delta between gross theoretical and net experimentally determined
    local_lm <- lm( specificCarbonRespirationLoss ~ day + 0 , data = data_reduced[,])
    a  <- summary(local_lm)
    
    # The slope of the regression is retrieved and stored as the respiration rate for the reactor, the statistically determined standard deviation is retained for uncertainty value on the respiration rate coefficient
    decay_rate_vector[3*(i_concentration-1) + j_light] <-  a$coefficients[1,1]
    decay_rate_vector_IC[3*(i_concentration-1)+j_light] <- a$coefficients[1,2]
  }
}

# The results are registered in the reactor specific data frame.
reactorPhoCAssPaNS_df$specificDecayRate <- decay_rate_vector
reactorPhoCAssPaNS_df$specificDecayRate_rel_error <- 1.96*decay_rate_vector_IC/decay_rate_vector


# A global decay rate is determined as the average of all decay rate calculated in the 9 reactors

mean(reactorPhoCAssPaNS_df$specificDecayRate)
sd(reactorPhoCAssPaNS_df$specificDecayRate)/sqrt(9)

lambda_decay <- mean(reactorPhoCAssPaNS_df$specificDecayRate)

```

```{r ,fig.height=5,fig.width=7}
ggplot(data = reactorPhoCAssPaNS_df,aes(x = lightDensity,y = -specificDecayRate, colour = lightClass,shape = concentrationClass)) +
  geom_point(size = 3,stroke = 1.25) +
  geom_errorbar(aes(ymin = -(specificDecayRate*(1 - specificDecayRate_rel_error)), ymax = -(specificDecayRate*(1 + specificDecayRate_rel_error))),
                stroke = 1.25, width = 1) +
  geom_errorbarh(aes(xmin = (lightDensity -1.96*lightDensityStd),
                     xmax = (lightDensity + 1.96*lightDensityStd)),
                stroke = 1.25, height = 0.0025) +
  scale_shape_manual(values = c(21,23,24),na.translate = FALSE) +
  labs(x = expression(bold(atop("Dryweight specific light density ",
                                 paste("(µmol.(g DW.s)"^"-1","])")))),
       y = expression(bold(paste(atop("Specific rate of endogenous carbon", 
                                      paste("consumption (g C.g DW"^"-1",".d"^"-1",")")))))) +
  theme_paul +
  scale_color_manual(values = c(my_color_fill[1],my_color_fill[2],my_color_fill[3])) 
  

ggplot(data = reactorPhoCAssPaNS_df,aes(x = lightDensityCell,y = specificDecayRate, colour = lightClass,shape = concentrationClass)) +
  geom_point() + 
  geom_errorbar(aes(ymin = (specificDecayRate*(1 - specificDecayRate_rel_error)), ymax = (specificDecayRate*(1 + specificDecayRate_rel_error))),
                stroke = 1.25) +
  geom_errorbarh(aes(xmin = (lightDensityCell -1.96*lightDensityCell_std), xmax = (lightDensityCell + 1.96*lightDensityCell_std)),
                stroke = 1.25) +
  scale_shape_manual(values = c(1,2,4),na.translate = FALSE) +
  geom_point(size = 3,stroke = 1.25) +
  scale_x_log10() +
  labs(x = expression(bold(atop("Cell specific light density ",
                                 paste("(µmol.(cell.s)"^"-1","])")))),
       y = expression(bold(paste("Specific decay rate (g C.g DW"^"-1",".d"^"-1",")")))) +
  theme_paul +
  scale_color_manual(values = c(my_color_fill[1],my_color_fill[2],my_color_fill[3])) 


```

### Per reactor plot of engodenous respiration rate determination

```{r, echo = include_code}
# Scaled boundary of the plots
## We set the minimum and maximum values for all plots in order to have coherent and comparable scales between reactors
y_min <- -0.6
y_max <- 0.35

# The plots of the delta between theoretical gross specific carbon fixed and experimental specific net functional carbon fixed are plotted against time, and associated linear regression (with null intercept) 
## 0.1 g/L, 75% light filter
plot_carbon_biomass_LoCoLoLi <- ggplot(data = subset(results_PhoCAssPaNS_df, sample == "LoCoLoLi"),
       aes(x = day , y = specificCarbonRespirationLoss, color = sample, shape = sample)) +
  scale_shape_manual(values = 1:nlevels(shape_factor),na.translate = FALSE) +
  geom_point(size = 3, stroke = 1.25) +
  geom_errorbar(aes(ymin = specificCarbonRespirationLoss - specificCarbonRespirationLoss_abs_error,
                    ymax = specificCarbonRespirationLoss + specificCarbonRespirationLoss_abs_error),
                width = 2) +
  geom_smooth(method = "lm", formula = y ~ x + 0 , geom = "smooth") +
  ylim(c(y_min,y_max)) +
  geom_abline(aes(slope = 0, intercept = 0), linetype = "dashed",linewidth = 1.5, color = "black") +
  labs(x = "Day",
       y = expression(bold(atop("Loss of specific functional carbon",paste("(g C.g DW"^"-1",")")))),
       title = expression(bold(paste("0.1 g.L"^"-1"," ; 75% light filter")))) +
  theme_paul_highColourFill +
  theme(axis.text.x = element_blank(),
        axis.ticks.x = element_blank(),
        axis.title.x = element_blank(),
        axis.title.y = element_blank(),
        plot.title = element_text(size = 12))



## 0.1 g/L, 50% light filter
plot_carbon_biomass_LoCoMeLi <- ggplot(data = subset(results_PhoCAssPaNS_df, sample == "LoCoMeLi"),
     aes(x = day , y = specificCarbonRespirationLoss, color = sample, shape = sample)) +
  scale_shape_manual(values = 1:nlevels(shape_factor),na.translate = FALSE) +
  geom_point(size = 3, stroke = 1.25) +
  geom_errorbar(aes(ymin = specificCarbonRespirationLoss - specificCarbonRespirationLoss_abs_error,
                    ymax = specificCarbonRespirationLoss + specificCarbonRespirationLoss_abs_error),
                width = 2) +
  geom_smooth(method = "lm", formula = y ~ x + 0 , geom = "smooth") +
  ylim(c(y_min,y_max)) +
  geom_abline(aes(slope = 0, intercept = 0), linetype = "dashed",linewidth = 1.5, color = "black") +
  labs(x = "Day",
       y = expression(bold(atop("Loss of specific functional carbon",paste("(g C.g DW"^"-1",")")))),
       title = expression(bold(paste("0.1 g.L"^"-1"," ; 50% light filter")))) +
 ylim(c(y_min,y_max)) +
 theme_paul_highColourFill +
  # Remove axis labels & ticks
  theme(axis.text.x = element_blank(),
        axis.ticks.x = element_blank(),
        axis.text.y = element_blank(),
        axis.ticks.y = element_blank(),
        axis.title.x = element_blank(),
        axis.title.y = element_blank(),
        plot.title = element_text(size = 12))



## 0.1 g/L, No light filter
plot_carbon_biomass_LoCoHiLi <- ggplot(data = subset(results_PhoCAssPaNS_df, sample == "LoCoHiLi"),
     aes(x = day , y = specificCarbonRespirationLoss, color = sample, shape = sample)) +
  scale_shape_manual(values = 1:nlevels(shape_factor),na.translate = FALSE) +
  geom_point(size = 3, stroke = 1.25) +
  geom_errorbar(aes(ymin = specificCarbonRespirationLoss - specificCarbonRespirationLoss_abs_error,
                    ymax = specificCarbonRespirationLoss + specificCarbonRespirationLoss_abs_error),
                width = 2) +
  geom_smooth(method = "lm", formula = y ~ x + 0 , geom = "smooth") +
  ylim(c(y_min,y_max)) +
  geom_abline(aes(slope = 0, intercept = 0), linetype = "dashed",linewidth = 1.5, color = "black") +
  labs(x = "Day",
       y = expression(bold(atop("Loss of specific functional carbon",paste("(g C.g DW"^"-1",")")))),
       title = expression(bold(paste("0.1 g.L"^"-1"," ; No light filter")))) +
  ylim(c(y_min,y_max)) +
 theme_paul_highColourFill +
  # Remove axis labels & ticks
  theme(axis.text.x = element_blank(),
        axis.ticks.x = element_blank(),
        axis.text.y = element_blank(),
        axis.ticks.y = element_blank(),
        axis.title.x = element_blank(),
        axis.title.y = element_blank(),
        plot.title = element_text(size = 12))



## 0.3 g/L, 75% light filter
plot_carbon_biomass_MeCoLoLi <- ggplot(data = subset(results_PhoCAssPaNS_df, sample == "MeCoLoLi"),
     aes(x = day , y = specificCarbonRespirationLoss, color = sample, shape = sample)) +
  scale_shape_manual(values = 1:nlevels(shape_factor),na.translate = FALSE) +
  geom_point(size = 3, stroke = 1.25) +
  geom_errorbar(aes(ymin = specificCarbonRespirationLoss - specificCarbonRespirationLoss_abs_error,
                    ymax = specificCarbonRespirationLoss + specificCarbonRespirationLoss_abs_error),
                width = 2) +
  geom_smooth(method = "lm", formula = y ~ x + 0 , geom = "smooth") +
  ylim(c(y_min,y_max)) +
  geom_abline(aes(slope = 0, intercept = 0), linetype = "dashed",linewidth = 1.5, color = "black") +
  labs(x = "Day",
       y = expression(bold(atop("Loss of specific functional",paste("carbon (g C.g DW"^"-1",")")))),
       title = expression(bold(paste("0.3 g.L"^"-1"," ; 75% light filter")))) +
  theme_paul_highColourFill +
  # Remove axis labels & ticks
  theme(axis.text.x = element_blank(),
        axis.ticks.x = element_blank(),
        axis.title.x = element_blank(),
        plot.title = element_text(size = 12))



## 0.3 g/L, 50% light filter
plot_carbon_biomass_MeCoMeLi <- ggplot(data = subset(results_PhoCAssPaNS_df, sample == "MeCoMeLi"),
     aes(x = day , y = specificCarbonRespirationLoss, color = sample, shape = sample)) +
  scale_shape_manual(values = 1:nlevels(shape_factor),na.translate = FALSE) +
  geom_point(size = 3, stroke = 1.25) +
  geom_errorbar(aes(ymin = specificCarbonRespirationLoss - specificCarbonRespirationLoss_abs_error,
                    ymax = specificCarbonRespirationLoss + specificCarbonRespirationLoss_abs_error),
                width = 2) +
  geom_smooth(method = "lm", formula = y ~ x + 0 , geom = "smooth") +
  ylim(c(y_min,y_max)) +
  geom_abline(aes(slope = 0, intercept = 0), linetype = "dashed",linewidth = 1.5, color = "black") +
  labs(x = "Day",
       y = expression(bold(atop("Loss of specific functional carbon",paste("(g C.g DW"^"-1",")")))),
       title = expression(bold(paste("0.3 g.L"^"-1"," ; 50% light filter")))) +
  theme_paul_highColourFill +
  # Remove axis labels & ticks
  theme(axis.text.x = element_blank(),
        axis.ticks.x = element_blank(),
        axis.text.y = element_blank(),
        axis.ticks.y = element_blank(),
        axis.title.x = element_blank(),
        axis.title.y = element_blank(),
        plot.title = element_text(size = 12))



## 0.3 g/L, No light filter
plot_carbon_biomass_MeCoHiLi <- ggplot(data = subset(results_PhoCAssPaNS_df, sample == "MeCoHiLi"),
     aes(x = day , y = specificCarbonRespirationLoss, color = sample, shape = sample)) +
  scale_shape_manual(values = 1:nlevels(shape_factor),na.translate = FALSE) +
  geom_point(size = 3, stroke = 1.25) +
  geom_errorbar(aes(ymin = specificCarbonRespirationLoss - specificCarbonRespirationLoss_abs_error,
                    ymax = specificCarbonRespirationLoss + specificCarbonRespirationLoss_abs_error),
                width = 2) +
  geom_smooth(method = "lm", formula = y ~ x + 0 , geom = "smooth") +
  ylim(c(y_min,y_max)) +
  geom_abline(aes(slope = 0, intercept = 0), linetype = "dashed",linewidth = 1.5, color = "black") +
  labs(x = "Day",
       y = expression(bold(atop("Loss of specific functional carbon",paste("(g C.g DW"^"-1",")")))),
       title = expression(bold(paste("0.3 g.L"^"-1"," ; No light filter")))) +
  theme_paul_highColourFill +
  # Remove axis labels & ticks
  theme(axis.text.x = element_blank(),
        axis.ticks.x = element_blank(),
        axis.ticks.y = element_blank(),
        axis.title.y = element_blank(),
        plot.title = element_text(size = 12))



## 1.0 g/L, 75% light filter
plot_carbon_biomass_HiCoLoLi <- ggplot(data = subset(results_PhoCAssPaNS_df, sample == "HiCoLoLi"),
     aes(x = day , y = specificCarbonRespirationLoss, color = sample, shape = sample)) +
  scale_shape_manual(values = 1:nlevels(shape_factor),na.translate = FALSE) +
  geom_point(size = 3, stroke = 1.25) +
  geom_errorbar(aes(ymin = specificCarbonRespirationLoss - specificCarbonRespirationLoss_abs_error,
                    ymax = specificCarbonRespirationLoss + specificCarbonRespirationLoss_abs_error),
                width = 2) +
  geom_smooth(method = "lm", formula = y ~ x + 0 , geom = "smooth") +
  ylim(c(y_min,y_max)) +
  geom_abline(aes(slope = 0, intercept = 0), linetype = "dashed",linewidth = 1.5, color = "black") +
  labs(x = "Day",
       y = expression(bold(atop("Loss of specific functional carbon",paste("(g C.g DW"^"-1",")")))),
       title = expression(bold(paste("1.0 g.L"^"-1"," ; 75% light filter")))) +
  theme_paul_highColourFill + 
  theme(axis.title.y = element_blank(),
        plot.title = element_text(size = 12))



## 1.0 g/L, 50% light filter
plot_carbon_biomass_HiCoMeLi <- ggplot(data = subset(results_PhoCAssPaNS_df, sample == "HiCoMeLi"),
     aes(x = day , y = specificCarbonRespirationLoss, color = sample, shape = sample)) +
  scale_shape_manual(values = 1:nlevels(shape_factor),na.translate = FALSE) +
  geom_point(size = 3, stroke = 1.25) +
  geom_errorbar(aes(ymin = specificCarbonRespirationLoss - specificCarbonRespirationLoss_abs_error,
                    ymax = specificCarbonRespirationLoss + specificCarbonRespirationLoss_abs_error),
                width = 2) +
  geom_smooth(method = "lm", formula = y ~ x + 0 , geom = "smooth") +
  ylim(c(y_min,y_max)) +
  geom_abline(aes(slope = 0, intercept = 0), linetype = "dashed",linewidth = 1.5, color = "black") +
  labs(x = "Day",
       y = expression(bold(atop("Loss of specific functional carbon",paste("(g C.g DW"^"-1",")")))),
       title = expression(bold(paste("1.0 g.L"^"-1"," ; 50% light filter")))) +
  theme_paul_highColourFill +
  # Remove axis labels & ticks
  theme(axis.text.y = element_blank(),
        axis.ticks.y = element_blank(),
        axis.title.y = element_blank(),
        plot.title = element_text(size = 12))

## 1.0 g/L, No light filter
plot_carbon_biomass_HiCoHiLi <- ggplot(data = subset(results_PhoCAssPaNS_df, sample == "HiCoHiLi"),
     aes(x = day , y = specificCarbonRespirationLoss, color = sample, shape = sample)) +
  scale_shape_manual(values = 1:nlevels(shape_factor),na.translate = FALSE) +
  geom_point(size = 3, stroke = 1.25) +
  geom_errorbar(aes(ymin = specificCarbonRespirationLoss - specificCarbonRespirationLoss_abs_error,
                    ymax = specificCarbonRespirationLoss + specificCarbonRespirationLoss_abs_error),
                width = 2) +
  geom_smooth(method = "lm", formula = y ~ x + 0, geom = "smooth") +
  ylim(c(y_min,y_max)) +
  geom_abline(aes(slope = 0, intercept = 0), linetype = "dashed",linewidth = 1.5, color = "black") +
  labs(x = "Day",
       y = expression(bold(atop("Loss of specific functional carbon",paste("(g C.g DW"^"-1",")")))),
       title = expression(bold(paste("1.0 g.L"^"-1"," ; No light filter")))) +
  ylim(c(y_min,y_max)) +
 theme_paul_highColourFill +
  # Remove axis labels & ticks
  theme(axis.text.y = element_blank(),
        axis.ticks.y = element_blank(),
        axis.title.y = element_blank(),
        plot.title = element_text(size = 12))

# Compilation in a single plot
plot_carbon_biomass_all <- plot_carbon_biomass_LoCoLoLi + theme(legend.position = "none") +
  plot_carbon_biomass_LoCoMeLi +  theme(legend.position = "none") +
  plot_carbon_biomass_LoCoHiLi +  theme(legend.position = "none") +
  plot_carbon_biomass_MeCoLoLi + theme(legend.position = "none") +
  plot_carbon_biomass_MeCoMeLi + theme(legend.position = "none") +
  plot_carbon_biomass_MeCoHiLi + theme(legend.position = "none") +
  plot_carbon_biomass_HiCoLoLi + theme(legend.position = "none") +
  plot_carbon_biomass_HiCoMeLi + theme(legend.position = "none") +
  plot_carbon_biomass_HiCoHiLi + theme(legend.position = "none")

```

```{r, echo = include_code,fig.width=10,fig.height=10,warning=FALSE}
plot_carbon_biomass_all
```

## Prediction of Pm

A predictive model for the specific photosynthetic rate of O2 production (Pm coefficient) is investigated through successive Spearman rank regression analysis. Parameters which variations are significantly linked to Pm coefficient variations are identified. A mathematical relationship between both variables are then investigated, implemented, and the process is repeated on the residuals.

### First Spearman rank analysis

```{r, echo = include_code}
# Results data frame is replicated so potential transforamtions on it can be implemented prior to generalized Spearman rank correlation analysis 
lm_PhoCAssPaNS <- results_PhoCAssPaNS_df

# Lines with an absence of PmMass data are removed to avoid errors
lm_PhoCAssPaNS <- lm_PhoCAssPaNS[is.na(lm_PhoCAssPaNS$PmMass) == 0,]

# Non numeric data are removed to prevent errors
local_lm_PhoCAssPaNS <- lm_PhoCAssPaNS %>% select(where(is.numeric))
lm_PhoCAssPaNS <- local_lm_PhoCAssPaNS


# Spearman rank analysis
## Exctracting the number of columns
n_col = ncol(lm_PhoCAssPaNS)
# Initialising the results matrix
## rho_spear_mat: matrix of Spearman rank coefficients 
rho_spear_mat <- matrix(NA,nrow = n_col, ncol = n_col)
## p_spear_mat: matix of associated p-values
p_spear_mat <- matrix(NA,nrow = n_col, ncol = n_col)

# Loop for Spearman rank analysis
## All variables are cross-tested through Spearman analysis
for (i_row in (1:n_col)){
  for (j_col in (1:n_col)){
    ## The following line aims at avoiding the calculation should an error be expected
    local_test <- try(cor.test(x = as.double(lm_PhoCAssPaNS[,i_row]),
                           y = as.double(lm_PhoCAssPaNS[,j_col]),
                           method = "spearman"))
    ## In case an error is expected, no Spearman rank analysis is performed, and a value NA is instead registered in the result matrix
    if (class(local_test) == "try-error"){
      rho_spear_mat[i_row,j_col] <- NA
      p_spear_mat[i_row,j_col] <- NA
    }else{
      # Case with no error reported: results from spearman rank analysis are collected and registered in the result matrices
      rho_local <- local_test$estimate
      p_local <- local_test$p.value
      rho_spear_mat[i_row,j_col] <- rho_local
      p_spear_mat[i_row,j_col] <- p_local
    }
  }
}
# Column names and row names are implemented to the Spearman rank matrix (names being the variables tested names)
## The names being the same for the p-value matrix, only one implementation is needed here
colnames(rho_spear_mat) <- colnames(lm_PhoCAssPaNS)
rownames(rho_spear_mat) <- colnames(lm_PhoCAssPaNS)


# Results from Spearman rank analysis for the variable PmMass are extracted, both for Spearman coeff and p-value
index <- which(colnames(rho_spear_mat) == "PmMass") 
PmMass_rho <- rho_spear_mat[index,]
PmMass_p <- p_spear_mat[index,]

# We now order the variable names according to the most significant values in the sense of increasing p-values
colnames_vector <- colnames(lm_PhoCAssPaNS)
colnames_vector_pOrder <- colnames_vector[order(PmMass_p)]

PmMass_rho_analysis <- matrix(c(PmMass_rho[order(PmMass_p)],colnames_vector_pOrder),ncol = 2)
PmMass_p_analysis <- matrix(c(PmMass_p[order(PmMass_p)],colnames_vector_pOrder),ncol = 2)

# Printing of the results
## A matrix of the spearman rank coefficient and p-values, ordered by increasing p-values is created
local_matrix <- matrix(c(PmMass_rho_analysis,PmMass_p_analysis),ncol = 4)
## the matrix is limited to p-values below 0.01
local_matrix <- local_matrix[as.numeric(local_matrix[,3]) < 0.01,]
local_matrix <- local_matrix[,1:3]
## We remove lines for parameters irrelevant to the analysis
listRemove <- 
  which(local_matrix[,2] %in% c("PmMass","PmMassMax","PmMassMin", # Removed due to being evidently correlated to Pm
                              "tnSpecific","tnCellSpecific","carbonFixedProteinsExp","carbonFixedLipidsExp", #Removed due to being redundant 
                              "predicted_q_P","predicted_cnRatio","predicted_Pm","predicted_sigma683Mass","predictedSigma683Mass","predicted_q_P_cell","predicted_q_L","predicted_q_L_cell","carbonFixedNetTheo", # Removed due to being predicted instead of measured data
                              "functionalCarbonFixedGrossTheo_rel_error","specificCarbonFunctionalFixedGrossTheo_rel_error","functionalPool_abs_error","specificCarbonRespirationLoss_abs_error","carbonFunctional_rel_error","specificCarbonFunctional_rel_error","Resp2Error","totalFame_rel_error","totalFAMECell_rel_error","carbonFixedLipidsExp_rel_error","lambdaPhotorespRelError", # removed due to being an error estimate
                              "OD880O2Cell","OD683O2Cell","mAlgaeO2cell","PO21","PO22","sampledVolume","nAlgaeO2cell","dilutionFactorO2Cell")) # removed due to being uncharacteristic to the culture conditions
                              
local_matrix <- local_matrix[-listRemove,]
print(local_matrix)


```

### Regression with C:N ratio and determination of residuals

The variables most significantly related to Pm coefficient were chlorophyll-a and b content. Next in line being C:N ratio, which was deemed more adapted to a predictive model for being direclty computed based on the model structure. The relationship between C:N ratio and Pm coefficient was therefore investigated.

```{r, fig.height=5,fig.width=6.5}

# A plot of Pm coefficient according to the C:N ratio was drawn

ggplot(data = results_PhoCAssPaNS_df,aes(x = cnRatio , y = PmMass )) +
  geom_point(size = 3, shape = 21, stroke = 1.25) +
  geom_errorbar(aes(ymin = PmMassMin,
                    ymax = PmMassMax),
                stroke = 1.25, width = 0.025) +
  labs(y = expression(bold(atop("Maximum specific rate of",
                                paste("photosynthesis (g O"[2],".g"^"-1",".s"^"-1",")")))),
       x = "Biomass C:N ratio") +
  scale_x_log10() +
  scale_y_log10() +
  geom_smooth(method = "lm", formula = y ~ x,geom = "smooth") +
  theme_paul


# The investigation evidenced a linear relationship between log(C:N ratio) and log(Pm). Details from this linear relationship are now determined.
## Creation of a local data frame to perform the linear regression with transformed Pm coefficient.
Pm_model_data = data.frame(PmMass = results_PhoCAssPaNS_df$PmMass,
                           cnRatio = results_PhoCAssPaNS_df$cnRatio,
                           PmMassMin = results_PhoCAssPaNS_df$PmMassMin,
                           PmMassMax = results_PhoCAssPaNS_df$PmMassMax,
                           log_PmMass_Norm = log(results_PhoCAssPaNS_df$PmMass/Pm_0_exp),
                           log_cnRatio = log(results_PhoCAssPaNS_df$cnRatio))

# ## Removing NA values to avoid errors
# na_value_vector <- which(is.na(Pm_model_data$log_PmMass) == 1)
# Pm_model_data <- Pm_model_data[is.na(Pm_model_data$log_PmMass) == 0,]

## Linear regression
lm_Pm <- lm(formula = log_PmMass_Norm ~ log_cnRatio ,
            data = Pm_model_data,na.action = na.exclude)      

## Results from the linear regression
a <- summary(lm_Pm)
a$r.squared # R^2
a$coefficients[2,4] # pvalue



# An equation in the form of Pm = Pm_0*(cnRation/cnRatio_char)^gamma_Pm was confirmed by the analysis
## Calculation of the regression equation without log-transformation. Error is determined from the standard error determined in the regression and error propagation analysis
gamma_Pm <- a$coefficients[2,1]
cnRatio_char <- exp(-a$coefficients[1,1]/a$coefficients[2,1])

gamma_Pm_rel_error = abs(1.96*a$coefficients[2,2]/a$coefficients[2,1])
abs(gamma_Pm_rel_error*gamma_Pm/1.96)

cnRatio_char_rel_error <- 1.96*sqrt( (a$coefficients[1,2]/a$coefficients[1,1])^2 + (a$coefficients[2,2]/a$coefficients[2,1])^2 ) 
cnRatio_char*cnRatio_char_rel_error/1.96

# Model residuals are finally implemented in the results data frame to prepare for the repetition of Spearman rank analysis on it
results_PhoCAssPaNS_df$PmMassModelResiduals <- results_PhoCAssPaNS_df$PmMass - Pm_0_exp*(results_PhoCAssPaNS_df$cnRatio/cnRatio_char)^(gamma_Pm)

SSR_Pm <- sum((results_PhoCAssPaNS_df$PmMass - results_PhoCAssPaNS_df$PmMassModelResiduals)^2,na.rm = TRUE)
SST_Pm <- sum((results_PhoCAssPaNS_df$PmMass - mean(results_PhoCAssPaNS_df$PmMass,na.rm = TRUE))^2,na.rm = TRUE)

R2_Pm <- 1-SSR_Pm/SST_Pm
R2_Pm

# Plot of the regression
Pm_model_data$predictedPmMass <- Pm_0_exp*(Pm_model_data$cnRatio/cnRatio_char)^gamma_Pm
Pm_model_data$predictedPmMassMax <- Pm_max_exp*(Pm_model_data$cnRatio/(cnRatio_char*(1 + cnRatio_char_rel_error)))^(gamma_Pm*(1 - gamma_Pm_rel_error))
Pm_model_data$predictedPmMassMin <- Pm_min_exp*(Pm_model_data$cnRatio/(cnRatio_char*(1 - cnRatio_char_rel_error)))^(gamma_Pm*(1 + gamma_Pm_rel_error))


ggplot(data = Pm_model_data,aes(x = cnRatio , y = PmMass )) +
  geom_ribbon(aes(ymin = predictedPmMassMin, ymax = predictedPmMassMax), fill = "grey70",alpha = 0.6) +
  geom_point(size = 3, shape = 21, stroke = 1.5) +
  geom_errorbar(aes(ymin = PmMassMin,
                    ymax = PmMassMax),
                stroke = 1.5, width = 0.5) +
  labs(y = expression(bold(atop("Maximum specific rate of",
                                paste("photosynthesis (g O"[2],".g"^"-1",".s"^"-1",")")))),
       x = "Biomass C:N ratio") +
  geom_line(aes(x = cnRatio, y = predictedPmMass), col = "blue",size = 1) +
  scale_y_log10() +
  # xlim(c(0,30)) +
  theme_paul
```

### Analysis of residuals

Spearman rank analysis is now repeated on the model residuals.

```{r, echo = include_code, fig.width= 5, fig.height= 5}
# Preparation
lm_PhoCAssPaNS <- results_PhoCAssPaNS_df
lm_PhoCAssPaNS <- lm_PhoCAssPaNS[is.na(lm_PhoCAssPaNS$PmMassModelResiduals) == 0,]
local_lm_PhoCAssPaNS <- lm_PhoCAssPaNS %>% select(where(is.numeric))
lm_PhoCAssPaNS <- local_lm_PhoCAssPaNS

# Spearman rank analysis
n_col = ncol(lm_PhoCAssPaNS)
rho_spear_mat <- matrix(NA,nrow = n_col, ncol = n_col)
p_spear_mat <- matrix(NA,nrow = n_col, ncol = n_col)
for (i_row in (1:n_col)){
  for (j_col in (1:n_col)){
    name_var_x <- colnames(lm_PhoCAssPaNS)[i_row]
    name_var_y <- colnames(lm_PhoCAssPaNS)[j_col]
    local_test <- try(cor.test(x = as.double(lm_PhoCAssPaNS[,i_row]),
                           y = as.double(lm_PhoCAssPaNS[,j_col]),
                           method = "spearman"))
    if (class(local_test) == "try-error"){
      rho_spear_mat[i_row,j_col] <- NA
      p_spear_mat[i_row,j_col] <- NA
    }else{
      rho_local <- local_test$estimate
      p_local <- local_test$p.value
      rho_spear_mat[i_row,j_col] <- rho_local
      p_spear_mat[i_row,j_col] <- p_local
    }
  }
}
colnames(rho_spear_mat) <- colnames(lm_PhoCAssPaNS)
rownames(rho_spear_mat) <- colnames(lm_PhoCAssPaNS)

# Retrieving data
index <- which(colnames(rho_spear_mat) == "logPmNormModelResiduals")

PmMassModelResiduals_rho <- rho_spear_mat[index,]
PmMassModelResiduals_p <- p_spear_mat[index,]

colnames_vector <- colnames(lm_PhoCAssPaNS)
colnames_vector_pOrder <- colnames_vector[order(PmMassModelResiduals_p)]

PmMassModelResiduals_rho_analysis <- matrix(c(PmMassModelResiduals_rho[order(PmMassModelResiduals_p)],colnames_vector_pOrder),ncol = 2)
PmMassModelResiduals_p_analysis <- matrix(c(PmMassModelResiduals_p[order(PmMassModelResiduals_p)],colnames_vector_pOrder),ncol = 2)

local_matrix <- matrix(data = c(PmMassModelResiduals_rho_analysis,PmMassModelResiduals_p_analysis),ncol = 4)
local_matrix <- local_matrix[,1:3]
print(local_matrix)


local_matrix <- local_matrix[as.numeric(local_matrix[,3]) < 0.01,]

listRemove <- 
  which(local_matrix[,2] %in% c("PmMass","PmMassMax","PmMassMin", # Removed due to being evidently correlated to Pm
                              "tnSpecific","tnCellSpecific","carbonFixedProteinsExp","carbonFixedLipidsExp", #Removed due to being redundant 
                              "predicted_q_P","predicted_cnRatio","predicted_Pm","predicted_sigma683Mass","predictedSigma683Mass","predicted_q_P_cell","predicted_q_L","predicted_q_L_cell","carbonFixedNetTheo", # Removed due to being predicted instead of measured data
                              "functionalCarbonFixedGrossTheo_rel_error","specificCarbonFunctionalFixedGrossTheo_rel_error","functionalPool_abs_error","specificCarbonRespirationLoss_abs_error","carbonFunctional_rel_error","specificCarbonFunctional_rel_error","Resp1Error","Resp2Error","totalFame_rel_error","totalFAMECell_rel_error","carbonFixedLipidsExp_rel_error","lambdaPhotorespRelError","lambdaDarkRelError", # removed due to being an error estimate
                              "OD880O2Cell","OD683O2Cell","mAlgaeO2cell","PO21","PO22","sampledVolume","nAlgaeO2cell","dilutionFactorO2Cell")) # removed due to being uncharacteristic to the culture conditions
                              
local_matrix <- local_matrix[-listRemove,]
print(local_matrix)


```

## Prediction of sigma mass

A predictive modelling of the light extinction coefficient at 683 nm (sigma_683) during N starvation was investigated from the same repeated Spearman rank analysis.

### First Spearman rank analysis

The same method as developed for Pm coefficient was implemented for sigma_683

```{r, echo = include_code}

# Initialisation
lm_PhoCAssPaNS <- results_PhoCAssPaNS_df
lm_PhoCAssPaNS <- lm_PhoCAssPaNS[is.na(lm_PhoCAssPaNS$sigma683Mass) == 0,]
local_lm_PhoCAssPaNS <- lm_PhoCAssPaNS %>% select(where(is.numeric))
  lm_PhoCAssPaNS <- local_lm_PhoCAssPaNS

# Spearman rank coefficient analysis
n_col = ncol(lm_PhoCAssPaNS)

rho_spear_mat <- matrix(NA,nrow = n_col, ncol = n_col)
p_spear_mat <- matrix(NA,nrow = n_col, ncol = n_col)

for (i_row in (1:n_col)){
  for (j_col in (1:n_col)){
    name_var_x <- colnames(lm_PhoCAssPaNS)[i_row]
    name_var_y <- colnames(lm_PhoCAssPaNS)[j_col]
    local_test <- try(cor.test(x = as.double(lm_PhoCAssPaNS[,i_row]),
                           y = as.double(lm_PhoCAssPaNS[,j_col]),
                           method = "spearman"))
    if (class(local_test) == "try-error"){
      rho_spear_mat[i_row,j_col] <- NA
      p_spear_mat[i_row,j_col] <- NA
    }else{
      rho_local <- local_test$estimate
      p_local <- local_test$p.value
      rho_spear_mat[i_row,j_col] <- rho_local
      p_spear_mat[i_row,j_col] <- p_local
    }
  }
}
colnames(rho_spear_mat) <- colnames(lm_PhoCAssPaNS)
rownames(rho_spear_mat) <- colnames(lm_PhoCAssPaNS)


# Data recuperation
index <- which(colnames(rho_spear_mat) == "sigma683Mass") # Finding the column number for sigma683Mass
sigma683Mass_rho <- rho_spear_mat[index,]
sigma683Mass_p <- p_spear_mat[index,]

colnames_vector <- colnames(lm_PhoCAssPaNS)

colnames_vector_pOrder <- colnames_vector[order(sigma683Mass_p)]

sigma683Mass_rho_analysis <- matrix(c(sigma683Mass_rho[order(sigma683Mass_p)],colnames_vector_pOrder),ncol = 2)
sigma683Mass_p_analysis <- matrix(c(sigma683Mass_p[order(sigma683Mass_p)],colnames_vector_pOrder),ncol = 2)

local_matrix <- matrix(c(sigma683Mass_rho_analysis,sigma683Mass_p_analysis),ncol = 4)
print(local_matrix)
```

#### First parametric model

Spearman rank analysis evidenced that the protein quota was the best predictor. A relationship between both variable is now investigated.

```{r, fig.width=6.5,fig.height=4.5}
# Initial plot analysis

ggplot(data = results_PhoCAssPaNS_df,
       aes(x = totalProtein , y = sigma683Mass, color = lightClass, shape = concentrationClass)) +
  geom_point(size = 3,stroke = 1.25) +
  scale_shape_manual(values = c(21,23,24)) +
  labs(x = "N-quota (gN/g DW)",
       y = expression(bold(atop("Mass specific extinction coefficient at 683nm", paste("(m"^"-2",".g DW"^"-1",")"))))) +
  theme_paul + 
  scale_color_manual(values = c(my_color_fill[1],my_color_fill[2],my_color_fill[3])) +
  scale_fill_manual(values = c(my_color_fill[1],my_color_fill[2],my_color_fill[3]))

## A Monod-type of relationship is evidenced by the plot, and a fit of Monod equation are therefore aimed at being determined.

# Determination of Monod-like coefficient
## A local data frame is created to perform the regression. The variables are from transformed to enable to determine the parameters from linear regression.
lm_sigma683_df <- data.frame(x = results_PhoCAssPaNS_df$sigma683Mass/results_PhoCAssPaNS_df$totalProtein, y = results_PhoCAssPaNS_df$sigma683Mass)

lm_sigma683 <- lm(y ~ x , data = lm_sigma683_df)
a <- summary(lm_sigma683)
sigma683Mass_max <- a$coefficients[1,1]
sigma683Mass_max_sd <- a$coefficients[1,2]
K_sigma683Mass <- -a$coefficients[2,1]
K_sigma683Mass_sd <- a$coefficients[2,2]


# Plot of the results
## A plot of the experimental superposed with the model determined is created
mock_TP <- seq(0,1.0,0.01)
mock_fit <- data.frame(x = mock_TP,y = sigma683Mass_max*mock_TP/(K_sigma683Mass+mock_TP))

ggplot(data = results_PhoCAssPaNS_df,
       aes(x = totalProtein , y = sigma683Mass)) +
  geom_errorbar(aes(ymin = sigma683Mass*(1 - sigma_rel_error),
                    ymax = sigma683Mass*(1 + sigma_rel_error),
                    width = 0.05)) +
  geom_point(aes(color = lightClass, shape = concentrationClass), size = 3,stroke = 1.25) +
  geom_line(data = mock_fit, aes(x = x, y = y), color = "black",size = 1, linetype = "dashed") +
  scale_shape_manual(values = c(21,23,24)) +
  labs(x = expression(bold(paste("Proteint quota (g Protein.(g DW)"^"-1",")"))),
       y = expression(bold(atop("Mass specific extinction coefficient",
                                paste("at 683nm (m"^"2",".g DW"^"-1",")"))))) +
  ylim(c(0,1)) +
  xlim(c(0,0.80)) +
  theme_paul + 
  scale_color_manual(values = c(my_color_fill[1],my_color_fill[2],my_color_fill[3])) +
  scale_fill_manual(values = c(my_color_fill[1],my_color_fill[2],my_color_fill[3]))


# Determination of the R squared of the regression
predicted_sigma683Mass <- sigma683Mass_max*
  results_PhoCAssPaNS_df$totalProtein/(K_sigma683Mass+results_PhoCAssPaNS_df$totalProtein)

SSR <- sum((predicted_sigma683Mass - results_PhoCAssPaNS_df$sigma683Mass)^2,na.rm = TRUE)
TSS <- sum((results_PhoCAssPaNS_df$sigma683Mass - mean(results_PhoCAssPaNS_df$sigma683Mass,na.rm = TRUE))^2,na.rm = TRUE)
R2 <- 1-SSR/TSS
R2
sum(is.na(results_PhoCAssPaNS_df$sigma683Mass) == 0)

```

### Spearman rank analysis of the first residuals

The residuals from the previous fit are now analysed in a repeated Spearman rank analysis

```{r, echo = include_code}

# Residuals determination
predicted_sigma_local <- 
  sigma683Mass_max*results_PhoCAssPaNS_df$totalProtein/(K_sigma683Mass+results_PhoCAssPaNS_df$totalProtein)
residuals_sigma683 <- results_PhoCAssPaNS_df$sigma683Mass - predicted_sigma_local
## Appending the residuals to the global data frame
results_PhoCAssPaNS_df$residualsSigma683 <- residuals_sigma683

# Spearman rank coefficient analysis

lm_PhoCAssPaNS <- results_PhoCAssPaNS_df
lm_PhoCAssPaNS <- lm_PhoCAssPaNS[is.na(lm_PhoCAssPaNS$residualsSigma683) == 0,]
local_lm_PhoCAssPaNS <- lm_PhoCAssPaNS %>% select(where(is.numeric))
lm_PhoCAssPaNS <- local_lm_PhoCAssPaNS

n_col = ncol(lm_PhoCAssPaNS)
rho_spear_mat <- matrix(NA,nrow = n_col, ncol = n_col)
p_spear_mat <- matrix(NA,nrow = n_col, ncol = n_col)

for (i_row in (1:n_col)){
  for (j_col in (1:n_col)){
    name_var_x <- colnames(lm_PhoCAssPaNS)[i_row]
    name_var_y <- colnames(lm_PhoCAssPaNS)[j_col]
    local_test <- try(cor.test(x = as.double(lm_PhoCAssPaNS[,i_row]),
                           y = as.double(lm_PhoCAssPaNS[,j_col]),
                           method = "spearman"))
    if (class(local_test) == "try-error"){
      rho_spear_mat[i_row,j_col] <- NA
      p_spear_mat[i_row,j_col] <- NA
    }else{
      rho_local <- local_test$estimate
      p_local <- local_test$p.value
      rho_spear_mat[i_row,j_col] <- rho_local
      p_spear_mat[i_row,j_col] <- p_local
    }
  }
}
colnames(rho_spear_mat) <- colnames(lm_PhoCAssPaNS)
rownames(rho_spear_mat) <- colnames(lm_PhoCAssPaNS)

index <- which(colnames(rho_spear_mat) == "residualsSigma683") # Finding the column number for sigma683Mass
residualsSigma683_rho <- rho_spear_mat[index,]
residualsSigma683_p <- p_spear_mat[index,]

colnames_vector <- colnames(lm_PhoCAssPaNS)
colnames_vector_pOrder <- colnames_vector[order(residualsSigma683_p)]

sigma683Mass_rho_analysis <- matrix(c(residualsSigma683_rho[order(residualsSigma683_p)],colnames_vector_pOrder),ncol = 2)
sigma683Mass_p_analysis <- matrix(c(residualsSigma683_p[order(residualsSigma683_p)],colnames_vector_pOrder),ncol = 2)

local_matrix <- matrix(c(sigma683Mass_rho_analysis,sigma683Mass_p_analysis),ncol = 4)
local_matrix <- local_matrix[,1:3]
print(local_matrix)


local_matrix <- local_matrix[as.numeric(local_matrix[,3]) < 0.01,]

listRemove <- 
  which(local_matrix[,2] %in% c("residualsSigma683","sigma683Mass","sigma880Mass", # Removed due to being evidently correlated to Pm
                              "tnSpecific","tnCellSpecific","carbonFixedProteinsExp","carbonFixedLipidsExp", #Removed due to being redundant 
                              "predicted_q_P","predicted_cnRatio","predicted_Pm","predicted_sigma683Mass","predictedSigma683Mass","predicted_q_P_cell","predicted_q_L","predicted_q_L_cell","carbonFixedNetTheo","functionalCarbonFixedGrossTheoMax", # Removed due to being predicted instead of measured data
                              "functionalCarbonFixedGrossTheo_rel_error","specificCarbonFunctionalFixedGrossTheo_rel_error","functionalPool_abs_error","specificCarbonRespirationLoss_abs_error","carbonFunctional_rel_error","specificCarbonFunctional_rel_error","Resp1Error","Resp2Error","totalFame_rel_error","totalFAMECell_rel_error","carbonFixedLipidsExp_rel_error","lambdaPhotorespRelError","lambdaDarkRelError","PmMassMax","PmMassMin","specificCarbonRespirationLoss_abs_error","functionalPool_abs_error","carbonFunctional_rel_error", # removed due to being an error estimate
                              "OD880O2Cell","OD683O2Cell","mAlgaeO2cell","PO21","PO22","sampledVolume","nAlgaeO2cell","dilutionFactorO2Cell")) # removed due to being uncharacteristic to the culture conditions
                              
local_matrix <- local_matrix[-listRemove,]
print(local_matrix)

```

#### Second parametric model

Previous Spearman rank analysis evidenced that the total light received was the most significant correlated variables (not stucturally correlated to sigma_683), followed by respiration rate following illumination, followed by the carbon fixed as carbohydrate concentration in the reactor (excluding relative errors for some variables). For the reasons developed in the manuscript, carbohydrate global concentration in the reactor was retained as a potential refinement of the prediction of sigma_683. The residuals from previous fit was thus studied in light of carbohydrate global concentration.

```{r, fig.width=7,fig.height=5}

local_lm_df <- data.frame(globalCHO =
                         results_PhoCAssPaNS_df$totalSugars*results_PhoCAssPaNS_df$dryWeight,
                       residualsSigma683 = results_PhoCAssPaNS_df$residualsSigma683)

a <- lm(residualsSigma683 ~ globalCHO, local_lm_df)
a$coefficients
ggplot(data = results_PhoCAssPaNS_df,
       aes(x = totalSugars*dryWeight ,
           y = residualsSigma683)) +
  geom_point(aes(color = lightClass, shape = concentrationClass), size = 3,stroke = 1.25) +
  geom_abline(slope = a$coefficients[2],
              intercept = a$coefficients[1],
              color = "black",size = 1, linetype = "dashed") +
  scale_shape_manual(values = c(21,23,24)) +
  labs(x = expression(bold(atop("Carbohydrate global concentration",
                                paste("(g CHO.(L)"^"-1",")")))),
       y = expression(bold(atop("Residuals of mass specific extinction",
                                paste("coefficient at 683nm (m"^"2",".g DW"^"-1",")"))))) +
  theme_paul + 
  scale_color_manual(values = c(my_color_fill[1],my_color_fill[2],my_color_fill[3])) +
  scale_fill_manual(values = c(my_color_fill[1],my_color_fill[2],my_color_fill[3]))



```

#### Summary

Based on all the analysis, we develop the following model sigma683Mass \~ sigmaMax*totalProtein/(Kp+totalProtein) - lambda_CHO*globalCHO Where - totalProtein is the protein quota (massic) - globalCHO is the total CHO concentration in the reactor - sigmaMax, lambda_CHO, Kp are fitting parameters

```{r, echo = include_code}


nls_sigma683Mass <- nls(sigma683Mass ~ a*totalProtein/(c+totalProtein) -
                          b*totalSugars*dryWeight,
                        data = results_PhoCAssPaNS_df,
                        start = list(a = 0.86, b = 0.10, c = 0.20 ),
                        lower = c(0,0,0))


a <- summary(nls_sigma683Mass)  


sigma683Mass_max <- a$coefficients[1,1]
sigma683Mass_max_sd <- a$coefficients[1,2]
lambda_CHO <-  a$coefficients[2,1]
lambda_CHO_sd <-  a$coefficients[2,2]
K_p <- a$coefficients[3,1]
K_p_sd <- a$coefficients[3,2]

predicted_sigma683Mass <- sigma683Mass_max*
  results_PhoCAssPaNS_df$totalProtein/(K_p+results_PhoCAssPaNS_df$totalProtein) - 
  lambda_CHO*results_PhoCAssPaNS_df$dryWeight*results_PhoCAssPaNS_df$totalSugars
  
results_PhoCAssPaNS_df$predictedSigma683Mass <- predicted_sigma683Mass

ggplot(data = results_PhoCAssPaNS_df,
       aes(x = predictedSigma683Mass , y = sigma683Mass, color = lightClass, shape = concentrationClass)) +
  geom_point(size = 3,stroke = 1.25) +
  geom_errorbar(aes(ymin = sigma683Mass*(1 - sigma_rel_error),
                    ymax = sigma683Mass*(1 + sigma_rel_error)),
                width = 0.05) +
  geom_abline(slope = 1, intercept = 0, color = "black",size = 1, linetype = "dashed") +
  scale_shape_manual(values = c(21,23,24)) +
  labs(x = expression(bold(atop("Predicted specific extinction", paste("coefficient at 683nm (m"^"2",".g DW"^"-1",")")))),
       y = expression(bold(atop("Measured specific extinction", paste("coefficient at 683nm (m"^"2",".g DW"^"-1",")"))))) +
  ylim(c(0,0.9)) +
  xlim(c(0,0.9)) +
  theme_paul + 
  scale_color_manual(values = c(my_color_fill[1],my_color_fill[2],my_color_fill[3])) 



SSR <- sum((results_PhoCAssPaNS_df$predictedSigma683Mass - results_PhoCAssPaNS_df$sigma683Mass)^2,na.rm = TRUE)
TSS <- sum((results_PhoCAssPaNS_df$sigma683Mass - mean(results_PhoCAssPaNS_df$sigma683Mass,na.rm = TRUE))^2,na.rm = TRUE)
R2 <- 1-SSR/TSS
R2
sum(is.na(results_PhoCAssPaNS_df$sigma683Mass) == 0)

```

### Spearman rank analysis of the second residuals

```{r, echo = include_code, fig.height=5,fig.width=6.5}
# Determination of residuals
residuals_sigma683 <- results_PhoCAssPaNS_df$sigma683Mass - results_PhoCAssPaNS_df$predictedSigma683Mass
results_PhoCAssPaNS_df$residualsSigma683 <- residuals_sigma683

# Spearman rank coefficient analysis

lm_PhoCAssPaNS <- results_PhoCAssPaNS_df
 
lm_PhoCAssPaNS <- lm_PhoCAssPaNS[is.na(lm_PhoCAssPaNS$residualsSigma683) == 0,]
local_lm_PhoCAssPaNS <- lm_PhoCAssPaNS %>% select(where(is.numeric))
lm_PhoCAssPaNS <- local_lm_PhoCAssPaNS

n_col = ncol(lm_PhoCAssPaNS)
rho_spear_mat <- matrix(NA,nrow = n_col, ncol = n_col)
p_spear_mat <- matrix(NA,nrow = n_col, ncol = n_col)
for (i_row in (1:n_col)){
  for (j_col in (1:n_col)){
    name_var_x <- colnames(lm_PhoCAssPaNS)[i_row]
    name_var_y <- colnames(lm_PhoCAssPaNS)[j_col]
    local_test <- try(cor.test(x = as.double(lm_PhoCAssPaNS[,i_row]),
                           y = as.double(lm_PhoCAssPaNS[,j_col]),
                           method = "spearman"))
    if (class(local_test) == "try-error"){
      rho_spear_mat[i_row,j_col] <- NA
      p_spear_mat[i_row,j_col] <- NA
    }else{
      rho_local <- local_test$estimate
      p_local <- local_test$p.value
      rho_spear_mat[i_row,j_col] <- rho_local
      p_spear_mat[i_row,j_col] <- p_local
    }
  }
}
colnames(rho_spear_mat) <- colnames(lm_PhoCAssPaNS)
rownames(rho_spear_mat) <- colnames(lm_PhoCAssPaNS)

index <- which(colnames(rho_spear_mat) == "residualsSigma683") # Finding the column number for sigma683Mass

residualsSigma683_rho <- rho_spear_mat[index,]
residualsSigma683_p <- p_spear_mat[index,]
colnames_vector <- colnames(lm_PhoCAssPaNS)

colnames_vector_pOrder <- colnames_vector[order(residualsSigma683_p)]

sigma683Mass_rho_analysis <- matrix(c(residualsSigma683_rho[order(residualsSigma683_p)],colnames_vector_pOrder),ncol = 2)
sigma683Mass_p_analysis <- matrix(c(residualsSigma683_p[order(residualsSigma683_p)],colnames_vector_pOrder),ncol = 2)

local_matrix <- matrix(c(sigma683Mass_rho_analysis,sigma683Mass_p_analysis),ncol = 4)
local_matrix <- local_matrix[,1:3]

local_matrix <- local_matrix[as.numeric(local_matrix[,3]) < 0.01,]

listRemove <- 
  which(local_matrix[,2] %in% c("residualsSigma683","sigma683Mass","sigma880Mass", # Removed due to being evidently correlated to Pm
                              "tnSpecific","tnCellSpecific","carbonFixedProteinsExp","carbonFixedLipidsExp", #Removed due to being redundant 
                              "predicted_q_P","predicted_cnRatio","predicted_Pm","predicted_sigma683Mass","predictedSigma683Mass","predicted_q_P_cell","predicted_q_L","predicted_q_L_cell","carbonFixedNetTheo","functionalCarbonFixedGrossTheoMax", # Removed due to being predicted instead of measured data
                              "functionalCarbonFixedGrossTheo_rel_error","specificCarbonFunctionalFixedGrossTheo_rel_error","functionalPool_abs_error","specificCarbonRespirationLoss_abs_error","carbonFunctional_rel_error","specificCarbonFunctional_rel_error","Resp1Error","Resp2Error","totalFame_rel_error","totalFAMECell_rel_error","carbonFixedLipidsExp_rel_error","lambdaPhotorespRelError","lambdaDarkRelError","PmMassMax","PmMassMin","specificCarbonRespirationLoss_abs_error","functionalPool_abs_error","carbonFunctional_rel_error", # removed due to being an error estimate
                              "OD880O2Cell","OD683O2Cell","mAlgaeO2cell","PO21","PO22","sampledVolume","nAlgaeO2cell","dilutionFactorO2Cell")) # removed due to being uncharacteristic to the culture conditions
                              
local_matrix <- local_matrix[-listRemove,]
print(local_matrix)

```

```{r, echo = include_code, fig.height=5,fig.width=6.5}

ggplot(data = results_PhoCAssPaNS_df,
       aes(x = totalSugarsCell ,
           y = residualsSigma683)) +
  geom_point(aes(color = lightClass, shape = concentrationClass), size = 3,stroke = 1.25) +
  scale_shape_manual(values = c(21,23,24)) +
  labs(x = expression(bold(atop("Carbohydrate cell quota",
                                paste("(g CHO.(cell)"^"-1",")")))),
       y = expression(bold(atop("Residuals of mass specific extinction",
                                paste("coefficient at 683nm (m"^"2",".g DW"^"-1",")"))))) +
  theme_paul + 
  scale_color_manual(values = c(my_color_fill[1],my_color_fill[2],my_color_fill[3])) +
  scale_fill_manual(values = c(my_color_fill[1],my_color_fill[2],my_color_fill[3]))

lm(residualsSigma683 ~ totalSugarsCell, results_PhoCAssPaNS_df)

```

```{r, fig.width=7,fig.height=5}

local_lm_df <- data.frame(totalSugarsCell = 
                            results_PhoCAssPaNS_df$totalSugarsCell,
                       residualsSigma683 = results_PhoCAssPaNS_df$residualsSigma683)

a <- lm(residualsSigma683 ~ totalSugarsCell, local_lm_df)
a$coefficients
ggplot(data = results_PhoCAssPaNS_df,
       aes(x = totalSugarsCell ,
           y = residualsSigma683)) +
  geom_point(aes(color = lightClass, shape = concentrationClass), size = 3,stroke = 1.25) +
  geom_abline(slope = a$coefficients[2],
              intercept = a$coefficients[1],
              color = "black",size = 1, linetype = "dashed") +
  scale_shape_manual(values = c(21,23,24)) +
  labs(x = expression(bold(atop("Carbohydrate cell quota",
                                paste("(g CHO.cell"^"-1",")")))),
       y = expression(bold(atop("Residuals of mass specific extinction",
                                paste("coefficient at 683nm (m"^"2",".g DW"^"-1",")"))))) +
  theme_paul + 
  scale_color_manual(values = c(my_color_fill[1],my_color_fill[2],my_color_fill[3])) +
  scale_fill_manual(values = c(my_color_fill[1],my_color_fill[2],my_color_fill[3]))



```

### Re-evaluation of the strategy

The fit the sugar cell appear to "normalize" a significant outlier, but is redundant witht the introduction of carbohydrate global concentration. A new fit is therefore attempted with the following model: sigma683Mass \~ sigmaMax*totalProtein/(Kp+totalProtein) - lambda_CHO*totalSugarsCell Where - totalProtein is the protein quota (massic) - totalSugarsCell is the Carbohydrates cell quota - sigmaMax, lambda_CHO, Kp are fitting parameters

```{r, echo = include_code, fig.height=5,fig.width=7}


nls_sigma683Mass <- nls(sigma683Mass ~ a*totalProtein/(c+totalProtein) -
                          b*totalSugarsCell,
                        data = results_PhoCAssPaNS_df,
                        start = list(a = 0.86, b = 1.5*10^10, c = 0.20 ),
                        lower = c(0,0,0))


a <- summary(nls_sigma683Mass)  


sigma683Mass_max <- a$coefficients[1,1]
sigma683Mass_max_sd <- a$coefficients[1,2]
lambda_CHO <-  a$coefficients[2,1]
lambda_CHO_sd <-  a$coefficients[2,2]
K_p <- a$coefficients[3,1]
K_p_sd <- a$coefficients[3,2]

predicted_sigma683Mass <- sigma683Mass_max*
  results_PhoCAssPaNS_df$totalProtein/(K_p+results_PhoCAssPaNS_df$totalProtein) - 
  lambda_CHO*results_PhoCAssPaNS_df$totalSugarsCell
  
results_PhoCAssPaNS_df$predictedSigma683Mass <- predicted_sigma683Mass

ggplot(data = results_PhoCAssPaNS_df,
       aes(x = predictedSigma683Mass , y = sigma683Mass, color = lightClass, shape = concentrationClass)) +
  geom_point(size = 3,stroke = 1.25) +
  geom_errorbar(aes(ymin = sigma683Mass*(1 - sigma_rel_error),
                    ymax = sigma683Mass*(1 + sigma_rel_error)),
                width = 0.05) +
  geom_abline(slope = 1, intercept = 0, color = "black",size = 1, linetype = "dashed") +
  scale_shape_manual(values = c(21,23,24)) +
  labs(x = expression(bold(atop("Predicted specific extinction", paste("coefficient at 683nm (m"^"2",".g DW"^"-1",")")))),
       y = expression(bold(atop("Measured specific extinction", paste("coefficient at 683nm (m"^"2",".g DW"^"-1",")"))))) +
  ylim(c(0,0.9)) +
  xlim(c(0,0.9)) +
  theme_paul + 
  scale_color_manual(values = c(my_color_fill[1],my_color_fill[2],my_color_fill[3]))



SSR <- sum((results_PhoCAssPaNS_df$predictedSigma683Mass - results_PhoCAssPaNS_df$sigma683Mass)^2,na.rm = TRUE)
TSS <- sum((results_PhoCAssPaNS_df$sigma683Mass - mean(results_PhoCAssPaNS_df$sigma683Mass,na.rm = TRUE))^2,na.rm = TRUE)
R2 <- 1-SSR/TSS
R2
sum(is.na(results_PhoCAssPaNS_df$sigma683Mass) == 0)

```

### Spearman rank analysis of the first residuals (2nd strategy)

```{r, echo = include_code, fig.height=5,fig.width=7}
residuals_sigma683 <- results_PhoCAssPaNS_df$sigma683Mass - results_PhoCAssPaNS_df$predictedSigma683Mass
results_PhoCAssPaNS_df$residualsSigma683 <- residuals_sigma683

# Spearman rank coefficient analysis

lm_PhoCAssPaNS <- results_PhoCAssPaNS_df


local_lm_PhoCAssPaNS <- lm_PhoCAssPaNS %>% select(where(is.numeric))
lm_PhoCAssPaNS <- local_lm_PhoCAssPaNS

n_col = ncol(lm_PhoCAssPaNS)
rho_spear_mat <- matrix(NA,nrow = n_col, ncol = n_col)
p_spear_mat <- matrix(NA,nrow = n_col, ncol = n_col)
for (i_row in (1:n_col)){
  for (j_col in (1:n_col)){
    name_var_x <- colnames(lm_PhoCAssPaNS)[i_row]
    name_var_y <- colnames(lm_PhoCAssPaNS)[j_col]
    local_test <- try(cor.test(x = as.double(lm_PhoCAssPaNS[,i_row]),
                           y = as.double(lm_PhoCAssPaNS[,j_col]),
                           method = "spearman"))
    if (class(local_test) == "try-error"){
      rho_spear_mat[i_row,j_col] <- NA
      p_spear_mat[i_row,j_col] <- NA
    }else{
      rho_local <- local_test$estimate
      p_local <- local_test$p.value
      rho_spear_mat[i_row,j_col] <- rho_local
      p_spear_mat[i_row,j_col] <- p_local
    }
  }
}
colnames(rho_spear_mat) <- colnames(lm_PhoCAssPaNS)
rownames(rho_spear_mat) <- colnames(lm_PhoCAssPaNS)
index <- which(colnames(rho_spear_mat) == "residualsSigma683") # Finding the column number for sigma683Mass
residualsSigma683_rho <- rho_spear_mat[index,]
residualsSigma683_p <- p_spear_mat[index,]

colnames_vector <- colnames(lm_PhoCAssPaNS)
colnames_vector_pOrder <- colnames_vector[order(residualsSigma683_p)]

sigma683Mass_rho_analysis <- matrix(c(residualsSigma683_rho[order(residualsSigma683_p)],colnames_vector_pOrder),ncol = 2)
sigma683Mass_p_analysis <- matrix(c(residualsSigma683_p[order(residualsSigma683_p)],colnames_vector_pOrder),ncol = 2)

local_matrix <- matrix(c(sigma683Mass_rho_analysis,sigma683Mass_p_analysis),ncol = 4)
local_matrix <- local_matrix[,1:3]

local_matrix <- local_matrix[as.numeric(local_matrix[,3]) < 0.01,]

listRemove <- 
  which(local_matrix[,2] %in% c("residualsSigma683","sigma683Mass","sigma880Mass", # Removed due to being evidently correlated to Pm
                              "tnSpecific","tnCellSpecific","carbonFixedProteinsExp","carbonFixedLipidsExp", #Removed due to being redundant 
                              "predicted_q_P","predicted_cnRatio","predicted_Pm","predicted_sigma683Mass","predictedSigma683Mass","predicted_q_P_cell","predicted_q_L","predicted_q_L_cell","carbonFixedNetTheo","functionalCarbonFixedGrossTheoMax","functionalCarbonFixedGrossTheo","functionalCarbonFixedGrossTheoMin", # Removed due to being predicted instead of measured data
                              "functionalCarbonFixedGrossTheo_rel_error","specificCarbonFunctionalFixedGrossTheo_rel_error","functionalPool_abs_error","specificCarbonRespirationLoss_abs_error","carbonFunctional_rel_error","specificCarbonFunctional_rel_error","Resp1Error","Resp2Error","totalFame_rel_error","totalFAMECell_rel_error","carbonFixedLipidsExp_rel_error","lambdaPhotorespRelError","lambdaDarkRelError","PmMassMax","PmMassMin","specificCarbonRespirationLoss_abs_error","functionalPool_abs_error","carbonFunctional_rel_error", # removed due to being an error estimate
                              "OD880O2Cell","OD683O2Cell","mAlgaeO2cell","PO21","PO22","sampledVolume","nAlgaeO2cell","dilutionFactorO2Cell")) # removed due to being uncharacteristic to the culture conditions
                              
local_matrix <- local_matrix[-listRemove,]
print(local_matrix)
```

#### Plot analysis of the last significant relationship of the residuals

The following variables are still evidenced significantly correlated to the current model residuals (removing least relevant variables): - carbonFunctional (p = 0.0004244) - dryWeight (p = 0.0005400) - carbonFixedCHOExp (p = 0.0005889) - cellCount (p = 0.0006839)

```{r, echo = include_code, fig.height=5,fig.width=6.5}

ggplot(data = results_PhoCAssPaNS_df,
       aes(x = carbonFunctional ,
           y = residualsSigma683)) +
  geom_point(aes(color = lightClass, shape = concentrationClass), size = 3,stroke = 1.25) +
  scale_shape_manual(values = c(21,23,24)) +
  labs(y = expression(bold(atop("Residuals of mass specific extinction",
                                paste("coefficient at 683nm (m"^"2",".g DW"^"-1",")"))))) +
  theme_paul + 
  scale_color_manual(values = c(my_color_fill[1],my_color_fill[2],my_color_fill[3])) +
  scale_fill_manual(values = c(my_color_fill[1],my_color_fill[2],my_color_fill[3]))

ggplot(data = results_PhoCAssPaNS_df,
       aes(x = dryWeight ,
           y = residualsSigma683)) +
  geom_point(aes(color = lightClass, shape = concentrationClass), size = 3,stroke = 1.25) +
  scale_shape_manual(values = c(21,23,24)) +
  labs(y = expression(bold(atop("Residuals of mass specific extinction",
                                paste("coefficient at 683nm (m"^"2",".g DW"^"-1",")"))))) +
  theme_paul + 
  scale_color_manual(values = c(my_color_fill[1],my_color_fill[2],my_color_fill[3])) +
  scale_fill_manual(values = c(my_color_fill[1],my_color_fill[2],my_color_fill[3]))

ggplot(data = results_PhoCAssPaNS_df,
       aes(x = carbonFixedCHOExp ,
           y = residualsSigma683)) +
  geom_point(aes(color = lightClass, shape = concentrationClass), size = 3,stroke = 1.25) +
  scale_shape_manual(values = c(21,23,24)) +
  labs(y = expression(bold(atop("Residuals of mass specific extinction",
                                paste("coefficient at 683nm (m"^"2",".g DW"^"-1",")"))))) +
  theme_paul + 
  scale_color_manual(values = c(my_color_fill[1],my_color_fill[2],my_color_fill[3])) +
  scale_fill_manual(values = c(my_color_fill[1],my_color_fill[2],my_color_fill[3]))

ggplot(data = results_PhoCAssPaNS_df,
       aes(x = cellCount ,
           y = residualsSigma683)) +
  geom_point(aes(color = lightClass, shape = concentrationClass), size = 3,stroke = 1.25) +
  scale_shape_manual(values = c(21,23,24)) +
  labs(y = expression(bold(atop("Residuals of mass specific extinction",
                                paste("coefficient at 683nm (m"^"2",".g DW"^"-1",")"))))) +
  theme_paul + 
  scale_color_manual(values = c(my_color_fill[1],my_color_fill[2],my_color_fill[3])) +
  scale_fill_manual(values = c(my_color_fill[1],my_color_fill[2],my_color_fill[3]))

```

None of the relationship tested above were deemed mathematically significant enough to be implemented in the sigma_683 predictive model.

### Final summary

Based on all the analysis, we develop the following model sigma683Mass \~ sigmaMax*totalProtein/(Kp+totalProtein) - lambda_CHO*totalSugarsCell Where - totalProtein is the protein quota (massic) - totalSugarsCell is the Carbohydrates cell quota - sigmaMax, lambda_CHO, Kp are fitting parameters

```{r, echo = include_code,fig.height=5,fig.width=7}

nls_sigma683Mass <- nls(sigma683Mass ~ a*totalProtein/(c+totalProtein) -
                          b*totalSugarsCell,
                        data = results_PhoCAssPaNS_df,
                        start = list(a = 0.86, b = 1.5*10^10, c = 0.20 ),
                        lower = c(0,0,0))

a <- summary(nls_sigma683Mass)  


sigma683Mass_max <- a$coefficients[1,1]
sigma683Mass_max_sd <- a$coefficients[1,2]
K_p <- a$coefficients[3,1]
K_p_sd <- a$coefficients[3,2]
lambda_sugars <- a$coefficients[2,1]
lambda_sugars_sd <- a$coefficients[2,2]

sigma683Mass_max
sigma683Mass_max_sd
K_p
K_p_sd
lambda_sugars
lambda_sugars_sd
format(lambda_sugars,scientific = TRUE)
format(lambda_sugars_sd,scientific = TRUE)

predicted_sigma683Mass <- sigma683Mass_max*
  results_PhoCAssPaNS_df$totalProtein/(K_p+results_PhoCAssPaNS_df$totalProtein) -
  lambda_sugars*results_PhoCAssPaNS_df$totalSugarsCell
  
results_PhoCAssPaNS_df$predictedSigma683Mass <- predicted_sigma683Mass

ggplot(data = results_PhoCAssPaNS_df,
       aes(x = predictedSigma683Mass , y = sigma683Mass, color = lightClass, shape = concentrationClass)) +
  geom_point(size = 3,stroke = 1.25) +
  geom_errorbar(aes(ymin = sigma683Mass*(1 - sigma_rel_error),
                    ymax = sigma683Mass*(1 + sigma_rel_error)),
                width = 0.05) +
  geom_abline(slope = 1, intercept = 0, color = "black",size = 1, linetype = "dashed") +
  scale_shape_manual(values = c(21,23,24)) +
  labs(x = expression(bold(atop("Predicted specific extinction", paste("coefficient at 683nm (m"^"2",".g DW"^"-1",")")))),
       y = expression(bold(atop("Measured specific extinction", paste("coefficient at 683nm (m"^"2",".g DW"^"-1",")"))))) +
  ylim(c(0,0.9)) +
  xlim(c(0,0.9)) +
  theme_paul + 
  scale_color_manual(values = c(my_color_fill[1],my_color_fill[2],my_color_fill[3])) 



SSR <- sum((results_PhoCAssPaNS_df$predictedSigma683Mass - results_PhoCAssPaNS_df$sigma683Mass)^2,na.rm = TRUE)
TSS <- sum((results_PhoCAssPaNS_df$sigma683Mass - mean(results_PhoCAssPaNS_df$sigma683Mass,na.rm = TRUE))^2,na.rm = TRUE)
R2 <- 1-SSR/TSS
print(a)
R2
sum(is.na(results_PhoCAssPaNS_df$sigma683Mass) == 0)

```

## Carbon allocation model

### Maximum CHO cellular quota

The maximum cellular quota of carbohydrate is determined as the average value of all the data excluding the days 1 and 2 (when dynamic accumulation was reported).

```{r, ech = TRUE}

# Creation of vectors of the max carbohydrate quota and error associated
q_CHO_max_reactor <- rep(NA,9)

# Loop of calculation
for (i_concentration in (1:3)){
  for (j_light in (1:3)){
     # Data of a specific reactor is recovered
    data_reduced <- subset(results_PhoCAssPaNS_df, concentrationClass == concentrationClassList[i_concentration])
    data_reduced <- subset(data_reduced, data_reduced$lightClass == lightClassList[j_light])
    
    # Carbohydarte cell quota data 
    local_CHOCell <- data_reduced$totalSugarsCell
    ## Calculation of the averaged value excluding day 1 and 2 is isolated
    local_q_CHO_max <- mean(local_CHOCell[data_reduced$day %in% c(0.75,1.75) == 0],na.rm = TRUE)
    
    # Storing the data in the local vectors
    q_CHO_max_reactor[3*(i_concentration-1)+j_light] <- local_q_CHO_max
  }
}
# Storing the data in the reactor specific data frame
reactorPhoCAssPaNS_df$qCHOMax <- q_CHO_max_reactor

# Calculation of the global average and associated error
q_CHO_max_global <- mean(reactorPhoCAssPaNS_df$qCHOMax)
SE_qCHOMax <- sd(reactorPhoCAssPaNS_df$qCHOMax)/sqrt(9)
# Printing the data for reporting
q_CHO_max_global
SE_qCHOMax


```

Plot of the results:

```{r ,fig.height=5,fig.width=7}
ggplot(data = reactorPhoCAssPaNS_df,aes(x = lightDensity , y = qCHOMax)) +
  geom_point(size = 3,stroke = 1.25) +
  geom_errorbar(aes(ymin = qCHOMax - 1.96*SE_qCHOMax, ymax = qCHOMax + 1.96*SE_qCHOMax),
                stroke = 1.25, width = 1) +
  geom_errorbarh(aes(xmin = (lightDensity -1.96*lightDensityStd),
                     xmax = (lightDensity + 1.96*lightDensityStd)),
                stroke = 1.25, width = 0.005) +
  scale_shape_manual(values = c(21,23,24),na.translate = FALSE) +
  labs(x = expression(bold(atop("Dryweight specific light density ",
                                 paste("(µmol.(g DW.s)"^"-1","])")))),
       y = expression(bold(paste(atop("Last carbohydrate cell quota", 
                                      paste("(g CHO.cell"^"-1",")")))))) +
  geom_smooth(method = "lm", formula = y ~ x , geom = "smooth") +
  theme_paul +
  scale_color_manual(values = c(my_color_fill[3],my_color_fill[1],my_color_fill[2])) 
  # scale_y_continuous(breaks = c(0,0.2,0.4,0.8))


ggplot(data = reactorPhoCAssPaNS_df,aes(x = lightDensityCell,y = qCHOMax)) +
  geom_point(size = 3,stroke = 1.25,) +
  geom_errorbar(aes(ymin = qCHOMax - 1.96*SE_qCHOMax, ymax = qCHOMax + 1.96*SE_qCHOMax),
                stroke = 1.25) +
  geom_errorbarh(aes(xmin = (lightDensityCell -1.96*lightDensityCell_std), xmax = (lightDensityCell + 1.96*lightDensityCell_std)),
                stroke = 1.25) +
  scale_shape_manual(values = c(1,2,4),na.translate = FALSE) +
  geom_smooth(method = "lm", formula = qCHOLast ~ lightDensityCell , geom = "smooth") +
  # scale_x_log10() +
  labs(x = expression(bold(atop("Cell specific light density ",
                                 paste("(µmol.(g DW.s)"^"-1","])")))),
            y = expression(bold(paste(atop("Last carbohydrate cell quota", 
                                      paste("(g CHO.cell"^"-1",")")))))) +
  theme_paul +
  scale_color_manual(values = c(my_color_fill[3],my_color_fill[1],my_color_fill[2])) 
  # scale_y_continuous(breaks = c(0,0.2,0.4,0.8))

a <- lm(qCHOMax ~ lightDensity,
        data = reactorPhoCAssPaNS_df)

summary(a)
```

### Maximum rate of lipid production

We assume based on global observations that a maximum cellular rate of lipid productivity exists. We are therefore aiming to determine a rate of cellular lipid production P_L such that dL/dt = P_L*N(t) where N(t) is the cell concentration and L is the total lipid concentration in the reactor. Because significant uncertainty exist in our data points, the variables were first smoothed (loess method) prior to study the ratio 1/N*dL/dt. It must be noted that P_L is expected to be fleetingly reaching a maximum value but would remain below most of the experiment as lipid accumulation is limited by the photosynthetic activity of the microalgae.

```{r, echo = include_code,fig.height=5,fig.width=8}

# We define a mock vector of time on which the data smoothing will be performed
mock_day <- seq(0,16,0.1)

# A matrix is initialized which will contain the data enabling the study of P_L
mock_fit <- matrix(NA,nrow = length(mock_day)-1,ncol = 9)
## A vector is created to name the column. This will enable to name the data in the legend of the final plot.
name_col <- rep(NA,10)
name_col[1] <- 'Time'

for (i_concentration in (1:3)){
  for (j_light in (1:3)){
     # Data for a given reactor is first obtained
    data_reduced <- subset(results_PhoCAssPaNS_df, concentrationClass == concentrationClassList[i_concentration])
    data_reduced <- subset(data_reduced, data_reduced$lightClass == lightClassList[j_light])
    
    # A local data frame is created containing time, cell count, dryweight, and total lipid concentration.
    ## Generic names were given to the data frame vectors in order to conveniently change the values and explore other calculations.
    local_data <- data.frame(x = data_reduced$day,
                             yDryWeight = data_reduced$dryWeight , 
                             yTest = data_reduced$totalFAME*data_reduced$dryWeight,
                             yScale = data_reduced$cellCount*1000)
    
    # Loess regression
    ## A first loess regression is performed on the total lipid concentration
    loess_fit <- loess(yTest ~ x, data = local_data,
                             weights = c(10,5,5,1,1,1,1,1), span = 1.0)
    ## A new data vector is generated on the mock day vector
    predictFit <- predict(loess_fit,newdata = mock_day )
    ## The result of the regression is plotted to evaluate plot quality (variation of the parameters for the loess regression were considered for variations)
    plot(local_data$x,local_data$yTest, ylim = c(0,1.1*max(c(predictFit,local_data$yTest),na.rm = TRUE)))
    lines(mock_day,predictFit,lty = 1 , lwd = 2 , col = "purple")
    
    ## A second loess regression is performed on cell count in the reactor
    loess_scale <- loess(yScale ~ x, data = local_data,
                             weights = c(10,5,5,1,1,1,1,1), span = 1)
    ## A new data vector is generated on the mock day vector
    predictScale <- predict(loess_scale,newdata = mock_day )
    ## The result of the regression is plotted to evaluate plot quality (variation of the parameters for the loess regression were considered for variations)
    plot(local_data$x,local_data$yScale, ylim = c(min(c(predictScale,local_data$yScale),na.rm = TRUE),1.1*max(c(predictScale,local_data$yScale),na.rm = TRUE)))
    lines(mock_day,predictScale,lty = 1 , lwd = 2 , col = "red")
  
    # Theoretical value for the cellular lipid productivity is stored is the matrix loccaly created
    mock_fit[,3*(i_concentration-1)+j_light] <-1/predictScale[1:(length(mock_day)-1)]*diff(predictFit)/diff(mock_day)
    
    # The name of the reactor is stored in a vecotr for later use
    name_col[1 + 3*(i_concentration-1)+j_light] <- paste(concentrationClassList[i_concentration], " ; ", lightClassList[j_light] , " light")
  }
}
# The matrix of the result is transformed in a data frame for ggplot use; variable names are transferred
df_final <- data.frame(cbind(mock_day[1:(length(mock_day)-1)],mock_fit)) 
colnames(df_final) <- name_col

# Results for the analysis are plotted
ggplot(data = df_final, aes(x = Time, y = `0.1 g.L-1  ;  25%  light`,color = name_col[2])) +
  geom_line(  size = 1) +
  geom_line(aes(x = Time, y = `0.1 g.L-1  ;  50%  light`,color = name_col[3]), size = 1) +
  geom_line(aes(x = Time, y = `0.1 g.L-1  ;  100%  light` ,color = name_col[4]), size = 1) +
  geom_line(aes(x = Time, y = `0.3 g.L-1  ;  25%  light` ,color = name_col[5]), size = 1) +
  geom_line(aes(x = Time, y = `0.3 g.L-1  ;  50%  light` ,color = name_col[6]), size = 1) +
  geom_line(aes(x = Time, y = `0.3 g.L-1  ;  100%  light` ,color = name_col[7]), size = 1) +
  geom_line(aes(x = Time, y = `1.0 g.L-1  ;  25%  light` ,color = name_col[8]), size = 1) +
  geom_line(aes(x = Time, y = `1.0 g.L-1  ;  50%  light`,color = name_col[9]), size = 1) +
  geom_line(aes(x = Time, y = `1.0 g.L-1  ;  100%  light`,color = name_col[10]), size = 1) +
  labs(x = "Time (d)",
       y = expression(bold(atop(paste("Cellular lipid production rate"),paste("(g Lipids.(cell.d)"^"-1",")"))))) +
  scale_y_log10() +
  theme_paul_highColourFill 

# The final theoretical maximum rate of lipid production is now computed as the average value on days before day 2 and for reactors exhibiting significantly above basal carbohydrate quota.
# max(df_final[,-1],na.rm = TRUE)
p_L_cell_max <- mean(as.matrix(df_final[df_final[,1] < 2,c(2,3,6)]) , na.rm = TRUE)
sd(as.matrix(df_final[df_final[,1] < 2,c(2,3,6)]) , na.rm = TRUE)



```

## Cell division model

### Reactor specific Droop model

Droop model was implemented for each reactor due to being an expected model of cell division under N starvation.

```{r, echo = include_code}

# Vector for each parameter recovered from Droop model for each reactor are initialized
µ_max <- rep(NA,9)
q_min <- rep(NA,9)
µ_max_IC <- rep(NA,9)
q_min_IC <- rep(NA,9)

for (i_concentration in (1:3)){
  for (j_light in (1:3)){
    
    # Reactor specific data is retrieved
    local_results <- subset(results_PhoCAssPaNS_df, concentrationClass == concentrationClassList[i_concentration])
    local_results <- subset(local_results, results_PhoCAssPaNS_df$lightClass == lightClassList[j_light])
    
    # Droop is linearized leading to the creation of x and y vector expected to be linearly dependent if Droop is verified
    x = 1/local_results$totalProteinCellMidInterval
    y <- replace(local_results$divisionRate, which(local_results$divisionRate <= 0) , NA)
    
    # Linear model is implemented
    model_data = data.frame(x = x , y = y)
    lm_fit <- lm(formula = y ~  x, data = model_data)
    a <- summary(lm_fit)
    plot(x,y)
    abline(lm_fit,col = "red",lwd = 2)
    
    # The parammeters are saved in the associated vecotrs
    µ_max[3*(i_concentration-1)+j_light] <- lm_fit$coefficients[1]
    µ_max_IC[3*(i_concentration-1)+j_light] <- 1.96*a$coefficients[1,2]
    q_min[3*(i_concentration-1)+j_light] <- -lm_fit$coefficients[2]/lm_fit$coefficients[1]
    q_min_IC[3*(i_concentration-1)+j_light] <- 1.96*a$coefficients[2,2]
  }
}
# Droop model parameters are now appended to the reactor specific data frame
reactorPhoCAssPaNS_df$µmDroop <- µ_max
reactorPhoCAssPaNS_df$µmDroopIC <- µ_max_IC
reactorPhoCAssPaNS_df$qMinDroop <- q_min
reactorPhoCAssPaNS_df$qMinDroopIC <- q_min_IC

mean(reactorPhoCAssPaNS_df$µmDroop)
mean(reactorPhoCAssPaNS_df$qMinDroop)
```

Unstaisfying Droop but exponential pattern noticeable.

### Spearman rank analysis

```{r, echo = include_code}
# Results data frame is replicated so potential transforamtions on it can be implemented prior to generalized Spearman rank correlation analysis 
lm_PhoCAssPaNS <- results_PhoCAssPaNS_df

# Lines with an absence of PmMass data are removed to avoid errors
lm_PhoCAssPaNS <- lm_PhoCAssPaNS[is.na(lm_PhoCAssPaNS$PmMass) == 0,]

# Non numeric data are removed to prevent errors
local_lm_PhoCAssPaNS <- lm_PhoCAssPaNS %>% select(where(is.numeric))
lm_PhoCAssPaNS <- local_lm_PhoCAssPaNS


# Spearman rank analysis
## Exctracting the number of columns
n_col = ncol(lm_PhoCAssPaNS)
# Initialising the results matrix
## rho_spear_mat: matrix of Spearman rank coefficients 
rho_spear_mat <- matrix(NA,nrow = n_col, ncol = n_col)
## p_spear_mat: matix of associated p-values
p_spear_mat <- matrix(NA,nrow = n_col, ncol = n_col)

# Loop for Spearman rank analysis
## All variables are cross-tested through Spearman analysis
for (i_row in (1:n_col)){
  for (j_col in (1:n_col)){
    ## The following line aims at avoiding the calculation should an error be expected
    local_test <- try(cor.test(x = as.double(lm_PhoCAssPaNS[,i_row]),
                           y = as.double(lm_PhoCAssPaNS[,j_col]),
                           method = "spearman"))
    ## In case an error is expected, no Spearman rank analysis is performed, and a value NA is instead registered in the result matrix
    if (class(local_test) == "try-error"){
      rho_spear_mat[i_row,j_col] <- NA
      p_spear_mat[i_row,j_col] <- NA
    }else{
      # Case with no error reported: results from spearman rank analysis are collected and registered in the result matrices
      rho_local <- local_test$estimate
      p_local <- local_test$p.value
      rho_spear_mat[i_row,j_col] <- rho_local
      p_spear_mat[i_row,j_col] <- p_local
    }
  }
}
# Column names and row names are implemented to the Spearman rank matrix (names being the variables tested names)
## The names being the same for the p-value matrix, only one implementation is needed here
colnames(rho_spear_mat) <- colnames(lm_PhoCAssPaNS)
rownames(rho_spear_mat) <- colnames(lm_PhoCAssPaNS)


# Results from Spearman rank analysis for the variable PmMass are extracted, both for Spearman coeff and p-value
index <- which(colnames(rho_spear_mat) == "divisionRate") 
divisionRate_rho <- rho_spear_mat[index,]
divisionRate_p <- p_spear_mat[index,]

# We now order the variable names according to the most significant values in the sense of increasing p-values
colnames_vector <- colnames(lm_PhoCAssPaNS)
colnames_vector_pOrder <- colnames_vector[order(divisionRate_p)]

divisionRate_rho_analysis <- matrix(c(divisionRate_rho[order(divisionRate_p)],colnames_vector_pOrder),ncol = 2)
divisionRate_p_analysis <- matrix(c(divisionRate_p[order(divisionRate_p)],colnames_vector_pOrder),ncol = 2)

# Printing of the results
## A matrix of the spearman rank coefficient and p-values, ordered by increasing p-values is created
local_matrix <- matrix(c(divisionRate_rho_analysis,divisionRate_p_analysis),ncol = 4)
## the matrix is limited to p-values below 0.01
local_matrix <- local_matrix[as.numeric(local_matrix[,3]) < 0.01,]
local_matrix <- local_matrix[,1:3]
## We remove lines for parameters irrelevant to the analysis
listRemove <- 
  which(local_matrix[,2] %in% c("PmMass","PmMassMax","PmMassMin", # Removed due to being evidently correlated to Pm
                              "tnSpecific","tnCellSpecific","carbonFixedProteinsExp","carbonFixedLipidsExp", #Removed due to being redundant 
                              "predicted_q_P","predicted_cnRatio","predicted_Pm","predicted_sigma683Mass","predictedSigma683Mass","predicted_q_P_cell","predicted_q_L","predicted_q_L_cell","carbonFixedNetTheo", # Removed due to being predicted instead of measured data
                              "functionalCarbonFixedGrossTheo_rel_error","specificCarbonFunctionalFixedGrossTheo_rel_error","functionalPool_abs_error","specificCarbonRespirationLoss_abs_error","carbonFunctional_rel_error","specificCarbonFunctional_rel_error","Resp2Error","totalFame_rel_error","totalFAMECell_rel_error","carbonFixedLipidsExp_rel_error","lambdaPhotorespRelError", # removed due to being an error estimate
                              "OD880O2Cell","OD683O2Cell","mAlgaeO2cell","PO21","PO22","sampledVolume","nAlgaeO2cell","dilutionFactorO2Cell")) # removed due to being uncharacteristic to the culture conditions
                              
local_matrix <- local_matrix[-listRemove,]
print(local_matrix)


```

### Reactor specific exponential Droop model

#### Determination of model fitting parameters

Due to unstatisfying fit, the model was reevaluated based on observation leading to the expression of a rate of division in the form of µ = µ_max\*exp(-q_critic/qP) where µ is the division rate, qp is protein cell quota, q_critic is a characteristic protein cell quota and µ_max is a theoretical maximum cell division rate. µ_max and q_critic are paramters determined through fitting

```{r, echo = include_code, fig.width = 5 , fig.height= 5}

# Intialisation of vectors determined
µ_max <- rep(NA,9)
q_critic <- rep(NA,9)
µ_max_rel_error <- rep(NA,9)
q_critic_rel_error <- rep(NA,9)
R2_local <-  rep(NA,9)
p_value_local <-  rep(NA,9)

ylim_low <- -6.5
y_lim_up <- 2.5

for (i_concentration in (1:3)){
  for (j_light in (1:3)){
    # Isolation of reactor specific data
    data_reduced <- subset(results_PhoCAssPaNS_df, concentrationClass == concentrationClassList[i_concentration])
    data_reduced <- subset(data_reduced, results_PhoCAssPaNS_df$lightClass == lightClassList[j_light])
    
    # The equation proposed is linearised leading to the creation of two vector which are expected to exhibit a linear relationship if the model proposed is verified
    data_reduced$totalProteinCellMidInterval_inverse <- 1/data_reduced$totalProteinCellMidInterval
    data_reduced$divisionRate_log <- log(replace(data_reduced$divisionRate,
                                                 which(data_reduced$divisionRate <= 0) , NA))
    
    # A point was concluded to be an outlier and excluded from analyses. The loop below identifies the experiment of concern and eliminates the outlier.
    if ((i_concentration == 3) & (j_light == 2)){
      point_excluded <- c(data_reduced$totalProteinCellMidInterval_inverse[data_reduced$divisionRate_log < -6],
                          data_reduced$divisionRate_log[data_reduced$divisionRate_log < -6])
      point_excluded <- point_excluded[is.na(point_excluded) == 0]
      data_reduced$divisionRate_log[data_reduced$divisionRate_log < -6] <- NA # removing an outlier of the analysis

    }
    # The linear regression is here performed
    lm_fit <- lm(formula = divisionRate_log ~ totalProteinCellMidInterval_inverse , data = data_reduced)
    a <- summary(lm_fit)
    

print(
    ggplot(data = data_reduced, aes(x = totalProteinCellMidInterval_inverse , y = divisionRate_log)) +
      geom_point() +
      {if((i_concentration == 3) & (j_light == 2))
       geom_point(aes( x = point_excluded[1] , y = point_excluded[2])) 
      } +     
      geom_errorbar(aes(ymin = log(divisionRate)-divisionRate_rel_error,
                        ymax = log(divisionRate) + divisionRate_rel_error)) + 
      geom_errorbarh(aes(xmin = 1/totalProteinCellMidInterval*(1 - totalProteinCellMidInterval_rel_error),
                         xmax = 1/totalProteinCellMidInterval*(1 + totalProteinCellMidInterval_rel_error)),
                     height = 0.2) +
      geom_smooth(method = "lm", formula = y ~ x,geom = "smooth") +
      scale_y_continuous(breaks = c(-6,-4,-2,0,2),limits = c(ylim_low,y_lim_up)) +
      labs(title = paste(concentrationClassList[i_concentration] , " ; " ,
                         lightClassList[j_light] , " incident light"),
           x = expression(bold(paste("1/q"['P'], " (cell.(g Proteins)"^"-1",")"))),
           y = expression(bold(paste("log(µ)")))) +
        theme_paul
)
   
    # Results from linear regression are stored in the local vectors
    µ_max[3*(i_concentration-1)+j_light] <- exp(a$coefficients[1,1])
    µ_max_rel_error[3*(i_concentration-1)+j_light] <- 1.96*a$coefficients[1,2]
    q_critic[3*(i_concentration-1)+j_light] <- -a$coefficients[2,1]
    q_critic_rel_error[3*(i_concentration-1)+j_light] <- 1.96*a$coefficients[2,2]/
      (abs(a$coefficients[2,1]))
    R2_local[3*(i_concentration-1)+j_light] <- a$r.squared
    p_value_local[3*(i_concentration-1)+j_light] <- a$coefficients[2,4]
  }
}
# The results are appended to the reactor specific data frame
reactorPhoCAssPaNS_df$µmExp <- µ_max
reactorPhoCAssPaNS_df$µmExp_rel_error <- µ_max_rel_error
reactorPhoCAssPaNS_df$qCriticExp <- q_critic
reactorPhoCAssPaNS_df$qCriticExp_rel_error <- q_critic_rel_error

# Printing results in a single matrix
divisionRate_matrix <-
  matrix(c(µ_max,
           µ_max_rel_error/1.96*µ_max,
           q_critic,
           q_critic_rel_error/1.96*q_critic,
           R2_local,
           p_value_local),
         nrow = 9)
print(divisionRate_matrix)

# The final max cell division rate is expressed as the average of all the division rates determined in each reactor.

µ_max_exp <- mean(reactorPhoCAssPaNS_df$µmExp)
µ_max_exp
sd(reactorPhoCAssPaNS_df$µmExp)/3

mean(reactorPhoCAssPaNS_df$qCriticExp)
sd(reactorPhoCAssPaNS_df$qCriticExp)/3

```

#### Analysis of cell division rate in light of light density in the reactor

We now plot the results from the cell division rate analysis in order to determine a potential link between light density in the reactor on the division characteristic cell protein quota

```{r, echo = include_code, message=FALSE, warning=FALSE, results='hide', fig.width= 1.3*5.3, fig.height=1.3*4}

ggplot(data = reactorPhoCAssPaNS_df, aes(x = lightDensity, y = qCriticExp)) +
  geom_smooth(method = "lm") +
  geom_errorbar(aes(ymin = qCriticExp*(1 - qCriticExp_rel_error), ymax = qCriticExp*(1 + qCriticExp_rel_error)),stroke = 1.25) + 
  geom_errorbarh(aes(xmin = lightDensity - 1.96*lightDensity_std, xmax = lightDensity + 1.96*lightDensity_std),stroke = 1.25) +
  scale_shape_manual(values = c(1,2,4),na.translate = FALSE) +
  geom_point(aes(colour = lightClass,shape = concentrationClass) , size = 3,stroke = 1.25) +
  labs(x = expression(bold(atop("Dryweight specific light density ",
                                 paste("(µmol.(g DW.s)"^"-1","])")))),
       y = expression(bold(atop("Cell division characteristic",
       paste("protein quota (g Proteins.cell"^"-1",")"))))) + 
  theme_paul +
  # scale_y_log10() +
  scale_color_manual(values = c(my_color_fill[1],my_color_fill[2],my_color_fill[3])) 


a <- lm(qCriticExp ~ lightDensity, data = reactorPhoCAssPaNS_df)
summary(a)

alpha_qp_char_cellDiv = a$coefficients[2]
beta_qp_char_cellDiv = a$coefficients[1] 


```

The same is now done to determine a potential link between light density in the reactor on the theoretical maximum cell division rate

```{r, echo = include_code, message=FALSE, warning=FALSE, results='hide', fig.width= 1.1*5.3, fig.height=1.1*4}


ggplot(data = reactorPhoCAssPaNS_df, aes(x = lightDensity, y = µmExp, colour = lightClass,shape = concentrationClass)) +
  geom_errorbar(aes(ymin = µmExp*(1 - µmExp_rel_error), ymax = µmExp*(1 + µmExp_rel_error)),stroke = 1.25,width = 1) +
  scale_shape_manual(values = c(1,2,4),na.translate = FALSE) +
  geom_point(size = 3,stroke = 1.25) +
  ylim(c(0,12)) +
  labs(x = expression(bold(atop("Dryweight specific light density ",
                                paste("(µmol.(g DW.s)"^"-1","])")))),
       y = expression(bold(atop("Exponential maximum", 
                                paste("specific growth rate (d"^"-1",")"))))) + 
  theme_paul +
  scale_color_manual(values = c(my_color_fill[1],my_color_fill[2],my_color_fill[3])) + 
  scale_y_continuous()
 
```

## Carbon to biomass ratio

The ratio between dryweight concentration and total functional carbon contained in the biomass is investigated below.

```{r, echo = include_code, fig.height=5.5, fig.width=7}

local_lm <- lm(dryWeight ~ carbonFunctional + 0, data = results_PhoCAssPaNS_df)

ggplot(data = results_PhoCAssPaNS_df,
       aes(x = carbonFunctional , y = dryWeight, color = lightClass, shape = concentrationClass)) +
  geom_abline( slope = local_lm$coefficients[1], intercept = 0,colour = "red", linewidth = 2 , linetype = "dashed") +
  geom_errorbar(aes(ymin = dryWeight*(1 - dryweight_rel_error), 
                    ymax = dryWeight*(1 + dryweight_rel_error)),
                width = 0.1) +
  geom_errorbarh(aes(xmin = carbonFunctional*(1 - carbonFunctional_rel_error), 
                     xmax = carbonFunctional*(1 + carbonFunctional_rel_error)),
                 height = 0.2) +
  geom_point(size = 3,stroke = 1.25) +
  scale_shape_manual(values = c(21,23,24)) +
  labs(x =  expression(bold(atop("Functional carbon fixed in biomass",paste("(g C.L"^"-1",")")))),
       y = expression(bold(atop("Biomass dryweight", paste("(g.L"^"-1",")"))))) +

  theme_paul +
  scale_color_manual(values = c(my_color_fill[3],my_color_fill[1],my_color_fill[2])) +
  scale_fill_manual(values = c(my_color_fill[3],my_color_fill[1],my_color_fill[2]))

local_lm
summary(local_lm)
summary(local_lm)$coefficients[1]
summary(local_lm)$coefficients[2]


```

# Model verification

## Stop module

As model verification may take up some time, this module was added which stops a run. The model verification must then be obtained by running the part of the code below separately.

```{r stop capsule}
if (lastSimulation == 0){
 stop()
}
```

## Initialisation variables

```{r , echo = include_code}

# General parameters------------------------------------------------------------

n_iter = 200 # number of iterations
dt = 16/n_iter # time step (day)
simulation_df <- data.frame(time = seq(0,n_iter*dt,dt))


# Operative parameters
## d_reactor : initial reactor depth (m)
## r_reactor : reactor radius (m)
## angle_eflask : inclination of the side of the erlen (radians)
  
d_reactor = 0.0556
r_reactor = 0.06
angle_eflask = 1.396263

# Initial reactor volume is computed (V_reactor_0, L)
V_reactor_0 = 1/3*pi*r_reactor^3*tan(angle_eflask)*(1-(1-d_reactor/(r_reactor*tan(angle_eflask)))^3)*1000

# Yield parameters
## Y_CHO_O2: yield of glucose per production of O2 during phtotsynthesis (g CHO/g O2)
## Y_C_CHO: content of carbon in biomass carbohydrates (g C/g CHO)
## Y_X_C : biomass to carbon yield during biomass growth (g DW/g C) 
## Y_C_L : content of carbon in  biomass lipids (g C/g Lipids)
## Y_C_P : content of carbon in  biomass proteins (g C/g Proteins)

Y_CHO_O2 <- 4/32*180/24
Y_C_CHO <- 0.439
Y_X_C <-  1.92019
Y_C_L <- 0.8522
Y_C_P <- 0.6579


# Cell parameters
## This regroups all model constants necessary for predictions
### lambda_decay: decay rate (g C/(g DW.s))
### Pm_0 : Theoretical maximum specific photosynthetic rate of O2 production (g 02/(g DW.s.[g N/g C]))
### cnRatio_char : characteristic C:N ratio of the decrease of photosynthetic activity for increasing C:N ratio (g C/(g N))
### sigma_max : max light extinction coefficient (m2/g DW)
### K_qp : affinity constant of light extinction coefficient toward protein mass quota (g P/g cell)
### lambda_CHO: carbohydrates cell quota characteristic for light absorption (g CHO/cell)
### µ_max_exp : maximum cell division rate (s-1)
### alpha_qp_char_cellDiv: slope of the linear regression between the characteristic protein quota for cell division and the light density in the reactor (g P.gDW.S/(cell.µmol))
### beta_qp_char_cellDiv : intercept of the linear regression between the characteristic protein quota for cell division and the light density in the reactor (g P.cell-1)
### q_CHO_cell_max_global : maximum carbohydrate cell quota prior to conversion of carbon to lipids (g CHO/cell)
### p_L_cell_max : maximum rate of production of lipid for a single cell (g Lipid/cell/s)

lambda_decay = lambda_decay/24/3600 # 0.01115367/24/3600
Pm_0_exp
cnRatio_char
gamma_Pm
sigma_max = sigma683Mass_max # 0.9564742
K_qP = K_p # 0.1424641
lambda_CHO = 1/lambda_sugars # 1/1.526272e+10
µ_max_exp = µ_max_exp/24/3600
alpha_qp_char_cellDiv 
beta_qp_char_cellDiv 
q_CHO_cell_max_global = q_CHO_max_global # 4.421543e-12
p_L_cell_max = p_L_cell_max/24/3600



# Initialization tables



## The cell metabolic state and the culture conditions are initialized. 
### q_P_0 : Initial protein quota (g Protein/g dryweight)
### q_L_0 : Initial lipid quota (g Lipids/g dryweight)
### q_CHO_0 : Initial carbohydrates quota (g Carbohydrates/g dryweight)
### N_0 : Initial cell count (cell/L)
### X_0 : Initial dry weight (g/L)

q_P_0 = 0.69
q_L_0 = 0.10
q_CHO_0 = 0.13

N_0_table = c(2.49*10^9 , 7.47*10^9 , 2.73*10^10)
X_0_table = c(0.101 , 0.303 , 1.11)


## Light conditions initialization
### Global initial light intensity (I0, µmol/m2/s)
I_0 = 220
### The light/dark period is determined for the corresponding lines of the time vector (day_vector, binary =1 if day, = 0 if night)
day_vector <- rep(1,nrow(simulation_df))
day_vector[(((simulation_df$time - floor(simulation_df$time)) < 11/24) & ((simulation_df$time - floor(simulation_df$time)) > 7/24))] <- 0
### Matrix of light intensity (I_0_table): a matrix is created gathering light intensity for the trhee different types of reactor (75% light intensity filter, 50% light intensity filter, no filter) including the dark/light period.
I_O_vector <- day_vector*I_0
I_0_table <- matrix(c(0.25*I_O_vector, 0.5*I_O_vector , I_O_vector), ncol = 3)

## Matrix of the volume of the reactor
### V_reactor_0_table: vector of volume variations according to time, initiliazed with the initial value V_reactor_0
### The volume variations due to sampling must be accounted for in order to recreate the experimental conditions. The values reported on each sampling and corresponding dates from the start are gathered in a matrix (matrix_volume_change)

V_reactor_0_table <- c(V_reactor_0,rep(NA,nrow(simulation_df)-1))
matrix_volume_change <- matrix(c(c(0.75,1.75,3.75,7.75,9.75,13.75,15.75),
                          c(0.470,0.390,0.310,0.230,0.150,NA,NA),
                          c(0.500,0.450,0.400,0.350,0.300,0.220,0.165),
                          c(0.500,0.450,0.400,0.350,0.300,0.250,0.200)),
                          ncol = 4)

```

## Loop of experiment simulation

```{r, echo = include_code, fig.width=5.5, fig.height=4.5}
# A list is created to save the data frame of the results of the simulation for each reactor (list_simulation)
list_simulation <- list()

# A loop is now performed per reactor
for (i_concentration in (1:3)){
  for (j_light in (1:3)){

    # Initialisation of the cell count and dryweight concentration
    N_0 = N_0_table[i_concentration]
    X_0 = X_0_table[i_concentration]
      
    # Creation of the data frame in which will be reported all the current loop results
    ## The data frame initially only contains the time vector on which data points will be determined
    simulation_df <- data.frame(time = seq(0,n_iter*dt,dt))
  
    # Initialisation of the data set
    ## Needed variables that will be included in the data frame for the current loop are created and initialised according to the real experimental data
    ## Incident light intensity (the values over the complete experiment are directly implemented)
    simulation_df$I0 <- I_0_table[,j_light]
    ## Dry-weight concentration (g/L)
    simulation_df$xAlgae <- c(X_0,rep(NA,nrow(simulation_df)-1))
    ## Algae cell count (cell/L)
    simulation_df$nAlgae <- c(N_0,rep(NA,nrow(simulation_df)-1))
    ## Proteins mass quota (g Proteins/g dry-weight)
    simulation_df$q_P <- c(q_P_0,rep(NA,nrow(simulation_df)-1))
    ## Lipids mass quota (g Lipids/g dry-weight)
    simulation_df$q_L <- c(q_L_0,rep(NA,nrow(simulation_df)-1))
    ## Carbohydrates mass quota (g Carbohydrates/g dry-weight)
    simulation_df$q_CHO <- c(q_CHO_0,rep(NA,nrow(simulation_df)-1))
    ## Proteins cell quota (g Proteins/cell)
    simulation_df$q_P_cell <- c(q_P_0*X_0/N_0,rep(NA,nrow(simulation_df)-1))
    ## Lipids cell quota (g Lipids/cell)
    simulation_df$q_L_cell <- c(q_L_0*X_0/N_0,rep(NA,nrow(simulation_df)-1))
    ## Carbohydrate cell quota (g Carbohydrates/cell)
    simulation_df$q_CHO_cell <- c(q_CHO_0*X_0/N_0,rep(NA,nrow(simulation_df)-1))
    
    # The rest of the variables needed in the simulation but which are not initialised according to experimental measurements are also included.
    ## C:N ratio in the biomass (g C/g N)
    simulation_df$cnRatio <- rep(NA,nrow(simulation_df))
    ## Mass specific light extinction coefficient (m2/g dry-weight)
    simulation_df$sigma683Mass <- rep(NA,nrow(simulation_df))
    ## Specific maximum photosynthetic rate of O2 production (g 02/g dry-weight/s)
    simulation_df$Pm <- rep(NA,nrow(simulation_df))
    ## Light density in the reactor (µmol/(gDW.S))
    simulation_df$lightDensity <- rep(NA,nrow(simulation_df))
    
    # Loop of calculation
    for (i_simul in (1:(n_iter))){
      # Calculation initilalization for the current time step
      ## Initialisation from previous determination
      q_P_local = simulation_df$q_P[i_simul]
      q_L_local = simulation_df$q_L[i_simul]
      q_CHO_local = simulation_df$q_CHO[i_simul]
      q_P_cell_local = simulation_df$q_P_cell[i_simul] # g Prot/cell
      q_CHO_cell_local = simulation_df$q_CHO_cell[i_simul] # g CHO/cell
      q_L_cell_local = simulation_df$q_L_cell[i_simul] # g Lip/cell
      I0_local <- simulation_df$I0[i_simul] # µmol/m2/s
      X_algae_local <- simulation_df$xAlgae[i_simul] #g/L
      N_algae_local <- simulation_df$nAlgae[i_simul] #cell/L
      
      ## Volume calculation
      ### The current volume (V_reactor_local) is determined by comparing the current time to the time of volume change in the reference matrix
      ### Volume change from previous time step is also calculated
      if (simulation_df$time[i_simul] < matrix_volume_change[1,1]){
        V_reactor_local <- V_reactor_0
        delta_V_local <- 0
      }else{
        V_reactor_old <- V_reactor_local
        V_reactor_local <- matrix_volume_change[max(which(matrix_volume_change[,1] < simulation_df$time[i_simul])),i_concentration + 1]
        # We try to find the index of matrix_volume_change corresponding to the actual volume
        delta_V_local <- V_reactor_local - V_reactor_old
        if (is.na(V_reactor_local)){
          delta_V_local <- 0
          V_reactor_local <- V_reactor_0
        }
      }
      ## Reactor depth of the current time is computed from the volume determined
      reactor_depth_local <- r_reactor*tan(angle_eflask) - 
        ((r_reactor*tan(angle_eflask))^3 -
           3/pi*(V_reactor_local/1000)*(tan(angle_eflask))^2)^(1/3)
  
      # The time step is computed for Euler-type calculations
      dt_local <- (simulation_df$time[i_simul+1] - simulation_df$time[i_simul])*24*3600 # into seconds
      
      ## Initialisation of variiables from model equations 
      cn_ratio_local = (Y_C_CHO*q_CHO_local + Y_C_P*q_P_local + Y_C_L*q_L_local)/(1/factor_protein*q_P_local)
      # Pm_local = Pm_0*exp(-cn_ratio_local/cnRatio_char)
      Pm_local = Pm_0_exp*(cn_ratio_local/cnRatio_char)^(gamma_Pm)
      sigma683Mass_local = sigma_max*q_P_local/(K_qP+q_P_local) - q_CHO_cell_local/lambda_CHO
      lightDensity_local = I0_local/(reactor_depth_local*X_algae_local*1000)*
        (1 - exp(-sigma683Mass_local*X_algae_local*1000*reactor_depth_local)) # µmol/g/s

        
      ## Implementation in the data frame of the modeled variables computed for the current time step
      simulation_df$sigma683Mass[i_simul] <- sigma683Mass_local
      simulation_df$Pm[i_simul] <- Pm_local
      simulation_df$cnRatio[i_simul] <- cn_ratio_local
      simulation_df$lightDensity[i_simul] <- lightDensity_local
        
      # Calculation of carbon absorbed on the current time step----------------- 
      
      eflask_base_tensor = array(data = rep(NA,(n_mesh+1)^3), dim = c(n_mesh+1,n_mesh+1,n_mesh+1))
      
      z_coordinates = seq(0,reactor_depth_local,reactor_depth_local/n_mesh)
      teta_coordinates = seq(0,2*pi,2*pi/n_mesh)
      r_coordinates <- seq(0,r_reactor - reactor_depth_local/tan(angle_eflask),(r_reactor - reactor_depth_local/tan(angle_eflask))/n_mesh)
        
      r_coordinates_tensor <- eflask_base_tensor
      teta_coordinates_tensor <- eflask_base_tensor
      z_coordinates_tensor <- eflask_base_tensor
    
      for (i in 1:(n_mesh + 1)){
        for (j in 1:(n_mesh + 1)){
          for (k in 1:(n_mesh + 1)){
            # Assigning coordinates for each point inside the volume of the e-flask
            r_seq <- seq(0,r_reactor - (reactor_depth_local - z_coordinates[k])/tan(angle_eflask),(r_reactor - (reactor_depth_local - z_coordinates[k])/tan(angle_eflask))/n_mesh)
            r_coordinates_tensor[i,j,k] <- r_seq[i]
            teta_coordinates_tensor[i,j,k] <- teta_coordinates[j]
            z_coordinates_tensor[i,j,k] <- z_coordinates[k]
          }
        }
      }
      
      ## Tensor for the corresponding coordinates are created for local light intensity (I_distribution_local) and local O2 photosynthetic production (P_O2_spec_local)
      I_distribution_local <- eflask_base_tensor
      P_O2_spec_local <- eflask_base_tensor

      ## Local light intensity determination
      for (iv in 1:(n_mesh)){
        for (jv in 1:(n_mesh)){
          for (kv in 1:(n_mesh)){
            
            # local point coordinates based on the middle point between consecutive coordinates
            r_local = (r_coordinates_tensor[iv,jv,kv] + r_coordinates_tensor[iv+1,jv,kv])/2
            teta_local = (teta_coordinates_tensor[iv,jv,kv] + teta_coordinates_tensor[iv,jv+1,kv])/2
            z_local = (z_coordinates_tensor[iv,jv,kv] + z_coordinates_tensor[iv,jv,kv+1])/2
            
            # Depth from the top of the e-flask vertically to the point (rk : positive toward the bottom)
            r_lim <- r_reactor - reactor_depth_local/tan(angle_eflask) # Limit of the "non conical" part of the broth
            if (r_local <= r_lim){
              z_s <- z_local
            }else{
              z_s <- z_local - (r_local - r_lim)*tan(angle_eflask)
            }
            I_distribution_local[iv,jv,kv] <- I0_local*exp(-sigma683Mass_local*X_algae_local*1000*z_s)
          }
        }
      }
      
      ## Gross O2 production calculation
      ### We apply the formula of photosynthetic oxygen productivity for all local volumes based on local intensities
      for (iv in 1:(n_mesh)){
        for (jv in 1:(n_mesh)){
          for (kv in 1:(n_mesh)){
              # Calculation of local volume value
              dV <- (r_coordinates_tensor[iv+1,jv,kv] + r_coordinates_tensor[iv,jv,kv])/2*(r_coordinates_tensor[iv+1,jv,kv] - r_coordinates_tensor[iv,jv,kv])*
                (teta_coordinates_tensor[iv,jv+1,kv] - teta_coordinates_tensor[iv,jv,kv])*
                (z_coordinates_tensor[iv,jv,kv+1] - z_coordinates_tensor[iv,jv,kv])
              # Local O2 production (gO2 produced over dt)
              P_O2_spec_local[iv,jv,kv] <- 
                Pm_local* sigma683Mass_local*(X_algae_local)*I_distribution_local[iv,jv,kv]/
                      (alpha_PI*Pm_local +  sigma683Mass_local*X_algae_local*I_distribution_local[iv,jv,kv] + (1/K2_mass)*(sigma683Mass_local*X_algae_local*I_distribution_local[iv,jv,kv])^2)*
                    X_algae_local*(10^3)*dV*dt_local
          }
        }
      }
      ### Global volumic O2 production is calculated as the sum of all the local O2 production divided by the total volume (g O2/L)
      P_O2_gross_local <- sum(P_O2_spec_local,na.rm = TRUE)/V_reactor_local 
      
      ## Net carbon assimilation
      ### Carbon assimilated by photosynthesis (g CHO/L over dt)
      CHO_photosynthesis_local <- P_O2_gross_local*Y_CHO_O2
      
      ### Gross CHO respiration consumption (g CHO/L over dt)
      CHO_respiration_gross_local <- 1/Y_C_CHO*lambda_decay*X_algae_local*dt_local 
      
      ### Net CHO productivity (g CHO/L/d)
      P_CHO_net_local <- (CHO_photosynthesis_local - CHO_respiration_gross_local)/dt_local
      
      
      # Cell division prediction----------------------------------------------------
      ## Instantaneous division rate is computed from mathematical model, and cell count evolution is determined based on Euler method
      µ_local <- µ_max_exp*
        exp(-(alpha_qp_char_cellDiv*lightDensity_local+beta_qp_char_cellDiv)/q_P_cell_local)
      N_algae_calc <- N_algae_local*(1 + µ_local*dt_local)
    
      
      # Carbon partition model-------------------------------------------------------------
      ## Protein quota
      ### Protein quota is simply computed based on a constant total protein quota and the increase of biomass dryweight and total cell
      q_P_cell_calc <- q_P_cell_local*N_algae_local/N_algae_calc
      
      ## CHO and lipids
      ### We first compute theoretical (P_L_aux_local) and maximal possible (P_L_max_local) productivities for lipids
      
      P_L_aux_local <- Y_C_CHO/Y_C_L*P_CHO_net_local
      P_L_max_local <- p_L_cell_max*N_algae_local
      
      ### Diverging scenarios for lipid production
      #### 1) Consumption of internal carbohydrates => all consumption is on carbohydrate quota
      if (P_CHO_net_local < 0){
        P_L_local <- 0
        P_CHO_local <- P_CHO_net_local
      }else{
      #### 2) The cells after division and newly assimilated carbon are not over the basal cell quota in carbohydarte => all carbon assimilation goes to carbohydrates
        if (q_CHO_cell_local < q_CHO_cell_max_global){ 
          P_L_local <- 0
          P_CHO_local <- P_CHO_net_local
        }else{
          if (P_L_aux_local < P_L_max_local){
            # 3) Cells carbohydrates quota would opverpass the basal quota & the potential for lipid accumulation would not overpass the maximum cell lipid productivit (i.e. P_L_max_local > P_L_aux_local) => then all the cabon left to absorb is absorbed as lipid
            P_L_local <- P_L_aux_local
            P_CHO_local <- 0
          }else{
            # 3) Cells carbohydrates quota would opverpass the basal quota & the potential for lipid accumulation would overpass the maximum cell lipid productivit (i.e. P_L_max_local > P_L_aux_local) => then lipid are produced according to the maximum possible and the rest of the carbon is absorbed as carbohydrates
            P_L_local <- P_L_max_local
            P_CHO_local <- P_CHO_net_local - Y_C_L/Y_C_CHO*P_L_max_local
          }
        }
      }

      ### Calculation of new partition in cell quotas for lipids and carbohydrates
      q_L_cell_calc <- (q_L_cell_local*N_algae_local + P_L_local*dt_local)/N_algae_calc
      q_CHO_cell_calc <- (q_CHO_cell_local*N_algae_local + P_CHO_local*dt_local)/N_algae_calc
      
      # Biomass dryweight prediction------------------------------------------------
      ## New biomass dryweight
      X_algae_calc <- X_algae_local + 
        Y_X_C*(Y_C_CHO*P_CHO_local + Y_C_L*P_L_local)*dt_local 
      
      # Mass quota prediction---------------------------------------------------
      q_P_calc <- q_P_local*X_algae_local/X_algae_calc
      q_CHO_calc <- (q_CHO_local*X_algae_local + P_CHO_local*dt_local)/X_algae_calc
      q_L_calc <- (q_L_local*X_algae_local + P_L_local*dt_local)/X_algae_calc
          
    
      
      # Implementation of new data in the data frame----------------------------
      simulation_df$xAlgae[i_simul + 1] <- X_algae_calc
      simulation_df$nAlgae[i_simul + 1] <- N_algae_calc
      simulation_df$q_P[i_simul + 1] <- q_P_calc
      simulation_df$q_P_cell[i_simul + 1] <- q_P_cell_calc
      simulation_df$q_CHO[i_simul + 1] <- q_CHO_calc
      simulation_df$q_CHO_cell[i_simul + 1] <- q_CHO_cell_calc 
      simulation_df$q_L[i_simul + 1] <-  q_L_calc 
      simulation_df$q_L_cell[i_simul + 1] <- q_L_cell_calc
    }
      
    # Appending the reactor data to the list of experiment results
    list_simulation[[3*(i_concentration-1)+j_light]] <- simulation_df
    ## Due to the relatively large duration of the calculation, we here print the advancement of the calculation (in % of the total approx. time)
    print(paste(as.character((3*(i_concentration-1)+j_light)/9*100)," %"))
#-------------------------------------------------------------------------------
    # PLOT OF THE RESULTS
    ## The plots comparing the data generated to the experimental are created here. These plots are briefly put together and mostly serve to control with th eye the behaviour of the model.
    
    ## Experimental data from the reactor of the current loop is retrieved
    data_comparison <- subset(results_PhoCAssPaNS_df , concentrationClass == concentrationClassList[i_concentration])
    data_comparison <- subset(data_comparison, data_comparison$lightClass == lightClassList[j_light])

    ## Plots are now created for each metric predicted
    p1 <- 
      ggplot() +
        geom_line(data = simulation_df, aes(x = time, y = xAlgae)) +
        geom_point(data = data_comparison, aes(x = day , dryWeight)) +
        geom_errorbar(data = data_comparison,
                      aes(x = day, y = dryWeight,
                          ymin = dryWeight*(1-dryweight_rel_error),
                          ymax = dryWeight*(1+dryweight_rel_error))) +
        theme_paul
      
    p2 <- 
      ggplot() +
        geom_point(data = data_comparison, aes(x = day , cellCount*1000)) +
        geom_line(data = simulation_df, aes(x = time, y = nAlgae)) +
        geom_errorbar(data = data_comparison,
                      aes(x = day, y = cellCount*1000,
                          ymin = cellCount*1000*(1-cellCount_rel_error),
                          ymax = cellCount*1000*(1+cellCount_rel_error))) +
        theme_paul
      
    p3<- 
      ggplot() +
        geom_point(data = data_comparison, aes(x = day , totalProtein)) +
        geom_line(data = simulation_df, aes(x = time, y = q_P)) +
        geom_errorbar(data = data_comparison,
                      aes(x = day, y = totalProtein,
                          ymin = totalProtein*(1-totalProtein_rel_error),
                          ymax = totalProtein*(1+totalProtein_rel_error))) +
        theme_paul
      
    p4 <- 
      ggplot() +
        geom_point(data = data_comparison, aes(x = day , totalSugars),size = 3,stroke = 1.25) +
        geom_line(data = simulation_df, aes(x = time, y = q_CHO),size = 1, col = "blue", linetype = 1) +
        geom_errorbar(data = data_comparison,
                      aes(x = day, y = totalSugars,
                          ymin = totalSugars*(1-totalSugars_rel_error),
                          ymax = totalSugars*(1+totalSugars_rel_error)),
                      size = 0.75) +
      labs(x = "Day",
           y = expression(bold(atop("Carbohydrates mass quotat", paste("(g.(g dry-weight)"^"-1",")"))))) +
      theme_paul
    
  
    p5 <- 
      ggplot() +
        geom_point(data = data_comparison, aes(x = day , totalFAME),size = 3,stroke = 1.25) +
        geom_line(data = simulation_df, aes(x = time, y = q_L),size = 1, col = "blue", linetype = 1) +
        geom_errorbar(data = data_comparison,
                      aes(x = day, y = totalFAME,
                          ymin = totalFAME*(1-totalFame_rel_error),
                          ymax = totalFAME*(1+totalFame_rel_error)),
                      size = 0.75) +
      labs(x = "Day",
           y = expression(bold(atop("Lipids mass quotat", paste("(g.(g dry-weight)"^"-1",")"))))) +
      theme_paul
        theme_paul
      
    p6 <- 
      ggplot() +
        geom_point(data = data_comparison, aes(x = day , totalProteinCell)) +
        geom_line(data = simulation_df, aes(x = time, y = q_P_cell)) +
        geom_errorbar(data = data_comparison,
                      aes(x = day, y = totalProteinCell,
                          ymin = totalProteinCell*(1-totalProteinCell_rel_error),
                          ymax = totalProteinCell*(1+totalProteinCell_rel_error))) +
        theme_paul
      
    p7 <- 
      ggplot() +
        geom_point(data = data_comparison, aes(x = day , totalSugarsCell)) +
        geom_line(data = simulation_df, aes(x = time, y = q_CHO_cell)) +
        geom_errorbar(data = data_comparison,
                      aes(x = day, y = totalSugarsCell,
                          ymin = totalSugarsCell*(1-totalSugarsCell_rel_error),
                          ymax = totalSugarsCell*(1+totalSugarsCell_rel_error))) +
        theme_paul
      
    p8 <- 
      ggplot() +
        geom_point(data = data_comparison, aes(x = day , totalFAMECell)) +
        geom_line(data = simulation_df, aes(x = time, y = q_L_cell)) +
        geom_errorbar(data = data_comparison,
                      aes(x = day, y = totalFAMECell,
                          ymin = totalFAMECell*(1-totalFAMECell_rel_error),
                          ymax = totalFAMECell*(1+totalFAMECell_rel_error))) +
        theme_paul
      
      
    p9 <- 
      ggplot() +
        geom_point(data = data_comparison, aes(x = day , sigma683Mass)) +
        geom_line(data = simulation_df, aes(x = time, y = sigma683Mass)) +
        geom_errorbar(data = data_comparison,
                      aes(x = day, y = sigma683Mass,
                          ymin = sigma683Mass*(1-sigma_rel_error),
                          ymax = sigma683Mass*(1+sigma_rel_error))) +
        theme_paul
      
    p10 <- 
      ggplot() +
        geom_point(data = data_comparison, aes(x = day , PmMass)) +
        geom_line(data = simulation_df, aes(x = time, y = Pm)) +
        geom_errorbar(data = data_comparison,
                      aes(x = day, y = PmMass,
                          ymin = PmMassMin,
                          ymax = PmMassMax)) +
      scale_y_log10() +
        theme_paul
      
    p11 <- 
      ggplot() +
        geom_point(data = data_comparison, aes(x = day , cnRatio)) +
        geom_line(data = simulation_df, aes(x = time, y = cnRatio)) +
        geom_errorbar(data = data_comparison,
                      aes(x = day, y = cnRatio,
                          ymin = cnRatio*(1-sqrt(tocSpecific_rel_error^2 + totalProtein_rel_error^2)),
                          ymax = cnRatio*(1+sqrt(tocSpecific_rel_error^2 + totalProtein_rel_error^2)))) +
        theme_paul
    
    p12 <- 
      ggplot() +
        geom_point(data = data_comparison, aes(x = day , totalProtein*dryWeight)) +
        geom_line(data = simulation_df, aes(x = time, y = q_P*xAlgae)) +
        geom_errorbar(data = data_comparison,
                      aes(x = day, y = totalProtein*dryWeight,
                          ymin = totalProtein*dryWeight*
                            (1 - sqrt(dryweight_rel_error^2 + totalProtein_rel_error^2)),
                          ymax = totalProtein*dryWeight*
                            (1 + sqrt(dryweight_rel_error^2 + totalProtein_rel_error^2)))) +
        theme_paul
    
    p13 <- 
      ggplot() +
        geom_point(data = data_comparison, aes(x = day , totalSugars*dryWeight)) +
        geom_line(data = simulation_df, aes(x = time, y = q_CHO*xAlgae)) +
        geom_errorbar(data = data_comparison,
                      aes(x = day, y = totalSugars*dryWeight,
                          ymin = totalSugars*dryWeight*
                            (1 - sqrt(dryweight_rel_error^2 + totalSugars_rel_error^2)),
                          ymax = totalSugars*dryWeight*
                            (1 + sqrt(dryweight_rel_error^2 + totalSugars_rel_error^2)))) +
        theme_paul
    
    p14 <- 
      ggplot() +
        geom_point(data = data_comparison, aes(x = day , totalFAME*dryWeight)) +
        geom_line(data = simulation_df, aes(x = time, y = q_L*xAlgae)) +
        geom_errorbar(data = data_comparison,
                      aes(x = day, y = totalFAME*dryWeight,
                          ymin = totalFAME*dryWeight*
                            (1 - sqrt(dryweight_rel_error^2 + totalFame_rel_error^2)),
                          ymax = totalFAME*dryWeight*
                            (1 + sqrt(dryweight_rel_error^2 + totalFame_rel_error^2)))) +
        theme_paul
    
    p15 <- 
      ggplot() +
        geom_point(data = data_comparison, aes(x = day , tocSpecific*dryWeight)) +
        geom_line(data = simulation_df, 
                  aes(x = time, y = (Y_C_P*q_P + Y_C_CHO*q_CHO + Y_C_L*q_L)*xAlgae)) +
        geom_errorbar(data = data_comparison,
                      aes(x = day, y = tocSpecific*dryWeight,
                          ymin = tocSpecific*dryWeight*
                            (1 - sqrt(tocSpecific_rel_error^2 + dryweight_rel_error^2)),
                          ymax = tocSpecific*dryWeight*
                            (1 + sqrt(tocSpecific_rel_error^2 + dryweight_rel_error^2)))) +
        theme_paul
    
    print(p1)
    print(p2)
    print(p3)
    print(p4)
    print(p5)
    print(p6)
    print(p7)
    print(p8)
    print(p9)
    print(p10)
    print(p11)
    print(p12)
    print(p13)
    print(p14)
    print(p15)
  }
}


```

## Recuperation of data

For each reactor, predicted data are extracted to correspond to each measured data point. To achieve so, the time step included to the model which is closest to each given measurement is identified and the data for each variable of this time step is then collected from the predicted data base. The predicted results corresponding to each date of the measured data hence obtained are appended to the central data frame.

```{r , echo = include_code}


for (i_val in (1:nrow(results_PhoCAssPaNS_df))){
  
  if (results_PhoCAssPaNS_df$concentrationClass[i_val] == "0.1 g.L-1"){
    i_concentration <- 1
  }else{
    if (results_PhoCAssPaNS_df$concentrationClass[i_val] == "0.3 g.L-1"){
      i_concentration <- 2
    }else{
      i_concentration <- 3
    }
  }
  
  if (results_PhoCAssPaNS_df$lightClass[i_val] == "25%"){
    j_light <- 1
  }else{
    if (results_PhoCAssPaNS_df$concentrationClass[i_val] == "0.3 g.L-1"){
      j_light <- 2
    }else{
      j_light <- 3
    }
  }
  
  local_simulation_df <- list_simulation[[3*(i_concentration-1)+j_light]]
  
  results_PhoCAssPaNS_df$predicted_xAlgae[i_val] <- 
    local_simulation_df$xAlgae[which(abs(local_simulation_df$time - results_PhoCAssPaNS_df$day[i_val]) == min(abs(local_simulation_df$time - results_PhoCAssPaNS_df$day[i_val])))]
  results_PhoCAssPaNS_df$predicted_nAlgae[i_val] <-
    local_simulation_df$nAlgae[which(abs(local_simulation_df$time - results_PhoCAssPaNS_df$day[i_val]) == min(abs(local_simulation_df$time - results_PhoCAssPaNS_df$day[i_val])))]
  results_PhoCAssPaNS_df$predicted_q_P[i_val] <- 
    local_simulation_df$q_P[which(abs(local_simulation_df$time - results_PhoCAssPaNS_df$day[i_val]) == min(abs(local_simulation_df$time - results_PhoCAssPaNS_df$day[i_val])))]
  results_PhoCAssPaNS_df$predicted_q_L[i_val] <- 
    local_simulation_df$q_L[which(abs(local_simulation_df$time - results_PhoCAssPaNS_df$day[i_val]) == min(abs(local_simulation_df$time - results_PhoCAssPaNS_df$day[i_val])))]
  results_PhoCAssPaNS_df$predicted_q_CHO[i_val] <- 
    local_simulation_df$q_CHO[which(abs(local_simulation_df$time - results_PhoCAssPaNS_df$day[i_val]) == min(abs(local_simulation_df$time - results_PhoCAssPaNS_df$day[i_val])))]
  results_PhoCAssPaNS_df$predicted_q_P_cell[i_val] <- 
    local_simulation_df$q_P_cell[which(abs(local_simulation_df$time - results_PhoCAssPaNS_df$day[i_val]) == min(abs(local_simulation_df$time - results_PhoCAssPaNS_df$day[i_val])))]
  results_PhoCAssPaNS_df$predicted_q_L_cell[i_val] <- 
    local_simulation_df$q_L_cell[which(abs(local_simulation_df$time - results_PhoCAssPaNS_df$day[i_val]) == min(abs(local_simulation_df$time - results_PhoCAssPaNS_df$day[i_val])))]
  results_PhoCAssPaNS_df$predicted_q_CHO_cell[i_val] <- 
    local_simulation_df$q_CHO_cell[which(abs(local_simulation_df$time - results_PhoCAssPaNS_df$day[i_val]) == min(abs(local_simulation_df$time - results_PhoCAssPaNS_df$day[i_val])))]
  results_PhoCAssPaNS_df$predicted_cnRatio[i_val] <- 
    local_simulation_df$cnRatio[which(abs(local_simulation_df$time - results_PhoCAssPaNS_df$day[i_val]) == min(abs(local_simulation_df$time - results_PhoCAssPaNS_df$day[i_val])))]
  results_PhoCAssPaNS_df$predicted_sigma683Mass[i_val] <- 
    local_simulation_df$sigma683Mass[which(abs(local_simulation_df$time - results_PhoCAssPaNS_df$day[i_val]) == min(abs(local_simulation_df$time - results_PhoCAssPaNS_df$day[i_val])))]
  results_PhoCAssPaNS_df$predicted_Pm[i_val] <- 
    local_simulation_df$Pm[which(abs(local_simulation_df$time - results_PhoCAssPaNS_df$day[i_val]) == min(abs(local_simulation_df$time - results_PhoCAssPaNS_df$day[i_val])))]
  
}

```

## Validation verification plots

FOr each variable predicted, measured vs predicted values are plotted.

```{r, echo = include_code, fig.width = 6, fig.height = 4.5}
validationPlot_dryweight <-
  ggplot(data = results_PhoCAssPaNS_df, aes(x = predicted_xAlgae, y = dryWeight)) +
    geom_point(aes(color = lightClass, shape = concentrationClass), size = 3,stroke = 1.25) +
    geom_errorbar(aes(ymin = dryWeight*(1 - dryweight_rel_error),
                      ymax = dryWeight*(1 + dryweight_rel_error)),
                  width = 0.05) +
    geom_abline( slope = 1, intercept = 0,colour = "red", linewidth = 2 , linetype = "dashed") +
    scale_shape_manual(values = c(21,23,24)) +
    labs(title = "a)",
         x = expression(bold(atop("Predicted biomass concentration",
                                        paste("(g dry-weight.L"^"-1",")")))),
         y = expression(bold(atop("Measured biomass concentration",
                                        paste("(g dry-weight.L"^"-1",")"))))) +
    theme_paul + 
    scale_color_manual(values = c(my_color_fill[1],my_color_fill[2],my_color_fill[3])) +
    scale_fill_manual(values = c(my_color_fill[1],my_color_fill[2],my_color_fill[3])) +
    theme_paul

validationPlot_dryweight


validationPlot_cellCount <-
  ggplot(data = results_PhoCAssPaNS_df, aes(x = predicted_nAlgae, y = cellCount*1000)) +
    geom_point(aes(color = lightClass, shape = concentrationClass), size = 3,stroke = 1.25) +
    geom_errorbar(aes(ymin = cellCount*(1 - cellCount_rel_error)*1000,
                      ymax = cellCount*(1 + cellCount_rel_error)*1000),
                      width = 0.05) +
    geom_abline( slope = 1, intercept = 0,colour = "red", linewidth = 2 , linetype = "dashed") +
    scale_shape_manual(values = c(21,23,24)) +
    labs(title = "b)",
         x = expression(bold(atop("Predicted biomass cell count",
                                        paste("(cell.L"^"-1",")")))),
         y = expression(bold(atop("Measured biomass cell count",
                                        paste("(cell.L"^"-1",")"))))) +
    theme_paul + 
    scale_y_log10() + 
    scale_x_log10() +
    scale_color_manual(values = c(my_color_fill[1],my_color_fill[2],my_color_fill[3])) +
    scale_fill_manual(values = c(my_color_fill[1],my_color_fill[2],my_color_fill[3])) +
    theme_paul

validationPlot_cellCount


ggplot(data = results_PhoCAssPaNS_df, aes(x = predicted_q_P, y = totalProtein)) +
  geom_point(aes(color = lightClass, shape = concentrationClass), size = 3,stroke = 1.25) +
  geom_errorbar(aes(ymin = totalProtein*(1 - totalProtein_rel_error),
                    ymax = totalProtein*(1 + totalProtein_rel_error))) +
  geom_abline( slope = 1, intercept = 0,colour = "red", linewidth = 2 , linetype = "dashed") +
  scale_shape_manual(values = c(21,23,24)) +
  theme_paul + 
  scale_color_manual(values = c(my_color_fill[1],my_color_fill[2],my_color_fill[3])) +
  scale_fill_manual(values = c(my_color_fill[1],my_color_fill[2],my_color_fill[3])) +
  theme_paul


ggplot(data = results_PhoCAssPaNS_df, aes(x = predicted_q_CHO, y = totalSugars)) +
  geom_point(aes(color = lightClass, shape = concentrationClass), size = 3,stroke = 1.25) +
  geom_errorbar(aes(ymin = totalSugars*(1 - totalSugars_rel_error),
                    ymax = totalSugars*(1 + totalSugars_rel_error))) +
  geom_abline( slope = 1, intercept = 0,colour = "red", linewidth = 2 , linetype = "dashed") +
  scale_shape_manual(values = c(21,23,24)) +
  theme_paul + 
  scale_color_manual(values = c(my_color_fill[1],my_color_fill[2],my_color_fill[3])) +
  scale_fill_manual(values = c(my_color_fill[1],my_color_fill[2],my_color_fill[3])) +
  theme_paul


ggplot(data = results_PhoCAssPaNS_df, aes(x = predicted_q_L, y = totalFAME)) +
  geom_point(aes(color = lightClass, shape = concentrationClass), size = 3,stroke = 1.25) +
  geom_errorbar(aes(ymin = totalFAME*(1 - totalFame_rel_error),
                    ymax = totalFAME*(1 + totalFame_rel_error))) +
  geom_abline( slope = 1, intercept = 0,colour = "red", linewidth = 2 , linetype = "dashed") +
  scale_shape_manual(values = c(21,23,24)) +
  theme_paul + 
  scale_color_manual(values = c(my_color_fill[1],my_color_fill[2],my_color_fill[3])) +
  scale_fill_manual(values = c(my_color_fill[1],my_color_fill[2],my_color_fill[3])) +
  theme_paul


ggplot(data = results_PhoCAssPaNS_df, aes(x = predicted_q_P_cell, y = totalProteinCell)) +
  geom_point(aes(color = lightClass, shape = concentrationClass), size = 3,stroke = 1.25) +
  geom_errorbar(aes(ymin = totalProteinCell*(1 - totalProteinCell_rel_error),
                    ymax = totalProteinCell*(1 + totalProteinCell_rel_error))) +
  geom_abline( slope = 1, intercept = 0,colour = "red", linewidth = 2 , linetype = "dashed") +
  scale_shape_manual(values = c(21,23,24)) +
  theme_paul + 
  scale_y_log10() + 
  scale_x_log10() +
  scale_color_manual(values = c(my_color_fill[1],my_color_fill[2],my_color_fill[3])) +
  scale_fill_manual(values = c(my_color_fill[1],my_color_fill[2],my_color_fill[3])) +
  theme_paul


ggplot(data = results_PhoCAssPaNS_df, aes(x = predicted_q_CHO_cell, y = totalSugarsCell)) +
  geom_point(aes(color = lightClass, shape = concentrationClass), size = 3,stroke = 1.25) +
  geom_errorbar(aes(ymin = totalSugarsCell*(1 - totalSugarsCell_rel_error),
                    ymax = totalSugarsCell*(1 + totalSugarsCell_rel_error))) +
  geom_abline( slope = 1, intercept = 0,colour = "red", linewidth = 2 , linetype = "dashed") +
  scale_shape_manual(values = c(21,23,24)) +
  theme_paul + 
  scale_y_log10() + 
  scale_x_log10() +
  scale_color_manual(values = c(my_color_fill[1],my_color_fill[2],my_color_fill[3])) +
  scale_fill_manual(values = c(my_color_fill[1],my_color_fill[2],my_color_fill[3])) +
  theme_paul


ggplot(data = results_PhoCAssPaNS_df, aes(x = predicted_q_L_cell, y = totalFAMECell)) +
  geom_point(aes(color = lightClass, shape = concentrationClass), size = 3,stroke = 1.25) +
  geom_errorbar(aes(ymin = totalFAMECell*(1 - totalFAMECell_rel_error),
                    ymax = totalFAMECell*(1 + totalFAMECell_rel_error))) +
  geom_abline( slope = 1, intercept = 0,colour = "red", linewidth = 2 , linetype = "dashed") +
  scale_shape_manual(values = c(21,23,24)) +
  theme_paul + 
  scale_y_log10() + 
  scale_x_log10() +
  scale_color_manual(values = c(my_color_fill[1],my_color_fill[2],my_color_fill[3])) +
  scale_fill_manual(values = c(my_color_fill[1],my_color_fill[2],my_color_fill[3])) +
  theme_paul


ggplot(data = results_PhoCAssPaNS_df, aes(x = predicted_sigma683Mass, y = sigma683Mass)) +
  geom_point(aes(color = lightClass, shape = concentrationClass), size = 3,stroke = 1.25) +
  geom_errorbar(aes(ymin = sigma683Mass*(1 - sigma_rel_error),
                    ymax = sigma683Mass*(1 + sigma_rel_error))) +
  geom_abline( slope = 1, intercept = 0,colour = "red", linewidth = 2 , linetype = "dashed") +
  scale_shape_manual(values = c(21,23,24)) +
  theme_paul + 
  scale_color_manual(values = c(my_color_fill[1],my_color_fill[2],my_color_fill[3])) +
  scale_fill_manual(values = c(my_color_fill[1],my_color_fill[2],my_color_fill[3])) +
  theme_paul


ggplot(data = results_PhoCAssPaNS_df, aes(x = predicted_Pm, y = PmMass)) +
  geom_point(aes(color = lightClass, shape = concentrationClass), size = 3,stroke = 1.25) +
  geom_errorbar(aes(ymin = PmMassMin,
                    ymax = PmMassMax)) +
  geom_abline( slope = 1, intercept = 0,colour = "red", linewidth = 2 , linetype = "dashed") +
  scale_shape_manual(values = c(21,23,24)) +
  theme_paul + 
  scale_color_manual(values = c(my_color_fill[1],my_color_fill[2],my_color_fill[3])) +
  scale_fill_manual(values = c(my_color_fill[1],my_color_fill[2],my_color_fill[3])) +
  theme_paul


ggplot(data = results_PhoCAssPaNS_df, aes(x = predicted_cnRatio, y = cnRatio)) +
  geom_point(aes(color = lightClass, shape = concentrationClass), size = 3,stroke = 1.25) +
  geom_errorbar(aes(ymin = cnRatio*(1 - sqrt(tocSpecific_rel_error^2 + totalProtein_rel_error^2)),
                    ymax = cnRatio*(1 + sqrt(tocSpecific_rel_error^2 + totalProtein_rel_error^2)))) +
  geom_abline( slope = 1, intercept = 0,colour = "red", linewidth = 2 , linetype = "dashed") +
  scale_shape_manual(values = c(21,23,24)) +
  theme_paul + 
  scale_color_manual(values = c(my_color_fill[1],my_color_fill[2],my_color_fill[3])) +
  scale_fill_manual(values = c(my_color_fill[1],my_color_fill[2],my_color_fill[3])) +
  theme_paul


ggplot(data = results_PhoCAssPaNS_df, aes(x = predicted_q_P + predicted_q_CHO + predicted_q_L ,
                                 y = totalProtein + totalSugars + totalFAME )) +
  geom_point(aes(color = lightClass, shape = concentrationClass), size = 3,stroke = 1.25) +
  geom_errorbar(aes(ymin = totalProtein + totalSugars + totalFAME - 
                      sqrt((totalProtein_rel_error*totalProtein)^2 +
                             (totalSugars_rel_error*totalSugars)^2 + 
                             (totalFame_rel_error*totalFAME)^2),
                    ymax = totalProtein + totalSugars + totalFAME + 
                      sqrt((totalProtein_rel_error*totalProtein)^2 +
                             (totalSugars_rel_error*totalSugars)^2 + 
                             (totalFame_rel_error*totalFAME)^2))) +
  geom_abline( slope = 1, intercept = 0,colour = "red", linewidth = 2 , linetype = "dashed") +
  scale_shape_manual(values = c(21,23,24)) +
  theme_paul + 
  scale_color_manual(values = c(my_color_fill[1],my_color_fill[2],my_color_fill[3])) +
  scale_fill_manual(values = c(my_color_fill[1],my_color_fill[2],my_color_fill[3])) +
  theme_paul


ggplot(data = results_PhoCAssPaNS_df, aes(x = predicted_q_P_cell*predicted_nAlgae, 
                                       y = totalProteinCell*cellCount*1000)) +
  geom_point(aes(color = lightClass, shape = concentrationClass), 
             size = 3, stroke = 1.25) +
  geom_errorbar(aes(ymin = totalProteinCell*cellCount*1000*
                      (1 - sqrt(cellCount_rel_error^2 + totalProteinCell_rel_error^2)),
                    ymax = totalProteinCell*cellCount*1000*
                      (1 + sqrt(cellCount_rel_error^2 + totalProteinCell_rel_error^2)))) +
  geom_abline( slope = 1, intercept = 0,colour = "red", linewidth = 2 , linetype = "dashed") +
  scale_shape_manual(values = c(21,23,24)) +
  theme_paul + 
  scale_y_log10() + 
  scale_x_log10() +
  scale_color_manual(values = c(my_color_fill[1],my_color_fill[2],my_color_fill[3])) +
  scale_fill_manual(values = c(my_color_fill[1],my_color_fill[2],my_color_fill[3])) +
  theme_paul

validationPlot_totalCHO <- 
  ggplot(data = results_PhoCAssPaNS_df, aes(x = predicted_q_CHO_cell*predicted_nAlgae, 
                                         y = totalSugarsCell*cellCount*1000)) +
    geom_point(aes(color = lightClass, shape = concentrationClass), size = 3,stroke = 1.25) +
    geom_errorbar(aes(ymin = totalSugarsCell*cellCount*1000*
                        (1 - sqrt(cellCount_rel_error^2 + totalSugarsCell_rel_error^2)),
                      ymax = totalSugarsCell*cellCount*1000*
                        (1 + sqrt(cellCount_rel_error^2 + totalSugarsCell_rel_error^2))),
                  width = 0.05) +
    geom_abline( slope = 1, intercept = 0,colour = "red", linewidth = 2 , linetype = "dashed") +
    scale_shape_manual(values = c(21,23,24)) +
    labs(title = "c)",
         x = expression(bold(atop("Predicted total carbohydrates",
                                        paste("(g carbohydrates.L"^"-1",")")))),
         y = expression(bold(atop("Measured total carbohydrates",
                                        paste("(g carbohydrates.L"^"-1",")"))))) +
    theme_paul + 
    scale_y_log10() + 
    scale_x_log10() +
    scale_color_manual(values = c(my_color_fill[1],my_color_fill[2],my_color_fill[3])) +
    scale_fill_manual(values = c(my_color_fill[1],my_color_fill[2],my_color_fill[3])) +
    theme_paul

validationPlot_totalCHO


validationPlot_totalLipids <- 
  ggplot(data = results_PhoCAssPaNS_df, aes(x = predicted_q_L_cell*predicted_nAlgae,
                                         y = totalFAMECell*cellCount*1000)) +
    geom_point(aes(color = lightClass, shape = concentrationClass), size = 3,stroke = 1.25) +
    geom_errorbar(aes(ymin = totalFAMECell*cellCount*1000*
                        (1 - sqrt(cellCount_rel_error^2 + totalFAMECell_rel_error^2)),
                      ymax = totalFAMECell*cellCount*1000*
                        (1 + sqrt(cellCount_rel_error^2 + totalFAMECell_rel_error^2))),
                  width = 0.05) +
    geom_abline( slope = 1, intercept = 0,colour = "red", linewidth = 2 , linetype = "dashed") +
    scale_shape_manual(values = c(21,23,24)) +
    labs(title = "d)",
         x = expression(bold(atop("Predicted total lipids",
                                        paste("(g lipids.L"^"-1",")")))),
         y = expression(bold(atop("Measured total lipids",
                                        paste("(g lipids.L"^"-1",")"))))) +
    theme_paul + 
    scale_y_log10() + 
    scale_x_log10() +
    scale_color_manual(values = c(my_color_fill[1],my_color_fill[2],my_color_fill[3])) +
    scale_fill_manual(values = c(my_color_fill[1],my_color_fill[2],my_color_fill[3])) +
    theme_paul


validationPlot_totalLipids


```

```{r, echo = include_code, fig.width = 12, fig.height = 10}

## Putting the legend in common (based on https://stackoverflow.com/questions/13649473/add-a-common-legend-for-combined-ggplots )

validationPlot_totalLipids <- validationPlot_totalLipids +
  theme(legend.box = "vertical")

g_legend <- function(a.gplot){
  tmp <- ggplot_gtable(ggplot_build(a.gplot))
  leg <- which(sapply(tmp$grobs, function(x) x$name) == "guide-box")
  legend <- tmp$grobs[[leg]]
  return(legend)
}

mylegend <- g_legend(validationPlot_totalLipids)


# finalValidationPlot <-
  grid.arrange(arrangeGrob(validationPlot_dryweight + theme(legend.position="none"),
                           validationPlot_cellCount + theme(legend.position="none"),
                           validationPlot_totalCHO  + theme(legend.position="none"),
                           validationPlot_totalLipids + theme(legend.position="none"),
                           nrow=2),
               mylegend,ncol = 2,widths = c(5,1))

```

## R2 of main metrics

```{r, echo = include_code}
# Dryweight


SS_res <- sum((results_PhoCAssPaNS_df$dryWeight - results_PhoCAssPaNS_df$predicted_xAlgae)^2 , na.rm = TRUE)
SS_tot <- sum((results_PhoCAssPaNS_df$dryWeight - mean(results_PhoCAssPaNS_df$dryWeight,na.rm = TRUE))^2 , na.rm = TRUE)
R2_dryweight <- 1 - SS_res/SS_tot 

MRE_dryweight <- mean(abs((results_PhoCAssPaNS_df$dryWeight - results_PhoCAssPaNS_df$predicted_xAlgae)/results_PhoCAssPaNS_df$dryWeight),na.rm = TRUE)


# Global lipids

SS_res <- sum((results_PhoCAssPaNS_df$totalFAMECell*results_PhoCAssPaNS_df$cellCount*1000 -
                 results_PhoCAssPaNS_df$predicted_q_L_cell*results_PhoCAssPaNS_df$predicted_nAlgae)^2 ,
              na.rm = TRUE)
SS_tot <- sum((results_PhoCAssPaNS_df$totalFAMECell*results_PhoCAssPaNS_df$cellCount*1000 -
                 mean(results_PhoCAssPaNS_df$totalFAMECell*results_PhoCAssPaNS_df$cellCount*1000,
                      na.rm = TRUE))^2 ,
              na.rm = TRUE)
R2_lipids <- 1 - SS_res/SS_tot 
MRE_lipids <- mean(abs((results_PhoCAssPaNS_df$totalFAMECell*results_PhoCAssPaNS_df$cellCount*1000 -
                         results_PhoCAssPaNS_df$predicted_q_L_cell*results_PhoCAssPaNS_df$predicted_nAlgae)/
                     (results_PhoCAssPaNS_df$totalFAMECell*results_PhoCAssPaNS_df$cellCount*1000)),na.rm = TRUE)

# CHO

SS_res <- sum((results_PhoCAssPaNS_df$totalSugarsCell*results_PhoCAssPaNS_df$cellCount*1000 -
                 results_PhoCAssPaNS_df$predicted_q_CHO_cell*results_PhoCAssPaNS_df$predicted_nAlgae)^2 ,
              na.rm = TRUE)
SS_tot <- sum((results_PhoCAssPaNS_df$totalSugarsCell*results_PhoCAssPaNS_df$cellCount*1000 -
                 mean(results_PhoCAssPaNS_df$totalSugarsCell*results_PhoCAssPaNS_df$cellCount*1000,
                      na.rm = TRUE))^2 ,
              na.rm = TRUE)
R2_CHO <- 1 - SS_res/SS_tot 
MRE_CHO <- mean(abs((results_PhoCAssPaNS_df$totalSugarsCell*results_PhoCAssPaNS_df$cellCount*1000 -
                       results_PhoCAssPaNS_df$predicted_q_CHO_cell*results_PhoCAssPaNS_df$predicted_nAlgae)/
                      (results_PhoCAssPaNS_df$totalSugarsCell*results_PhoCAssPaNS_df$cellCount*1000)),na.rm = TRUE)

# Cell count

SS_res <- sum((results_PhoCAssPaNS_df$cellCount - results_PhoCAssPaNS_df$predicted_nAlgae/1000)^2 , na.rm = TRUE)
SS_tot <- sum((results_PhoCAssPaNS_df$cellCount - mean(results_PhoCAssPaNS_df$cellCount,na.rm = TRUE))^2 , na.rm = TRUE)
R2_cellcount <- 1 - SS_res/SS_tot 


R2_dryweight
MRE_dryweight
R2_lipids
MRE_lipids
R2_CHO
MRE_CHO
R2_cellcount

```
# Sensitivity analysis

## Initialisation and sensitivity loop

```{r , echo = TRUE}

# Parameter table

# We create a table of parameters "table_parameters" for which each line correpsond to a parameter which will be varied individually for sensitivity analysis. The first column corresponds to the central or base value, and the second and third columns respectively correspond to the lower and higher uncertainty values (when varying of one standard deviation if the uncertainy is based on regression or statistical analysis).

# The order of the parameters for each line is as follows:
  # d_reactor <=> 1
  # r_reactor <=> 2
  # angle_eflask <=> 3
  # Y_X_C <=> 4
  # Y_C_L <=> 5
  # Y_C_P <=> 6
  # lambda_decay <=> 7
  # Pm_0_exp <=> 8
  # cnRatio_char <=> 9
  # gamma_Pm <=> 10
  # sigma_max <=> 11
  # K_qP <=> 12
  # lambda_CHO <=> 13
  # µ_max_exp <=> 14
  # alpha_qp_char_cellDiv <=> 15
  # beta_qp_char_cellDiv <=> 16
  # q_CHO_cell_max_global <=> 17
  # p_L_cell_max <=> 18
  # I0 <=> 19
  # Volume_change <=> 20
  # alpha_PI <=> 21
  # K2_mass <=> 22

# Due to low sensitivity, the value for n_iter in base case was lowered to 100.

table_parameters = matrix(data = c(0.0556	,	0.054181633	,	0.057018367	,
                                   0.06	,	0.058469388	,	0.061530612	,
                                   1.396263	,	1.360644046	,	1.431881954	,
                                   1.92019	,	1.89019	,	1.95019	,
                                   0.8522	,	0.85165886	,	0.85274114	,
                                   0.6579	,	0.657482222	,	0.657899735	,
                                   -1.440638E-07 ,	-1.979990E-07 ,	-9.012861E-08,
                                   0.0009103757	,	0.000878376	,	0.000942376	,
                                   2.746015	,	2.43	,	3.07	,
                                   -2.884479	,	-3.01	,	-2.75	,
                                   0.9564742	,	0.927	,	0.985	,
                                   0.1424641	,	0.13	,	0.152	,
                                   6.624711E-11	,	5.21907E-11	,	8.02596E-11	,
                                   4.253194E-05	,	3.7963E-05	,	4.69907E-05	,
                                   -4.526242E-13	,	-7.97E-13	,	-1.09E-13	,
                                   2.253142E-11	,	1.95E-11	,	2.55E-11	,
                                   4.470671E-12	,	4.23E-12	,	4.71E-12	,
                                   3.29502E-17	,	8.5E-13	,	4.85E-12	,
                                   2.20E+02	,	1.98E+02	,	2.42E+02	,
                                   1	,	0.95	,	1.05	,
                                   171885.4	,	166706.8014	,	177063.9986	,
                                   9.593525	,	8.8804	,	10.24),
                          ncol=3,byrow = TRUE)

# A table to register the results is created

table_results_SA <- matrix(NA, nrow = 45, ncol = 6)

# The sensitivity calculation loop is now implemented. For each turn of the loop, a list of parameter is created in the order previously given extracted from table_parameters matrix. This list of parameters present the central value for all parameters with one parameter being varied alternatively to its lower uncertainty and to its upper uncertainty. The first loop is carried out implementing only central values.

for(i_sensitivity in (1:45)){
  # Selection of parameter list
  local_parameters_list <- table_parameters[,1]
  
  if (i_sensitivity >= 2){
    local_parameters_list[floor(i_sensitivity/2)] <- table_parameters[floor(i_sensitivity/2),2 + i_sensitivity %% 2]
  }


  # General parameters------------------------------------------------------------
  
  n_iter = 100 # number of iterations
  n_mesh = 50 # mesh subdivision for discrete modelling of E-flasks
  dt = 16/n_iter # time step (day)
  simulation_df <- data.frame(time = seq(0,n_iter*dt,dt))
  
  
  # Operative parameters
  ## d_reactor : initial reactor depth (m)
  ## r_reactor : reactor radius (m)
  ## angle_eflask : inclination of the side of the erlen (radians)
    
  d_reactor = local_parameters_list[1]
  r_reactor = local_parameters_list[2]
  angle_eflask = local_parameters_list[3]
  
  # Initial reactor volume is computed (V_reactor_0, L)
  V_reactor_0 = 1/3*pi*r_reactor^3*tan(angle_eflask)*(1-(1-d_reactor/(r_reactor*tan(angle_eflask)))^3)*1000
  
  # Yield parameters
  ## Y_CHO_O2: yield of glucose per production of O2 during phtotsynthesis (g CHO/g O2)
  ## Y_C_CHO: content of carbon in biomass carbohydrates (g C/g CHO)
  ## Y_X_C : biomass to carbon yield during biomass growth (g DW/g C) 
  ## Y_C_L : content of carbon in  biomass lipids (g C/g Lipids)
  ## Y_C_P : content of carbon in  biomass proteins (g C/g Proteins)
  
  Y_CHO_O2 <- 4/32*180/24
  Y_C_CHO <- 0.439
  Y_X_C <-  local_parameters_list[4]
  Y_C_L <- local_parameters_list[5]
  Y_C_P <- local_parameters_list[6]
  
  
  # Cell parameters
  ## This regroups all model constants necessary for predictions
  ### lambda_decay: decay rate (g C/(g DW.s))
  ### Pm_0 : Theoretical maximum specific photosynthetic rate of O2 production (g 02/(g DW.s.[g N/g C]))
  ### cnRatio_char : characteristic C:N ratio of the decrease of photosynthetic activity for increasing C:N ratio (g C/(g N))
  ### sigma_max : max light extinction coefficient (m2/g DW)
  ### K_qp : affinity constant of light extinction coefficient toward protein mass quota (g P/g cell)
  ### lambda_CHO: carbohydrates cell quota characteristic for light absorption (g CHO/cell)
  ### µ_max_exp : maximum cell division rate (s-1)
  ### alpha_qp_char_cellDiv: slope of the linear regression between the characteristic protein quota for cell division and the light density in the reactor (g P.gDW.S/(cell.µmol))
  ### beta_qp_char_cellDiv : intercept of the linear regression between the characteristic protein quota for cell division and the light density in the reactor (g P.cell-1)
  ### q_CHO_cell_max_global : maximum carbohydrate cell quota prior to conversion of carbon to lipids (g CHO/cell)
  ### p_L_cell_max : maximum rate of production of lipid for a single cell (g Lipid/cell/s)
  
  lambda_decay = local_parameters_list[7]
  Pm_0_exp = local_parameters_list[8]
  cnRatio_char = local_parameters_list[9]
  gamma_Pm = local_parameters_list[10]
  sigma_max = local_parameters_list[11]
  K_qP = local_parameters_list[12]
  lambda_CHO = local_parameters_list[13]
  µ_max_exp = local_parameters_list[14]
  alpha_qp_char_cellDiv = local_parameters_list[15]
  beta_qp_char_cellDiv = local_parameters_list[16]
  q_CHO_cell_max_global = local_parameters_list[17]
  p_L_cell_max = local_parameters_list[18]
  
  
  
  # Initialization tables
  
  
  
  ## The cell metabolic state and the culture conditions are initialized. 
  ### q_P_0 : Initial protein quota (g Protein/g dryweight)
  ### q_L_0 : Initial lipid quota (g Lipids/g dryweight)
  ### q_CHO_0 : Initial carbohydrates quota (g Carbohydrates/g dryweight)
  ### N_0 : Initial cell count (cell/L)
  ### X_0 : Initial dry weight (g/L)
  
  q_P_0 = 0.69
  q_L_0 = 0.10
  q_CHO_0 = 0.13
  
  N_0_table = c(2.49*10^9 , 7.47*10^9 , 2.73*10^10)
  X_0_table = c(0.101 , 0.303 , 1.11)
  
  
  ## Light conditions initialization
  ### Global initial light intensity (I0, µmol/m2/s)
  I_0 = local_parameters_list[19]
  ### The light/dark period is determined for the corresponding lines of the time vector (day_vector, binary =1 if day, = 0 if night)
  day_vector <- rep(1,nrow(simulation_df))
  day_vector[(((simulation_df$time - floor(simulation_df$time)) < 11/24) & ((simulation_df$time - floor(simulation_df$time)) > 7/24))] <- 0
  ### Matrix of light intensity (I_0_table): a matrix is created gathering light intensity for the trhee different types of reactor (75% light intensity filter, 50% light intensity filter, no filter) including the dark/light period.
  I_O_vector <- day_vector*I_0
  I_0_table <- matrix(c(0.25*I_O_vector, 0.5*I_O_vector , I_O_vector), ncol = 3)
  
  ## Matrix of the volume of the reactor
  ### V_reactor_0_table: vector of volume variations according to time, initiliazed with the initial value V_reactor_0
  ### The volume variations due to sampling must be accounted for in order to recreate the experimental conditions. The values reported on each sampling and corresponding dates from the start are gathered in a matrix (matrix_volume_change)
  
  V_reactor_0_table <- c(V_reactor_0,rep(NA,nrow(simulation_df)-1))
  matrix_volume_change <- local_parameters_list[20]*
    matrix(c(c(0.75,1.75,3.75,7.75,9.75,13.75,15.75),
             c(0.470,0.390,0.310,0.230,0.150,NA,NA),
             c(0.500,0.450,0.400,0.350,0.300,0.220,0.165),
             c(0.500,0.450,0.400,0.350,0.300,0.250,0.200)),
           ncol = 4)
  
  alpha_PI = local_parameters_list[21]
  K2_mass = local_parameters_list[22]
  
  factor_protein <- 5.04
  
  ## Loop of experiment simulation: the loop performed for model fitness determination is now reproduced for the new values of the parameters.
  
  # A list is created to save the data frame of the results of the simulation for each reactor (list_simulation)
  list_simulation <- list()
  
  # A loop is now performed per reactor
  for (i_concentration in (1:3)){
    for (j_light in (1:3)){
  
      # Initialisation of the cell count and dryweight concentration
      N_0 = N_0_table[i_concentration]
      X_0 = X_0_table[i_concentration]
        
      # Creation of the data frame in which will be reported all the current loop results
      ## The data frame initially only contains the time vector on which data points will be determined
      simulation_df <- data.frame(time = seq(0,n_iter*dt,dt))
    
      # Initialisation of the data set
      ## Needed variables that will be included in the data frame for the current loop are created and initialised according to the real experimental data
      ## Incident light intensity (the values over the complete experiment are directly implemented)
      simulation_df$I0 <- I_0_table[,j_light]
      ## Dry-weight concentration (g/L)
      simulation_df$xAlgae <- c(X_0,rep(NA,nrow(simulation_df)-1))
      ## Algae cell count (cell/L)
      simulation_df$nAlgae <- c(N_0,rep(NA,nrow(simulation_df)-1))
      ## Proteins mass quota (g Proteins/g dry-weight)
      simulation_df$q_P <- c(q_P_0,rep(NA,nrow(simulation_df)-1))
      ## Lipids mass quota (g Lipids/g dry-weight)
      simulation_df$q_L <- c(q_L_0,rep(NA,nrow(simulation_df)-1))
      ## Carbohydrates mass quota (g Carbohydrates/g dry-weight)
      simulation_df$q_CHO <- c(q_CHO_0,rep(NA,nrow(simulation_df)-1))
      ## Proteins cell quota (g Proteins/cell)
      simulation_df$q_P_cell <- c(q_P_0*X_0/N_0,rep(NA,nrow(simulation_df)-1))
      ## Lipids cell quota (g Lipids/cell)
      simulation_df$q_L_cell <- c(q_L_0*X_0/N_0,rep(NA,nrow(simulation_df)-1))
      ## Carbohydrate cell quota (g Carbohydrates/cell)
      simulation_df$q_CHO_cell <- c(q_CHO_0*X_0/N_0,rep(NA,nrow(simulation_df)-1))
      
      # The rest of the variables needed in the simulation but which are not initialised according to experimental measurements are also included.
      ## C:N ratio in the biomass (g C/g N)
      simulation_df$cnRatio <- rep(NA,nrow(simulation_df))
      ## Mass specific light extinction coefficient (m2/g dry-weight)
      simulation_df$sigma683Mass <- rep(NA,nrow(simulation_df))
      ## Specific maximum photosynthetic rate of O2 production (g 02/g dry-weight/s)
      simulation_df$Pm <- rep(NA,nrow(simulation_df))
      ## Light density in the reactor (µmol/(gDW.S))
      simulation_df$lightDensity <- rep(NA,nrow(simulation_df))
      
      # Loop of calculation
      for (i_simul in (1:(n_iter))){
        # Calculation initilalization for the current time step
        ## Initialisation from previous determination
        q_P_local = simulation_df$q_P[i_simul]
        q_L_local = simulation_df$q_L[i_simul]
        q_CHO_local = simulation_df$q_CHO[i_simul]
        q_P_cell_local = simulation_df$q_P_cell[i_simul] # g Prot/cell
        q_CHO_cell_local = simulation_df$q_CHO_cell[i_simul] # g CHO/cell
        q_L_cell_local = simulation_df$q_L_cell[i_simul] # g Lip/cell
        I0_local <- simulation_df$I0[i_simul] # µmol/m2/s
        X_algae_local <- simulation_df$xAlgae[i_simul] #g/L
        N_algae_local <- simulation_df$nAlgae[i_simul] #cell/L
        
        ## Volume calculation
        ### The current volume (V_reactor_local) is determined by comparing the current time to the time of volume change in the reference matrix
        ### Volume change from previous time step is also calculated
        if (simulation_df$time[i_simul] < matrix_volume_change[1,1]){
          V_reactor_local <- V_reactor_0
          delta_V_local <- 0
        }else{
          V_reactor_old <- V_reactor_local
          V_reactor_local <- matrix_volume_change[max(which(matrix_volume_change[,1] < simulation_df$time[i_simul])),i_concentration + 1]
          # We try to find the index of matrix_volume_change corresponding to the actual volume
          delta_V_local <- V_reactor_local - V_reactor_old
          if (is.na(V_reactor_local)){
            delta_V_local <- 0
            V_reactor_local <- V_reactor_0
          }
        }
        ## Reactor depth of the current time is computed from the volume determined
        reactor_depth_local <- r_reactor*tan(angle_eflask) - 
          ((r_reactor*tan(angle_eflask))^3 -
             3/pi*(V_reactor_local/1000)*(tan(angle_eflask))^2)^(1/3)
    
        # The time step is computed for Euler-type calculations
        dt_local <- (simulation_df$time[i_simul+1] - simulation_df$time[i_simul])*24*3600 # into seconds
        
        ## Initialisation of variiables from model equations 
        cn_ratio_local = (Y_C_CHO*q_CHO_local + Y_C_P*q_P_local + Y_C_L*q_L_local)/(1/factor_protein*q_P_local)
        # Pm_local = Pm_0*exp(-cn_ratio_local/cnRatio_char)
        Pm_local = Pm_0_exp*(cn_ratio_local/cnRatio_char)^(gamma_Pm)
        sigma683Mass_local = sigma_max*q_P_local/(K_qP+q_P_local) - q_CHO_cell_local/lambda_CHO
        lightDensity_local = I0_local/(reactor_depth_local*X_algae_local*1000)*
          (1 - exp(-sigma683Mass_local*X_algae_local*1000*reactor_depth_local)) # µmol/g/s
  
          
        ## Implementation in the data frame of the modeled variables computed for the current time step
        simulation_df$sigma683Mass[i_simul] <- sigma683Mass_local
        simulation_df$Pm[i_simul] <- Pm_local
        simulation_df$cnRatio[i_simul] <- cn_ratio_local
        simulation_df$lightDensity[i_simul] <- lightDensity_local
          
        # Calculation of carbon absorbed on the current time step----------------- 
        
        eflask_base_tensor = array(data = rep(NA,(n_mesh+1)^3), dim = c(n_mesh+1,n_mesh+1,n_mesh+1))
        
        z_coordinates = seq(0,reactor_depth_local,reactor_depth_local/n_mesh)
        teta_coordinates = seq(0,2*pi,2*pi/n_mesh)
        r_coordinates <- seq(0,r_reactor - reactor_depth_local/tan(angle_eflask),(r_reactor - reactor_depth_local/tan(angle_eflask))/n_mesh)
          
        r_coordinates_tensor <- eflask_base_tensor
        teta_coordinates_tensor <- eflask_base_tensor
        z_coordinates_tensor <- eflask_base_tensor
      
        for (i in 1:(n_mesh + 1)){
          for (j in 1:(n_mesh + 1)){
            for (k in 1:(n_mesh + 1)){
              # Assigning coordinates for each point inside the volume of the e-flask
              r_seq <- seq(0,r_reactor - (reactor_depth_local - z_coordinates[k])/tan(angle_eflask),(r_reactor - (reactor_depth_local - z_coordinates[k])/tan(angle_eflask))/n_mesh)
              r_coordinates_tensor[i,j,k] <- r_seq[i]
              teta_coordinates_tensor[i,j,k] <- teta_coordinates[j]
              z_coordinates_tensor[i,j,k] <- z_coordinates[k]
            }
          }
        }
        
        ## Tensor for the corresponding coordinates are created for local light intensity (I_distribution_local) and local O2 photosynthetic production (P_O2_spec_local)
        I_distribution_local <- eflask_base_tensor
        P_O2_spec_local <- eflask_base_tensor
  
        ## Local light intensity determination
        for (iv in 1:(n_mesh)){
          for (jv in 1:(n_mesh)){
            for (kv in 1:(n_mesh)){
              
              # local point coordinates based on the middle point between consecutive coordinates
              r_local = (r_coordinates_tensor[iv,jv,kv] + r_coordinates_tensor[iv+1,jv,kv])/2
              teta_local = (teta_coordinates_tensor[iv,jv,kv] + teta_coordinates_tensor[iv,jv+1,kv])/2
              z_local = (z_coordinates_tensor[iv,jv,kv] + z_coordinates_tensor[iv,jv,kv+1])/2
              
              # Depth from the top of the e-flask vertically to the point (rk : positive toward the bottom)
              r_lim <- r_reactor - reactor_depth_local/tan(angle_eflask) # Limit of the "non conical" part of the broth
              if (r_local <= r_lim){
                z_s <- z_local
              }else{
                z_s <- z_local - (r_local - r_lim)*tan(angle_eflask)
              }
              I_distribution_local[iv,jv,kv] <- I0_local*exp(-sigma683Mass_local*X_algae_local*1000*z_s)
            }
          }
        }
        
        ## Gross O2 production calculation
        ### We apply the formula of photosynthetic oxygen productivity for all local volumes based on local intensities
        for (iv in 1:(n_mesh)){
          for (jv in 1:(n_mesh)){
            for (kv in 1:(n_mesh)){
                # Calculation of local volume value
                dV <- (r_coordinates_tensor[iv+1,jv,kv] + r_coordinates_tensor[iv,jv,kv])/2*(r_coordinates_tensor[iv+1,jv,kv] - r_coordinates_tensor[iv,jv,kv])*
                  (teta_coordinates_tensor[iv,jv+1,kv] - teta_coordinates_tensor[iv,jv,kv])*
                  (z_coordinates_tensor[iv,jv,kv+1] - z_coordinates_tensor[iv,jv,kv])
                # Local O2 production (gO2 produced over dt)
                P_O2_spec_local[iv,jv,kv] <- 
                  Pm_local* sigma683Mass_local*(X_algae_local)*I_distribution_local[iv,jv,kv]/
                        (alpha_PI*Pm_local +  sigma683Mass_local*X_algae_local*I_distribution_local[iv,jv,kv] + (1/K2_mass)*(sigma683Mass_local*X_algae_local*I_distribution_local[iv,jv,kv])^2)*
                      X_algae_local*(10^3)*dV*dt_local
            }
          }
        }
        ### Global volumic O2 production is calculated as the sum of all the local O2 production divided by the total volume (g O2/L)
        P_O2_gross_local <- sum(P_O2_spec_local,na.rm = TRUE)/V_reactor_local 
        
        ## Net carbon assimilation
        ### Carbon assimilated by photosynthesis (g CHO/L over dt)
        CHO_photosynthesis_local <- P_O2_gross_local*Y_CHO_O2
        
        ### Gross CHO respiration consumption (g CHO/L over dt)
        CHO_respiration_gross_local <- 1/Y_C_CHO*lambda_decay*X_algae_local*dt_local 
        
        ### Net CHO productivity (g CHO/L/d)
        P_CHO_net_local <- (CHO_photosynthesis_local - CHO_respiration_gross_local)/dt_local
        
        
        # Cell division prediction----------------------------------------------------
        ## Instantaneous division rate is computed from mathematical model, and cell count evolution is determined based on Euler method
        µ_local <- µ_max_exp*
          exp(-(alpha_qp_char_cellDiv*lightDensity_local+beta_qp_char_cellDiv)/q_P_cell_local)
        N_algae_calc <- N_algae_local*(1 + µ_local*dt_local)
      
        
        # Carbon partition model-------------------------------------------------------------
        ## Protein quota
        ### Protein quota is simply computed based on a constant total protein quota and the increase of biomass dryweight and total cell
        q_P_cell_calc <- q_P_cell_local*N_algae_local/N_algae_calc
        
        ## CHO and lipids
        ### We first compute theoretical (P_L_aux_local) and maximal possible (P_L_max_local) productivities for lipids
        
        P_L_aux_local <- Y_C_CHO/Y_C_L*P_CHO_net_local
        P_L_max_local <- p_L_cell_max*N_algae_local
        
        ### Diverging scenarios for lipid production
        #### 1) Consumption of internal carbohydrates => all consumption is on carbohydrate quota
        if (P_CHO_net_local < 0){
          P_L_local <- 0
          P_CHO_local <- P_CHO_net_local
        }else{
        #### 2) The cells after division and newly assimilated carbon are not over the basal cell quota in carbohydarte => all carbon assimilation goes to carbohydrates
          if (q_CHO_cell_local < q_CHO_cell_max_global){ 
            P_L_local <- 0
            P_CHO_local <- P_CHO_net_local
          }else{
            if (P_L_aux_local < P_L_max_local){
              # 3) Cells carbohydrates quota would opverpass the basal quota & the potential for lipid accumulation would not overpass the maximum cell lipid productivit (i.e. P_L_max_local > P_L_aux_local) => then all the cabon left to absorb is absorbed as lipid
              P_L_local <- P_L_aux_local
              P_CHO_local <- 0
            }else{
              # 3) Cells carbohydrates quota would opverpass the basal quota & the potential for lipid accumulation would overpass the maximum cell lipid productivit (i.e. P_L_max_local > P_L_aux_local) => then lipid are produced according to the maximum possible and the rest of the carbon is absorbed as carbohydrates
              P_L_local <- P_L_max_local
              P_CHO_local <- P_CHO_net_local - Y_C_L/Y_C_CHO*P_L_max_local
            }
          }
        }
  
        ### Calculation of new partition in cell quotas for lipids and carbohydrates
        q_L_cell_calc <- (q_L_cell_local*N_algae_local + P_L_local*dt_local)/N_algae_calc
        q_CHO_cell_calc <- (q_CHO_cell_local*N_algae_local + P_CHO_local*dt_local)/N_algae_calc
        
        # Biomass dryweight prediction------------------------------------------------
        ## New biomass dryweight
        X_algae_calc <- X_algae_local + 
          Y_X_C*(Y_C_CHO*P_CHO_local + Y_C_L*P_L_local)*dt_local 
        
        # Mass quota prediction---------------------------------------------------
        q_P_calc <- q_P_local*X_algae_local/X_algae_calc
        q_CHO_calc <- (q_CHO_local*X_algae_local + P_CHO_local*dt_local)/X_algae_calc
        q_L_calc <- (q_L_local*X_algae_local + P_L_local*dt_local)/X_algae_calc
            
      
        
        # Implementation of new data in the data frame----------------------------
        simulation_df$xAlgae[i_simul + 1] <- X_algae_calc
        simulation_df$nAlgae[i_simul + 1] <- N_algae_calc
        simulation_df$q_P[i_simul + 1] <- q_P_calc
        simulation_df$q_P_cell[i_simul + 1] <- q_P_cell_calc
        simulation_df$q_CHO[i_simul + 1] <- q_CHO_calc
        simulation_df$q_CHO_cell[i_simul + 1] <- q_CHO_cell_calc 
        simulation_df$q_L[i_simul + 1] <-  q_L_calc 
        simulation_df$q_L_cell[i_simul + 1] <- q_L_cell_calc
      }
        
      # Appending the reactor data to the list of experiment results
      list_simulation[[3*(i_concentration-1)+j_light]] <- simulation_df
      ## Due to the relatively large duration of the calculation, we here print the advancement of the calculation (in % of the total approx. time)
      print(paste(as.character((3*(i_concentration-1)+j_light)/9*100)," %"))
  
    }
  }
  
  ## Recuperation of data
  
  # For each reactor, predicted data are extracted to correspond to each measured data point. To achieve so, the time step included to the model which is closest to each given measurement is identified and the data for each variable of this time step is then collected from the predicted data base. The predicted results corresponding to each date of the measured data hence obtained are appended to the central data frame.
  
  
  for (i_val in (1:nrow(results_PhoCAssPaNS_df))){
    
    if (results_PhoCAssPaNS_df$concentrationClass[i_val] == "0.1 g.L-1"){
      i_concentration <- 1
    }else{
      if (results_PhoCAssPaNS_df$concentrationClass[i_val] == "0.3 g.L-1"){
        i_concentration <- 2
      }else{
        i_concentration <- 3
      }
    }
    
    if (results_PhoCAssPaNS_df$lightClass[i_val] == "25%"){
      j_light <- 1
    }else{
      if (results_PhoCAssPaNS_df$concentrationClass[i_val] == "0.3 g.L-1"){
        j_light <- 2
      }else{
        j_light <- 3
      }
    }
    
    local_simulation_df <- list_simulation[[3*(i_concentration-1)+j_light]]
    
    results_PhoCAssPaNS_df$predicted_xAlgae[i_val] <- 
      local_simulation_df$xAlgae[which(abs(local_simulation_df$time - results_PhoCAssPaNS_df$day[i_val]) == min(abs(local_simulation_df$time - results_PhoCAssPaNS_df$day[i_val])))]
    results_PhoCAssPaNS_df$predicted_nAlgae[i_val] <-
      local_simulation_df$nAlgae[which(abs(local_simulation_df$time - results_PhoCAssPaNS_df$day[i_val]) == min(abs(local_simulation_df$time - results_PhoCAssPaNS_df$day[i_val])))]
    results_PhoCAssPaNS_df$predicted_q_P[i_val] <- 
      local_simulation_df$q_P[which(abs(local_simulation_df$time - results_PhoCAssPaNS_df$day[i_val]) == min(abs(local_simulation_df$time - results_PhoCAssPaNS_df$day[i_val])))]
    results_PhoCAssPaNS_df$predicted_q_L[i_val] <- 
      local_simulation_df$q_L[which(abs(local_simulation_df$time - results_PhoCAssPaNS_df$day[i_val]) == min(abs(local_simulation_df$time - results_PhoCAssPaNS_df$day[i_val])))]
    results_PhoCAssPaNS_df$predicted_q_CHO[i_val] <- 
      local_simulation_df$q_CHO[which(abs(local_simulation_df$time - results_PhoCAssPaNS_df$day[i_val]) == min(abs(local_simulation_df$time - results_PhoCAssPaNS_df$day[i_val])))]
    results_PhoCAssPaNS_df$predicted_q_P_cell[i_val] <- 
      local_simulation_df$q_P_cell[which(abs(local_simulation_df$time - results_PhoCAssPaNS_df$day[i_val]) == min(abs(local_simulation_df$time - results_PhoCAssPaNS_df$day[i_val])))]
    results_PhoCAssPaNS_df$predicted_q_L_cell[i_val] <- 
      local_simulation_df$q_L_cell[which(abs(local_simulation_df$time - results_PhoCAssPaNS_df$day[i_val]) == min(abs(local_simulation_df$time - results_PhoCAssPaNS_df$day[i_val])))]
    results_PhoCAssPaNS_df$predicted_q_CHO_cell[i_val] <- 
      local_simulation_df$q_CHO_cell[which(abs(local_simulation_df$time - results_PhoCAssPaNS_df$day[i_val]) == min(abs(local_simulation_df$time - results_PhoCAssPaNS_df$day[i_val])))]
    results_PhoCAssPaNS_df$predicted_cnRatio[i_val] <- 
      local_simulation_df$cnRatio[which(abs(local_simulation_df$time - results_PhoCAssPaNS_df$day[i_val]) == min(abs(local_simulation_df$time - results_PhoCAssPaNS_df$day[i_val])))]
    results_PhoCAssPaNS_df$predicted_sigma683Mass[i_val] <- 
      local_simulation_df$sigma683Mass[which(abs(local_simulation_df$time - results_PhoCAssPaNS_df$day[i_val]) == min(abs(local_simulation_df$time - results_PhoCAssPaNS_df$day[i_val])))]
    results_PhoCAssPaNS_df$predicted_Pm[i_val] <- 
      local_simulation_df$Pm[which(abs(local_simulation_df$time - results_PhoCAssPaNS_df$day[i_val]) == min(abs(local_simulation_df$time - results_PhoCAssPaNS_df$day[i_val])))]
    
  }
  
  
  ## Validation verification plots
  
  # For each variable predicted, measured vs predicted values are plotted.
  
  validationPlot_dryweight <-
    ggplot(data = results_PhoCAssPaNS_df, aes(x = predicted_xAlgae, y = dryWeight)) +
      geom_point(aes(color = lightClass, shape = concentrationClass), size = 3,stroke = 1.25) +
      geom_abline( slope = 1, intercept = 0,colour = "red", linewidth = 2 , linetype = "dashed") +
      scale_shape_manual(values = c(21,23,24)) +
      labs(title = "a)",
           x = expression(bold(atop("Predicted biomass concentration",
                                          paste("(g dry-weight.L"^"-1",")")))),
           y = expression(bold(atop("Measured biomass concentration",
                                          paste("(g dry-weight.L"^"-1",")"))))) +
      theme_paul + 
      scale_color_manual(values = c(my_color_fill[1],my_color_fill[2],my_color_fill[3])) +
      scale_fill_manual(values = c(my_color_fill[1],my_color_fill[2],my_color_fill[3])) +
      theme_paul
  
  print(validationPlot_dryweight)
  
  
  validationPlot_cellCount <-
    ggplot(data = results_PhoCAssPaNS_df, aes(x = predicted_nAlgae, y = cellCount*1000)) +
      geom_point(aes(color = lightClass, shape = concentrationClass), size = 3,stroke = 1.25) +
      geom_abline( slope = 1, intercept = 0,colour = "red", linewidth = 2 , linetype = "dashed") +
      scale_shape_manual(values = c(21,23,24)) +
      labs(title = "b)",
           x = expression(bold(atop("Predicted biomass cell count",
                                          paste("(cell.L"^"-1",")")))),
           y = expression(bold(atop("Measured biomass cell count",
                                          paste("(cell.L"^"-1",")"))))) +
      theme_paul + 
      scale_y_log10() + 
      scale_x_log10() +
      scale_color_manual(values = c(my_color_fill[1],my_color_fill[2],my_color_fill[3])) +
      scale_fill_manual(values = c(my_color_fill[1],my_color_fill[2],my_color_fill[3])) +
      theme_paul
  
  print(validationPlot_cellCount)
  
  
  
  
  validationPlot_totalCHO <- 
    ggplot(data = results_PhoCAssPaNS_df, aes(x = predicted_q_CHO_cell*predicted_nAlgae, 
                                           y = totalSugarsCell*cellCount*1000)) +
      geom_point(aes(color = lightClass, shape = concentrationClass), size = 3,stroke = 1.25) +
      geom_abline( slope = 1, intercept = 0,colour = "red", linewidth = 2 , linetype = "dashed") +
      scale_shape_manual(values = c(21,23,24)) +
      labs(title = "c)",
           x = expression(bold(atop("Predicted total carbohydrates",
                                          paste("(g carbohydrates.L"^"-1",")")))),
           y = expression(bold(atop("Measured total carbohydrates",
                                          paste("(g carbohydrates.L"^"-1",")"))))) +
      theme_paul + 
      scale_y_log10() + 
      scale_x_log10() +
      scale_color_manual(values = c(my_color_fill[1],my_color_fill[2],my_color_fill[3])) +
      scale_fill_manual(values = c(my_color_fill[1],my_color_fill[2],my_color_fill[3])) +
      theme_paul
  
  print(validationPlot_totalCHO)
  
  
  validationPlot_totalLipids <- 
    ggplot(data = results_PhoCAssPaNS_df, aes(x = predicted_q_L_cell*predicted_nAlgae,
                                           y = totalFAMECell*cellCount*1000)) +
      geom_point(aes(color = lightClass, shape = concentrationClass), size = 3,stroke = 1.25) +
      geom_abline( slope = 1, intercept = 0,colour = "red", linewidth = 2 , linetype = "dashed") +
      scale_shape_manual(values = c(21,23,24)) +
      labs(title = "d)",
           x = expression(bold(atop("Predicted total lipids",
                                          paste("(g lipids.L"^"-1",")")))),
           y = expression(bold(atop("Measured total lipids",
                                          paste("(g lipids.L"^"-1",")"))))) +
      theme_paul + 
      scale_y_log10() + 
      scale_x_log10() +
      scale_color_manual(values = c(my_color_fill[1],my_color_fill[2],my_color_fill[3])) +
      scale_fill_manual(values = c(my_color_fill[1],my_color_fill[2],my_color_fill[3])) +
      theme_paul
  
  
  print(validationPlot_totalLipids)
  
  # Outputs from sensitivity analysis
  ## The R2 and RMSE from the fit of global concentration in lipid, biomass, and carbohydrate are computed and recorded.
  
  ### Dryweight concentration
  SS_res <- sum((results_PhoCAssPaNS_df$dryWeight - results_PhoCAssPaNS_df$predicted_xAlgae)^2 , na.rm = TRUE)
  SS_tot <- sum((results_PhoCAssPaNS_df$dryWeight - mean(results_PhoCAssPaNS_df$dryWeight,na.rm = TRUE))^2 , na.rm = TRUE)
  R2_dryweight <- 1 - SS_res/SS_tot 
  
  MRE_dryweight <- mean(abs((results_PhoCAssPaNS_df$dryWeight - results_PhoCAssPaNS_df$predicted_xAlgae)/results_PhoCAssPaNS_df$dryWeight),na.rm = TRUE)
  RMSE_dryweight <- sqrt(sum((results_PhoCAssPaNS_df$dryWeight -
                                results_PhoCAssPaNS_df$predicted_xAlgae)^2,na.rm = TRUE)/
                        length(results_PhoCAssPaNS_df$dryWeight))
  
  ### Global lipid concentration
  
  SS_res <- sum((results_PhoCAssPaNS_df$totalFAMECell*results_PhoCAssPaNS_df$cellCount*1000 -
                   results_PhoCAssPaNS_df$predicted_q_L_cell*results_PhoCAssPaNS_df$predicted_nAlgae)^2 ,
                na.rm = TRUE)
  SS_tot <- sum((results_PhoCAssPaNS_df$totalFAMECell*results_PhoCAssPaNS_df$cellCount*1000 -
                   mean(results_PhoCAssPaNS_df$totalFAMECell*results_PhoCAssPaNS_df$cellCount*1000,
                        na.rm = TRUE))^2 ,
                na.rm = TRUE)
  R2_lipids <- 1 - SS_res/SS_tot 
  MRE_lipids <- mean(abs((results_PhoCAssPaNS_df$totalFAMECell*results_PhoCAssPaNS_df$cellCount*1000 -
                           results_PhoCAssPaNS_df$predicted_q_L_cell*results_PhoCAssPaNS_df$predicted_nAlgae)/
                       (results_PhoCAssPaNS_df$totalFAMECell*results_PhoCAssPaNS_df$cellCount*1000)),na.rm = TRUE)
  RMSE_lipids <- sqrt(sum((results_PhoCAssPaNS_df$totalFAMECell*results_PhoCAssPaNS_df$cellCount*1000 -
                                  results_PhoCAssPaNS_df$predicted_q_L_cell*results_PhoCAssPaNS_df$predicted_nAlgae)^2,na.rm = TRUE)/
                        length(results_PhoCAssPaNS_df$totalFAMECell*results_PhoCAssPaNS_df$cellCount*1000))
  
  
  ### Global carbohydrate concentration
  
  SS_res <- sum((results_PhoCAssPaNS_df$totalSugarsCell*results_PhoCAssPaNS_df$cellCount*1000 -
                   results_PhoCAssPaNS_df$predicted_q_CHO_cell*results_PhoCAssPaNS_df$predicted_nAlgae)^2 ,
                na.rm = TRUE)
  SS_tot <- sum((results_PhoCAssPaNS_df$totalSugarsCell*results_PhoCAssPaNS_df$cellCount*1000 -
                   mean(results_PhoCAssPaNS_df$totalSugarsCell*results_PhoCAssPaNS_df$cellCount*1000,
                        na.rm = TRUE))^2 ,
                na.rm = TRUE)
  R2_CHO <- 1 - SS_res/SS_tot 
  MRE_CHO <- mean(abs((results_PhoCAssPaNS_df$totalSugarsCell*results_PhoCAssPaNS_df$cellCount*1000 -
                         results_PhoCAssPaNS_df$predicted_q_CHO_cell*results_PhoCAssPaNS_df$predicted_nAlgae)/
                        (results_PhoCAssPaNS_df$totalSugarsCell*results_PhoCAssPaNS_df$cellCount*1000)),na.rm = TRUE)
  RMSE_CHO <- sqrt(sum((results_PhoCAssPaNS_df$totalSugarsCell*results_PhoCAssPaNS_df$cellCount*1000 -
                                  results_PhoCAssPaNS_df$predicted_q_CHO_cell*results_PhoCAssPaNS_df$predicted_nAlgae)^2,na.rm = TRUE)/
                        length(results_PhoCAssPaNS_df$totalSugarsCell*results_PhoCAssPaNS_df$cellCount*1000))
  
  ### Cell count
  
  SS_res <- sum((results_PhoCAssPaNS_df$cellCount - results_PhoCAssPaNS_df$predicted_nAlgae/1000)^2 , na.rm = TRUE)
  SS_tot <- sum((results_PhoCAssPaNS_df$cellCount - mean(results_PhoCAssPaNS_df$cellCount,na.rm = TRUE))^2 , na.rm = TRUE)
  R2_cellcount <- 1 - SS_res/SS_tot 
  
  RMSE_cellcount <- sqrt(sum((results_PhoCAssPaNS_df$cellCount - results_PhoCAssPaNS_df$predicted_nAlgae/1000)^2,na.rm = TRUE)/
                        length(results_PhoCAssPaNS_df$cellCount))
  RMSE_cellcount/10^7 # => 10^7 cell/mL
  
  
  
  table_results_SA[i_sensitivity,] <- c(R2_dryweight,
                                        RMSE_dryweight,
                                        R2_lipids,
                                        RMSE_lipids,
                                        R2_CHO,
                                        RMSE_CHO)
  print(c("i=sensitivity =",i_sensitivity, "has terminated"))
}
```


## Graphic output: Tornado diagram

```{r, echo = TRUE, fig.width=14,fig.height=9}



# Import sensitivity analysis results
## Optional import
## To avoid running the full code to create the output of the sensitivity analysis, the possibility is given to directly import the results from the sensitivity analysis. The final tornado diagram could then be obtained thanks to running only the present section of the script
option_run_local_SA <- 0
if (option_run_local_SA == 1){
  table_results_SA <- 
     read.csv(file = paste(localPath,"/Data files/Sensitivity analysis_final.csv",
                           sep=""),
              sep = ";")
  
  table_results_SA$X <- c()
}

# Parameters list

parameter_list <- c("Flask depth",
                    "Flask diameter",
                    "Flask angle",
                    "Carbon to biomass ratio",
                    "Carbon to lipid ratio",
                    "Carbon to protein ratio",
                    "Rate of endogenous carbon consumption",
                    expression(paste("Maximum specific rate of O"[2]," production")),
                    expression("[C:N]"["char"]),
                    expression(gamma["Pm"]),
                    expression(sigma["max"]),
                    expression("K"[q[p]]),
                    expression(lambda["CHO"]),
                    expression(mu[exp]^'max'),
                    expression(alpha[q[p]^char]),
                    expression(beta[q[p]^char]),
                    expression(q[CHO]^basal),
                    expression(P[L]^max),
                    "Incident light intensity",
                    "Volume change",
                    expression(alpha[PI]),
                    expression(K["2"]))

### Part 1: with R2 as output

# R2 Lipids

## original value of output
R2_lipids_base_value <- table_results_SA[1,3]

## Reorganisation of the data for tornado plot
R2_lipids_base_vector_0 <- table_results_SA[,3]
R2_lipids_base_vector_0 <- R2_lipids_base_vector_0[-1]

R2_lipids_base_vector_1 <- matrix(NA,nrow = 24,ncol = 4)
R2_lipids_base_vector_1 <- as.data.frame(R2_lipids_base_vector_1)
R2_lipids_base_vector_1[,1] <- parameter_list

for (i in 1:24){
  R2_lipids_base_vector_1[i,2] <- R2_lipids_base_vector_0[2*i-1] # Min value
  R2_lipids_base_vector_1[i,3] <- R2_lipids_base_vector_0[2*i] # Max value
  R2_lipids_base_vector_1[i,4] <- max(abs(R2_lipids_base_vector_1[i,2]-R2_lipids_base_value),
                                 abs(R2_lipids_base_vector_1[i,3]-R2_lipids_base_value)) # Max delta from central value
}


## Order base matrix
new_order <- order(R2_lipids_base_vector_1[,4], decreasing = FALSE)
R2_lipids_base_vector_sorted <- R2_lipids_base_vector_1[new_order,]


## width of bars in tornado plot
width <- 0.95

## Creation of data frame for tornado plot
R2_lipids_df <- data.frame(
  y_min = rep(seq(1,24,1) - width/2,2),
  y_max = rep(seq(1,24,1) + width/2,2),
  x_min = c(R2_lipids_base_vector_sorted[,2],rep(R2_lipids_base_value,24)),
  x_max = c(rep(R2_lipids_base_value,24),R2_lipids_base_vector_sorted[,3]),
  fillValue = c(rep("Negative error",24),rep("Positive error",24)),
  facetValue = rep("Lipids",48),
  base_value = rep(R2_lipids_base_value,48)
)


# R2 Biomass

## original value of output
R2_biomass_base_value <- table_results_SA[1,1]

## Reorganisation of the data for tornado plot
R2_biomass_base_vector_0 <- table_results_SA[,1]
R2_biomass_base_vector_0 <- R2_biomass_base_vector_0[-1]

R2_biomass_base_vector_1 <- matrix(NA,nrow = 24,ncol = 4)
R2_biomass_base_vector_1 <- as.data.frame(R2_biomass_base_vector_1)
R2_biomass_base_vector_1[,1] <- parameter_list

for (i in 1:24){
  R2_biomass_base_vector_1[i,2] <- R2_biomass_base_vector_0[2*i-1] # Min value
  R2_biomass_base_vector_1[i,3] <- R2_biomass_base_vector_0[2*i] # Max value
  R2_biomass_base_vector_1[i,4] <- max(abs(R2_biomass_base_vector_1[i,2]-R2_biomass_base_value),
                                 abs(R2_biomass_base_vector_1[i,3]-R2_biomass_base_value)) # Max delta from central value
}


## Order base matrix
R2_biomass_base_vector_sorted <- R2_biomass_base_vector_1[new_order,]


## Creation of data frame for tornado plot
R2_biomass_df <- data.frame(
  y_min = rep(seq(1,24,1) - width/2,2),
  y_max = rep(seq(1,24,1) + width/2,2),
  x_min = c(R2_biomass_base_vector_sorted[,2],rep(R2_biomass_base_value,24)),
  x_max = c(rep(R2_biomass_base_value,24),R2_biomass_base_vector_sorted[,3]),
  fillValue = c(rep("Negative error",24),rep("Positive error",24)),
  facetValue = rep("Biomass",48),
  base_value = rep(R2_biomass_base_value,48)
)




# R2 Carbohydrates

## original value of output
R2_CHO_base_value <- table_results_SA[1,5]

## Reorganisation of the data for tornado plot
R2_CHO_base_vector_0 <- table_results_SA[,5]
R2_CHO_base_vector_0 <- R2_CHO_base_vector_0[-1]

R2_CHO_base_vector_1 <- matrix(NA,nrow = 24,ncol = 4)
R2_CHO_base_vector_1 <- as.data.frame(R2_CHO_base_vector_1)
R2_CHO_base_vector_1[,1] <- parameter_list

for (i in 1:24){
  R2_CHO_base_vector_1[i,2] <- R2_CHO_base_vector_0[2*i-1] # Min value
  R2_CHO_base_vector_1[i,3] <- R2_CHO_base_vector_0[2*i] # Max value
  R2_CHO_base_vector_1[i,4] <- max(abs(R2_CHO_base_vector_1[i,2]-R2_CHO_base_value),
                                 abs(R2_CHO_base_vector_1[i,3]-R2_CHO_base_value)) # Max delta from central value
}


## Order base matrix
R2_CHO_base_vector_sorted <- R2_CHO_base_vector_1[new_order,]




## width of columns in plot (value between 0 and 1)
width <- 0.95

# Creation of data frame for tornado plot
R2_CHO_df <- data.frame(
  y_min = rep(seq(1,24,1) - width/2,2),
  y_max = rep(seq(1,24,1) + width/2,2),
  x_min = c(R2_CHO_base_vector_sorted[,2],rep(R2_CHO_base_value,24)),
  x_max = c(rep(R2_CHO_base_value,24),R2_CHO_base_vector_sorted[,3]),
  fillValue = c(rep("Negative error",24),rep("Positive error",24)),
  facetValue = rep("Carbohydrates",48),
  base_value = rep(R2_CHO_base_value,48)
)


# Final plot

## Final data frame organisation for facetted plot
final_SA_df <- rbind(R2_lipids_df, R2_biomass_df , R2_CHO_df)

final_SA_plot <-
  ggplot() + 
  geom_rect(data = final_SA_df, 
            aes(ymax = y_max, ymin = y_min, xmax = x_max, xmin = x_min, fill = fillValue), alpha = 0.95) +
  # geom_vline(aes(xintercept = base_value)) +
  scale_y_continuous(breaks = c(1:24), 
                     labels = R2_CHO_base_vector_sorted[,1]) +
  xlab(expression(bold("Model R"^2))) +
  theme_paul +
  theme(axis.title.y=element_blank(), legend.position = 'bottom',
        # legend.title = element_blank(),
        axis.text.y = element_text(size = 15)) +
  facet_wrap(~ factor(facetValue,c("Lipids","Biomass","Carbohydrates")),
             scales = "free_x"
             )

ggsave(
    "Figure_SA_R2.png",
    plot = final_SA_plot,
    device = "png",
    scale = 1,
    width = 14,
    height = 9,
    units = "in",
    dpi = 1000,
    limitsize = TRUE,
    bg = "white"
  )

### Part II: with RMSE as output

# Import sensitivity analysis results
## Optional import
## To avoid running the full code to create the output of the sensitivity analysis, the possibility is given to directly import the results from the sensitivity analysis. The final tornado diagram could then be obtained thanks to running only the present section of the script

# Parameters list

parameter_list <- c("Time discretisation",
                    "Volume discretisation",
                    "Flask depth",
                    "Flask diameter",
                    "Flask angle",
                    "Carbon to biomass ratio",
                    "Carbon to lipid ratio",
                    "Carbon to protein ratio",
                    "Rate of endogenous carbon consumption",
                    expression(paste("Maximum specific rate of O"[2]," production")),
                    expression("[C:N]"["char"]),
                    expression(gamma["Pm"]),
                    expression(sigma["max"]),
                    expression("K"[q[p]]),
                    expression(lambda["CHO"]),
                    expression(mu[exp]^'max'),
                    expression(alpha[q[p]^char]),
                    expression(beta[q[p]^char]),
                    expression(q[CHO]^basal),
                    expression(P[L]^max),
                    "Incident light intensity",
                    "Volume change",
                    expression(alpha[PI]),
                    expression(K["2"]))


# RMSE Lipids

## original value of output
RMSE_lipids_base_value <- table_results_SA[1,4]

## Reorganisation of the data for tornado plot
RMSE_lipids_base_vector_0 <- table_results_SA[,4]
RMSE_lipids_base_vector_0 <- RMSE_lipids_base_vector_0[-1]

RMSE_lipids_base_vector_1 <- matrix(NA,nrow = 24,ncol = 4)
RMSE_lipids_base_vector_1 <- as.data.frame(RMSE_lipids_base_vector_1)
RMSE_lipids_base_vector_1[,1] <- parameter_list

for (i in 1:24){
  RMSE_lipids_base_vector_1[i,2] <- RMSE_lipids_base_vector_0[2*i-1] # Min value
  RMSE_lipids_base_vector_1[i,3] <- RMSE_lipids_base_vector_0[2*i] # Max value
  RMSE_lipids_base_vector_1[i,4] <- max(abs(RMSE_lipids_base_vector_1[i,2]-RMSE_lipids_base_value),
                                 abs(RMSE_lipids_base_vector_1[i,3]-RMSE_lipids_base_value)) # Max delta from central value
}


## Order base matrix
new_order <- order(RMSE_lipids_base_vector_1[,4], decreasing = FALSE)
RMSE_lipids_base_vector_sorted <- RMSE_lipids_base_vector_1[new_order,]


## width of bars in tornado plot
width <- 0.95

## Creation of data frame for tornado plot
RMSE_lipids_df <- data.frame(
  y_min = rep(seq(1,24,1) - width/2,2),
  y_max = rep(seq(1,24,1) + width/2,2),
  x_min = c(RMSE_lipids_base_vector_sorted[,2],rep(RMSE_lipids_base_value,24)),
  x_max = c(rep(RMSE_lipids_base_value,24),RMSE_lipids_base_vector_sorted[,3]),
  fillValue = c(rep("Negative error",24),rep("Positive error",24)),
  facetValue = rep("Lipids",48),
  base_value = rep(RMSE_lipids_base_value,48)
)


# RMSE Biomass

## original value of output
RMSE_biomass_base_value <- table_results_SA[1,2]

## Reorganisation of the data for tornado plot
RMSE_biomass_base_vector_0 <- table_results_SA[,2]
RMSE_biomass_base_vector_0 <- RMSE_biomass_base_vector_0[-1]

RMSE_biomass_base_vector_1 <- matrix(NA,nrow = 24,ncol = 4)
RMSE_biomass_base_vector_1 <- as.data.frame(RMSE_biomass_base_vector_1)
RMSE_biomass_base_vector_1[,1] <- parameter_list

for (i in 1:24){
  RMSE_biomass_base_vector_1[i,2] <- RMSE_biomass_base_vector_0[2*i-1] # Min value
  RMSE_biomass_base_vector_1[i,3] <- RMSE_biomass_base_vector_0[2*i] # Max value
  RMSE_biomass_base_vector_1[i,4] <- max(abs(RMSE_biomass_base_vector_1[i,2]-RMSE_biomass_base_value),
                                 abs(RMSE_biomass_base_vector_1[i,3]-RMSE_biomass_base_value)) # Max delta from central value
}


## Order base matrix
RMSE_biomass_base_vector_sorted <- RMSE_biomass_base_vector_1[new_order,]


## Creation of data frame for tornado plot
RMSE_biomass_df <- data.frame(
  y_min = rep(seq(1,24,1) - width/2,2),
  y_max = rep(seq(1,24,1) + width/2,2),
  x_min = c(RMSE_biomass_base_vector_sorted[,2],rep(RMSE_biomass_base_value,24)),
  x_max = c(rep(RMSE_biomass_base_value,24),RMSE_biomass_base_vector_sorted[,3]),
  fillValue = c(rep("Negative error",24),rep("Positive error",24)),
  facetValue = rep("Biomass",48),
  base_value = rep(RMSE_biomass_base_value,48)
)




# RMSE Carbohydrates

## original value of output
RMSE_CHO_base_value <- table_results_SA[1,6]

## Reorganisation of the data for tornado plot
RMSE_CHO_base_vector_0 <- table_results_SA[,6]
RMSE_CHO_base_vector_0 <- RMSE_CHO_base_vector_0[-1]

RMSE_CHO_base_vector_1 <- matrix(NA,nrow = 24,ncol = 4)
RMSE_CHO_base_vector_1 <- as.data.frame(RMSE_CHO_base_vector_1)
RMSE_CHO_base_vector_1[,1] <- parameter_list

for (i in 1:24){
  RMSE_CHO_base_vector_1[i,2] <- RMSE_CHO_base_vector_0[2*i-1] # Min value
  RMSE_CHO_base_vector_1[i,3] <- RMSE_CHO_base_vector_0[2*i] # Max value
  RMSE_CHO_base_vector_1[i,4] <- max(abs(RMSE_CHO_base_vector_1[i,2]-RMSE_CHO_base_value),
                                 abs(RMSE_CHO_base_vector_1[i,3]-RMSE_CHO_base_value)) # Max delta from central value
}


## Order base matrix
RMSE_CHO_base_vector_sorted <- RMSE_CHO_base_vector_1[new_order,]




## width of columns in plot (value between 0 and 1)
width <- 0.95

# Creation of data frame for tornado plot
RMSE_CHO_df <- data.frame(
  y_min = rep(seq(1,24,1) - width/2,2),
  y_max = rep(seq(1,24,1) + width/2,2),
  x_min = c(RMSE_CHO_base_vector_sorted[,2],rep(RMSE_CHO_base_value,24)),
  x_max = c(rep(RMSE_CHO_base_value,24),RMSE_CHO_base_vector_sorted[,3]),
  fillValue = c(rep("Negative error",24),rep("Positive error",24)),
  facetValue = rep("Carbohydrates",48),
  base_value = rep(RMSE_CHO_base_value,48)
)


# Final plot

## Final data frame organisation for facetted plot
final_SA_df <- rbind(RMSE_lipids_df, RMSE_biomass_df , RMSE_CHO_df)

final_SA_plot <-
  ggplot() + 
  geom_rect(data = final_SA_df, 
            aes(ymax = y_max, ymin = y_min, xmax = x_max, xmin = x_min, fill = fillValue), alpha = 0.95) +
  # geom_vline(aes(xintercept = base_value)) +
  scale_y_continuous(breaks = c(1:24), 
                     labels = RMSE_CHO_base_vector_sorted[,1]) +
  xlab(expression(bold("Model R"^2))) +
  theme_paul +
  theme(axis.title.y=element_blank(), legend.position = 'bottom',
        # legend.title = element_blank(),
        axis.text.y = element_text(size = 15)) +
  facet_wrap(~ factor(facetValue,c("Lipids","Biomass","Carbohydrates")),
             scales = "free_x"
             )

ggsave(
    "Figure_SA_RMSE.png",
    plot = final_SA_plot,
    device = "png",
    scale = 1,
    width = 14,
    height = 9,
    units = "in",
    dpi = 1000,
    limitsize = TRUE,
    bg = "white"
  )
```

```{r stop capsule}
if (lastSimulation == 0){
 stop()
}
```

# Miscellaneous

## Link between decrease of pigment and light irradiance

### Calculation

```{r, echo = include_code,fig.height=6, fig.width=8}


# Determining a rate of decrease for pigment content specifically to biomass dry-weight concentration

concentrationClassList = c("0.1 g.L-1","0.3 g.L-1","1.0 g.L-1")
lightClassList = c("25%","50%","100%")

## Initialisation of vectors for storage of the results
spec_chla_degradation_rate <- rep(NA,9)
spec_chla_degradation_rate_std <- rep(NA,9)
spec_chlb_degradation_rate <- rep(NA,9)
spec_chlb_degradation_rate_std <- rep(NA,9)
spec_carot_degradation_rate <- rep(NA,9)
spec_carot_degradation_rate_std <- rep(NA,9)
spec_totalPigment_degradation_rate <- rep(NA,9)
spec_totalPigment_degradation_rate_std <- rep(NA,9)

R2_table <- matrix(data = NA, nrow = 9,ncol = 4)
pVal_table <- matrix(data = NA, nrow = 9,ncol = 4)

for (i_concentration in (1:3)){
  for (j_light in (1:3)){
    
    # Extraction of single rector data
    data_reduced <- subset(results_PhoCAssPaNS_df, concentrationClass == concentrationClassList[i_concentration])
    data_reduced <- subset(data_reduced, data_reduced$lightClass == lightClassList[j_light])
    
    # log transformation of pigment data for linearisation
    data_reduced$logSpecTotalChla <- log10(data_reduced$totalChlaSpecificWeight)
    data_reduced$logSpecTotalChlb <- log10(data_reduced$totalChlbSpecificWeight)
    data_reduced$logSpecTotalCarot <- log10(data_reduced$totalCarotSpecificWeight)
    data_reduced$logSpecTotalPigment <-
      log10(data_reduced$totalChlaSpecificWeight +
         data_reduced$totalChlbSpecificWeight +
         data_reduced$totalCarotSpecificWeight)

    # Calculation for chlorophyll-a
    
    local_lm_chla <- lm(data = data_reduced, logSpecTotalChla ~ day )
    
    spec_chla_degradation_rate[3*(i_concentration - 1) + j_light] <- 
      -summary(local_lm_chla)$coefficients[2,1]
    spec_chla_degradation_rate_std[3*(i_concentration - 1) + j_light] <-
      summary(local_lm_chla)$coefficients[2,2]
    
    R2_table[3*(i_concentration - 1) + j_light,1] <- summary(local_lm_chla)$r.squared
    pVal_table[3*(i_concentration - 1) + j_light,1] <- summary(local_lm_chla)$coefficients[2,4]
    
    plot(data_reduced$day,data_reduced$logSpecTotalChla)
    abline(local_lm_chla,col = "red",lwd = 2)
    
    # Calculation for chlorophyll-b
    
    local_lm_chlb <- lm(data = data_reduced, logSpecTotalChlb ~ day )
    
    spec_chlb_degradation_rate[3*(i_concentration - 1) + j_light] <- 
      -summary(local_lm_chlb)$coefficients[2,1]
    spec_chlb_degradation_rate_std[3*(i_concentration - 1) + j_light] <-
      summary(local_lm_chlb)$coefficients[2,2]
    
    plot(data_reduced$day,data_reduced$logSpecTotalChlb)
    abline(local_lm_chlb,col = "red",lwd = 2)
    
    R2_table[3*(i_concentration - 1) + j_light,2] <- summary(local_lm_chlb)$r.squared
    pVal_table[3*(i_concentration - 1) + j_light,2] <- summary(local_lm_chlb)$coefficients[2,4]
    
    
    # Calculation for carotenoids
    ## Carotenoids degradation rate was only computed from day 2 due to an initial increase noted in most reactors.
    local_lm_carot <- lm(data = subset(data_reduced, day >= 0.75), logSpecTotalCarot ~ day )
    
    spec_carot_degradation_rate[3*(i_concentration - 1) + j_light] <- 
      -summary(local_lm_carot)$coefficients[2,1]
    spec_carot_degradation_rate_std[3*(i_concentration - 1) + j_light] <-
      summary(local_lm_carot)$coefficients[2,2]
    
    plot(data_reduced$day,data_reduced$logSpecTotalCarot)
    abline(local_lm_carot,col = "red",lwd = 2)
    
    R2_table[3*(i_concentration - 1) + j_light,3] <- summary(local_lm_carot)$r.squared
    pVal_table[3*(i_concentration - 1) + j_light,3] <- summary(local_lm_carot)$coefficients[2,4]
    
    # Calculation for total pigments
    
    local_lm_totalPigment <- lm(data = data_reduced, logSpecTotalPigment ~ day )
    
    spec_totalPigment_degradation_rate[3*(i_concentration - 1) + j_light] <- 
      -summary(local_lm_totalPigment)$coefficients[2,1]
    spec_totalPigment_degradation_rate_std[3*(i_concentration - 1) + j_light] <-
      summary(local_lm_totalPigment)$coefficients[2,2]
    
    plot(data_reduced$day,data_reduced$logSpecTotalPigment)
    abline(local_lm_totalPigment,col = "red",lwd = 2)
    
    R2_table[3*(i_concentration - 1) + j_light,4] <- summary(local_lm_totalPigment)$r.squared
    pVal_table[3*(i_concentration - 1) + j_light,4] <- summary(local_lm_totalPigment)$coefficients[2,4]
  }
}

# Data recollection

reactorPhoCAssPaNS_df$specChlaDegradationRate <- spec_chla_degradation_rate
reactorPhoCAssPaNS_df$specChlaDegradationRate_rel_error <- 
  abs(1.96*spec_chla_degradation_rate_std/spec_chla_degradation_rate)

reactorPhoCAssPaNS_df$specChlbDegradationRate <- spec_chlb_degradation_rate
reactorPhoCAssPaNS_df$specChlbDegradationRate_rel_error <- 
  abs(1.96*spec_chlb_degradation_rate_std/spec_chlb_degradation_rate)

reactorPhoCAssPaNS_df$specCarotDegradationRate <- spec_carot_degradation_rate
reactorPhoCAssPaNS_df$specCarotDegradationRate_rel_error <- 
  abs(1.96*spec_carot_degradation_rate_std/spec_carot_degradation_rate)

reactorPhoCAssPaNS_df$specTotalPigmentDegradationRate <- spec_totalPigment_degradation_rate
reactorPhoCAssPaNS_df$specTotalPigmentDegradationRate_rel_error <- 
  abs(1.96*spec_totalPigment_degradation_rate_std/spec_totalPigment_degradation_rate)

# Plot for chlorophyll-a
plot_chla_deg <- 
  ggplot(data = reactorPhoCAssPaNS_df,aes(x = lightDensity,y = specChlaDegradationRate, colour = lightClass,shape = concentrationClass)) +
    geom_point(size = 3,stroke = 1.25) +
    geom_errorbarh(aes(xmin = (lightDensity -1.96*lightDensityStd), xmax = (lightDensity + 1.96*lightDensityStd)),
                  stroke = 1.25, height = 0.01) +
    geom_errorbar(aes(ymin = specChlaDegradationRate*(1 - specChlaDegradationRate_rel_error),
                      ymax = specChlaDegradationRate*(1 + specChlaDegradationRate_rel_error)),
                  stroke = 1.25, width = 2) +
    scale_shape_manual(values = c(1,2,4),na.translate = FALSE) +
    ylim(c(0,0.16)) +
    labs(title = "a)",
         x = expression(bold(atop("Dryweight specific light density ",
                                   paste("(µmol.(g DW.s)"^"-1","])")))),
         y = expression(bold(atop("Degradation rate of mass specific",
                                  paste("chlorophyll-a (d"^"-1",")"))))) +
    theme_paul +
    scale_color_manual(values = c(my_color_fill[1],my_color_fill[2],my_color_fill[3])) 

pig_deg_rate_matrix <- 
  matrix(c(spec_chla_degradation_rate,spec_chla_degradation_rate_std,
           spec_chlb_degradation_rate,spec_chlb_degradation_rate_std,
           spec_carot_degradation_rate,spec_carot_degradation_rate_std,
           spec_totalPigment_degradation_rate,spec_totalPigment_degradation_rate_std),
         nrow = 9)
# Results from the analysis are stored in a matrix such that:
## Col 1 , 3 , 5 , 7: degradation rate of specific content of resp. chlorophyll-a, chlorophyll-b, carotenoids, and total pigments
## Col 2, 4, 6, 8 : standard deviation on the degradation rate of specific content of resp. chlorophyll-a, chlorophyll-b, carotenoids, and total pigments
## Col 9-12: R2 on the regression of different pigment specific degradation rate (same order)
## Col 13-16: p-value on the regression of different pigment specific degradation rate (same order)

pig_deg_rate_matrix <- 
  cbind(pig_deg_rate_matrix,R2_table,pVal_table)
       
```

### Plot development

```{r, echo = include_code}

# Plot for chlorophyll-b
plot_chlb_deg <- 
  ggplot(data = reactorPhoCAssPaNS_df,aes(x = lightDensity,y = specChlbDegradationRate, colour = lightClass,shape = concentrationClass)) +
    geom_point(size = 3,stroke = 1.25) +
    geom_errorbarh(aes(xmin = (lightDensity -1.96*lightDensityStd), xmax = (lightDensity + 1.96*lightDensityStd)),
                  stroke = 1.25, height = 0.005) +
    geom_errorbar(aes(ymin = specChlbDegradationRate*(1 - specChlbDegradationRate_rel_error),
                      ymax = specChlbDegradationRate*(1 + specChlbDegradationRate_rel_error)),
                  stroke = 1.25, width = 1) +
    scale_shape_manual(values = c(1,2,4),na.translate = FALSE) +
    ylim(c(0,0.16)) +
    labs(title = "b)",
         x = expression(bold(atop("Dryweight specific light density ",
                                   paste("(µmol.(g DW.s)"^"-1","])")))),
         y = expression(bold(atop("Degradation rate of mass specific",
                                  paste("chlorophyll-b (d"^"-1",")"))))) +
    theme_paul +
    scale_color_manual(values = c(my_color_fill[1],my_color_fill[2],my_color_fill[3])) 
  



# Plot for carotenoids
plot_carot_deg <- 
  ggplot(data = reactorPhoCAssPaNS_df,aes(x = lightDensity,y = specCarotDegradationRate, colour = lightClass,shape = concentrationClass)) +
    geom_point(size = 3,stroke = 1.25) +
    geom_errorbarh(aes(xmin = (lightDensity -1.96*lightDensityStd), xmax = (lightDensity + 1.96*lightDensityStd)),
                  stroke = 1.25, height = 0.005) +
    geom_errorbar(aes(ymin = specCarotDegradationRate*(1 - specCarotDegradationRate_rel_error),
                      ymax = specCarotDegradationRate*(1 + specCarotDegradationRate_rel_error)),
                  stroke = 1.25, width = 1) +
    scale_shape_manual(values = c(1,2,4),na.translate = FALSE) +
    ylim(c(0,0.16)) +
    labs(title = "c)",
         x = expression(bold(atop("Dryweight specific light density ",
                                   paste("(µmol.(g DW.s)"^"-1","])")))),
         y = expression(bold(atop("Degradation rate of mass specific",
                                  paste("carotenoids (d"^"-1",")"))))) +
    theme_paul +
    scale_color_manual(values = c(my_color_fill[1],my_color_fill[2],my_color_fill[3])) 
  

# Plot for total pigment
plot_pigment_total_deg <- 
  ggplot(data = reactorPhoCAssPaNS_df,aes(x = lightDensity,y = specTotalPigmentDegradationRate, colour = lightClass,shape = concentrationClass)) +
    geom_point(size = 3,stroke = 1.25) +
    geom_errorbarh(aes(xmin = (lightDensity -1.96*lightDensityStd), xmax = (lightDensity + 1.96*lightDensityStd)),
                  stroke = 1.25, height = 0.02) +
    geom_errorbar(aes(ymin = specTotalPigmentDegradationRate*(1 - specTotalPigmentDegradationRate_rel_error),
                      ymax = specTotalPigmentDegradationRate*(1 + specTotalPigmentDegradationRate_rel_error)),
                  stroke = 1.25, width = 1) +
    scale_shape_manual(values = c(1,2,4),na.translate = FALSE) +
    ylim(c(0,0.16)) +
    labs(title = "d)",
         x = expression(bold(atop("Dryweight specific light density ",
                                   paste("(µmol.(g DW.s)"^"-1","])")))),
         y = expression(bold(atop("Degradation rate of mass specific",
                                  paste("total pigment (d"^"-1",")"))))) +
    theme_paul +
    scale_color_manual(values = c(my_color_fill[1],my_color_fill[2],my_color_fill[3])) 

```

### Final plot

```{r, echo = include_code,fig.height=10, fig.width=12}

  

plot_pigment_total_deg <- plot_pigment_total_deg +
  theme(legend.box = "vertical")

g_legend <- function(a.gplot){
  tmp <- ggplot_gtable(ggplot_build(a.gplot))
  leg <- which(sapply(tmp$grobs, function(x) x$name) == "guide-box")
  legend <- tmp$grobs[[leg]]
  return(legend)
}

mylegend <- g_legend(plot_pigment_total_deg)


grid.arrange(arrangeGrob(plot_chla_deg + theme(legend.position="none", axis.title.x = element_blank()),
                           plot_chlb_deg + theme(legend.position="none",axis.title.x = element_blank()),
                           plot_carot_deg  + theme(legend.position="none"),
                           plot_pigment_total_deg + theme(legend.position="none"),
                           nrow=2,heights = c(5,5.5),widths = c(5,5)),
               mylegend,ncol = 2,widths = c(5,1))
```



